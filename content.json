{"meta":{"title":"Changbin He's Website","subtitle":null,"description":"About crypto|blockchain","author":"kvh","url":"https://kvh.io","root":"/"},"pages":[],"posts":[{"title":"zksync 存储：sparse-merkle-tree 存储","slug":"sparse-merkle-tree","date":"2021-02-09T12:02:00.000Z","updated":"2021-06-13T17:46:33.469Z","comments":true,"path":"sparse-merkle-tree.html","link":"","permalink":"https://kvh.io/sparse-merkle-tree.html","excerpt":"","text":"简介 本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。 merkle tree merkle tree 常用于区块链存储数据和快速校验数据。其构造特点是叶节点使用数据的 hash 进行标记，中间节点使用所有子节点的 hash进行标记。 merkle-tree 对于 merke tree 的操作，包含：插入节点、获取树根、计算 merkle 证明、检验 merkle 证明。 计算 merkle 证明包含： 1）计算存在证明 2）计算不存在证明 在原始的 merkle tree 上，很容易生成存在性证明，但是难以生成不存在证明。 sparse merkle tree 为了解决这个问题，同时零知识证明也要求账号在树上的位置具有确定性，因此引入 sparse merkle tree，有如下特点： 1234一棵满二叉树数据是索引的，每个数据会放到对应的索引的叶子上存在性证明，merkle path不存在性证明，需要证明是 null 优化 1）预计算空值哈希 由于大部分情况下，树并不会真的满，而是非常的稀疏。可以预计算H(null)、H(H(null)|H(null))、H(H(H(null)|H(null))|H(H(null)|H(null)))等层级上的值，达到加速的效果。 2）并行计算左右子树哈希 H(H(left)|H(right)) 这类操作要求 快速计算左右子树的哈希值，并行计算可以计算。 实现 rust-matter-labs js-iden3 golang-iden3 文献参考 whats-a-sparse-merkle-tree sparse-merkle-trees-visual-introduction","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"zkp","slug":"zkp","permalink":"https://kvh.io/tags/zkp/"}]},{"title":"关于智能钱包","slug":"smart-wallet","date":"2021-01-13T01:58:57.000Z","updated":"2021-01-13T02:33:24.629Z","comments":true,"path":"smart-wallet.html","link":"","permalink":"https://kvh.io/smart-wallet.html","excerpt":"","text":"Vitalik 在 1-11 在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。 原文不赘述，下文将主要记录要点和思考。 原文 英文 中文 要点 guardian 的选择 抵抗 guardian 联合作恶： 1）不公开 对 list 进行哈希 fulllist，如何获得？ guardian 确定性的生成一个用于恢复的地址；只在需要恢复的时候用到一次； 2）来自不同的 social circle 对于加密价值的讨论 有一种论调认为，社交恢复，是恢复到了相信人，是对区块链和加密的背叛。 Vitalik 认为，加密不是移除所有的信任，其目的是提供更多的选择，来决定去相信谁；允许可控的信任：容许某些人代替做某些事，而没有能力做所有事。 对抗小偷 sign key 可能丢失，可以增加一个保险柜功能，把 token 进入其中；在保险柜中的 token，交易可消。在发起交易和交易生效中间，增加了一个可撤回的缓冲期；还可以通过增加 vault 的可编程性支持更多的功能。 Argent 和路印等现行社交钱包的两大挑战 121）对中继的依赖2）交易费高 目前的流行做法，是中继官方的签名的在链下进行，收集之后打包发送到服务器； 对于这里的「收集」的概念有一定疑问； 假设一个用户有 7 个guardian，路印是收集齐了4 个guardian的签名，才发送到链上？ 两大挑战的解决方案： 当前改造方式 generalized decentralized relayer network 以太坊加油站（与 heco 的元交易有异曲同工之处） allow transactions to begin from contracts 修改以太坊协议，允许合约主动发起交易。 彻底改造方式：迁移到 layer2 为什么能解决问题？资金首先来自 1 层？在二层里面实现智能钱包逻辑？ 思考 如果是一个定制的链的场景，可以采用更激进的方式来改造链，是否可以定制一个对用户友好的钱包系统？ 思考免费钱包或者网络可能性，可以使用原生元交易，对交易费进行补贴。 总结 钱包本身存在易用性和安全性的矛盾。公私钥、备份助记词这种操作，对于习惯了只记录一个 pin 的 web2.0 用户而言不友好，这可能也是阻碍区块链向更大量的用户普及的一部分原因。 支持社交恢复的智能钱包，免去了用户记录助记词的困难，将安全性托付于社交关系，易用性上有了提升，但是也存在一些问题。Vitalik 难得之处在于，不止提出问题，还提供了解决方案的思考。 当前以太坊社区，开始逐步理解和使用 layer2，将 layer2 和智能钱包结合，将有利于以太坊网络向更大体量的用户推广。 欢迎留言或者联系博主对相关问题讨论！","categories":[{"name":"blockchain","slug":"blockchain","permalink":"https://kvh.io/categories/blockchain/"}],"tags":[{"name":"wallet","slug":"wallet","permalink":"https://kvh.io/tags/wallet/"}]},{"title":"0x协议-介绍","slug":"0x-intro","date":"2021-01-01T02:49:05.000Z","updated":"2021-01-13T01:42:18.816Z","comments":true,"path":"0x-intro.html","link":"","permalink":"https://kvh.io/0x-intro.html","excerpt":"","text":"核心 链下撮合（订单簿在链下）、链上结算（资金划转） 角色 maker 挂单者 taker 吃单者 实现 maker 创建订单信息，签名 1234567891011makerAddresstakerAddressmakerAssetDatatakerAssetDatamakerAssetAmounttakerAssetAmountexpirationTimeSecondsfee...签名哈希 注意： takerAddress 是空——直到taker接单 relayer 链下撮合 taker 接受 maker 的订单，签名，提交到智能合约 链上结算 合约实现资金划转 问题 1）maker 如何取消交易 订单过期 2）交易效率 12预先检查链上成交 与 uniswap 对比 1）uni 有流动性提供者，一个 pair 的两个 token 都需要提供 2）uni 的价格是链上发现的 3）0x 只是交易意愿撮合，用户的资产不需要抵押 总结 0x 协议核心是定义了一个「链下撮合，链下成交」的结构，但正式由于分离了链上和链下，其成交效率有一定折扣。 其后继者 uniswap 是一个整体闭环。 参考 0x-protocol 0x-intro-jnse","categories":[{"name":"blockchain","slug":"blockchain","permalink":"https://kvh.io/categories/blockchain/"}],"tags":[{"name":"defi","slug":"defi","permalink":"https://kvh.io/tags/defi/"}]},{"title":"《你就是孩子最好的玩具》读书笔记","slug":"reading-emotion-coaching","date":"2020-10-05T10:05:12.000Z","updated":"2021-01-13T01:42:18.826Z","comments":true,"path":"reading-emotion-coaching.html","link":"","permalink":"https://kvh.io/reading-emotion-coaching.html","excerpt":"","text":"前言 随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。 人生来就是一张白纸，父母是第一位老师，家庭教育对于塑造一个人的品格，有关键作用。 在教育这个事情上，说实话，也是战战兢兢，一不留神，就可能把原先的不那么正确的观念带给了孩子。 这个时候，不能盲目，不能下意识，只能多阅读、多思考、多观察、多实践，或许能减少一些内心的焦虑。 这是一本儿童教育的书，核心观点是对孩子进行情感引导式教育。作者摒弃了控制式、放任式、奖励式、惩罚式的教育。等等，这都是不对的？感觉颠覆了三观。细读下来，发现奖励和惩罚还是会在，不过占主导的是发挥同理心，进行情感引导和沟通。 这本书又是一本手册类的书，列举儿童 0-7 岁能出现的大部分让家长抓狂的情形再现、原因分析和解决方案，是值得多次翻阅和查找的一本书。 🏷信息卡片 123456789101112名称：《你就是孩子最好的玩具》作者:&nbsp;金伯莉·布雷恩译者:&nbsp;夏欣茁出版年:&nbsp;2011-8页数:&nbsp;191定价:&nbsp;29.80元ISBN:&nbsp;9787550102996豆瓣评分：&nbsp; &nbsp; &nbsp;&nbsp; 8.2起止时间：&nbsp; &nbsp; &nbsp;&nbsp; 2020.10.05--2020.10.05阅读次数：&nbsp; &nbsp; &nbsp;&nbsp; 1推荐指数：&nbsp; &nbsp; &nbsp; 🌟🌟🌟🌟获奖情况： 🌱写作背景 作者是儿童教育专家，最早提出「情感引导式教育」概念，同时也是 2 个男孩的母亲。 📒原著呈现 p9 你是希望孩子处于对你的恐惧而听从你的建议，还是处于对你的爱戴和尊重而听从你的建议呢？ p149 我们唯有甘心忍耐，才可能从刻意逃避转为欣然面对 🖇书摘&amp;批注 1234567891011121314151617181920212223242526272829303132333435363738394041424344p3 情感引导是什么：想孩子传授情感规则，让他们知道如何辨认情感并且以恰当的方式来表达。懂得辨认和他人的情感，是形成和谐的人际关系的关键。p6 常见误区：1）控制和放任型2）轻视、低估和否定孩子的感受 3）采用外部激励和奖赏的手段 4）以消极后果作为惩罚小朋友没有去权利生气？不是的，小朋友要学会知道自己是否在生气，为什么生气，如何处理情绪。p33 同情的力量所谓同理心——站在别人角度看问题；对待小朋友，也需要如此。p38 情感引导的关键步骤：1）播下种子——提前预告2）观察和判断——了解孩子的情况3）聆听——倾听孩子的感受4）体察和同情期前预告接下来要发生的事情，以一种协商的姿态告知孩子，争取他的配合。p56 安抚毯、毛绒玩具作者提到她的孩子对于安抚毯有强烈的依赖。p62 不眠之夜在某些转折点之前，可能会折腾一阵子——例如突然开始说话之前p63 带婴儿外出做好心理建设最重要——孩子不大可能能长时间配合p79 为什么打屁股没用打屁股会影响孩子的学习能力，教唆使用暴力，体罚会造成伤害，打击自信心因为暴力而屈服，并不是真的理解，也没有主观产生能动性p92 奖励无法奏效核心是孩子应该是靠情感来激励，而不是物质；幸福感只能来源自身；久而久之，孩子会对奖励有过高的期望或者依赖。准确的夸赞孩子，而不是使用某种激励手段。p96 孩子耍脾气怎么办不要针锋相对提前计划，表达对孩子的理解和同情，保持冷静，不去理睬p149 无条件的爱了解自己，了解孩子 🙋‍♀️总结感悟 核心观点是父母与孩子建立良好的沟通和互动关系，理解、疏导孩各类「不良」行为。进而形成亲子之间的感情纽带，教会孩子正确理解和处理自己的情感，成长为一个具有良好社交能力的人。 孩子发展是分阶段的，不同孩子的发展又不是完全同步的，因此父母要尊重规律，抛弃不切实际的计划和目标——例如要求 2 岁的孩子能安静坐着看电影。 作者认为新生儿阶段，应该给与足够的照料，这也是跟李玫瑾的观点类似。 2 岁以前，转移注意力的做法是可取的。 夸赞的方式：询问孩子自身的感受（你觉得怎么样？），站在主观的角度来观察（我喜欢你穿的衣服），而不是下一个看似客观的定义（你真会穿衣服）。 这本书实用性比较强，用了大量的案例来支撑观点。3-4-5 章更是针对各类儿童的问题，都给出了分析和对策。 教会孩子与大人进行协作。","categories":[{"name":"reading","slug":"reading","permalink":"https://kvh.io/categories/reading/"}],"tags":[{"name":"education","slug":"education","permalink":"https://kvh.io/tags/education/"}]},{"title":"币安链（BC）与币安智能链（BSC）简介","slug":"blockchain-bsc-intro","date":"2020-09-19T03:46:03.000Z","updated":"2021-01-13T01:42:18.820Z","comments":true,"path":"blockchain-bsc-intro.html","link":"","permalink":"https://kvh.io/blockchain-bsc-intro.html","excerpt":"","text":"本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。 出发点 总所周知，币安基于Cosmos-SDk 搭建了币安链（Binance Chain，下称 BC），并于 2019 年上线了主网。那为什么还要有另外一个智能链（Binance Smart Chain，下称 BSC）呢。白皮书解释和言外之意都描述下： 1231）实际应用要求有更强的可编程性（要有智能合约）2）保证现有的 dex 的高性能（基于 cosmos-sdk的链交易并发是有瓶颈的）3）开发者的学习曲线（以太坊的 DApp 生态最完善） 有了以上的需求，采用下面的技术路线和架构几乎是水到渠成。 设计目标 设计目标 121）BC 为主链，新链是一个独立区块链，对BC的依赖少2）兼容以太坊生态，保留跟随以太坊升级的可能性（改动越少，越好升级） 分工和职责 为了旧链和新链的合理性，设计了下面的职责和结构。 BC核心职责： 121）原有的 dex 功能2）平行链信息， staking 与治理 平行staking 放在 BC 上，也可能是考虑以后还会有别的新链出现~ BSC 核心职责： 121）运行区块链，输出 staking 和治理依据2）运行复杂的 DApp 由于两个链是相对独立的，所以称为是平行链。 BSC 共识协议 BSC 采用了 所谓的 PoSA（Proof of Staked Authority），你可以认为是以太坊代码中的 Clique 的一个小改动，综合了 PoA 和 DPoS 的思路。大致流程是： 1231）验证者或者代理人在 BC 上抵押2）BC 每24 小时重选合法验证者列表（21 个），通过跨链消息传递给 BSC3）BSC 根据验证者列表，选择节点轮流产块 PoA这个协议只能实现秒级的产块，但是无法实现秒级的确认（finality）。不确定做这个选择是为什么？可能是为了简单？个人认为有点偷懒了，采用基于 BFT 的快速确认的共识协议可能会更好。 简单而言，实现了基于 PoS 治理，PoA 产块。 从区块浏览器观察来看，BC 的区块周期大约1秒 2 个区块（ sub-second），BSC 的区块周期是大约 3 秒。 因为 BC 使用的 tendermint 共识，所以交易确认时间也就是区块周期，BSC 使用了是 PoA 共识，如果等待 21 个节点中的 +1/2确认，需要大约 30s-1m。 Token 设计了在 BC 和 BSC 双向映射和转账的机制。 Token 定义 1234BC：BEP2BNB... 123BSC：BEP2EBNB BNB 是两个平行链的 native token，交易手续费、抵押、奖励等都使用 BNB。 BEP2 是 BC 上类似于 ERC20 的 Token。 BEP2E 是 BSC 上类似于 ERC20 的 Token，多了几个方法： 123symbol()decimals()onwer() //比较重要，声明拥有者地址，后面只有这个地址可以发起绑定操作 那核心问题就是Token映射和转账，即： 1BEP2 of BC &lt;--?--&gt;BEP2E of BSC Token 绑定 12345678910111）确定 BC 上的BEP2和 BSC 上的 BEP2E 存在2）确定和锁定发行量 假如总发行量 S， BC 初始流通 K BSC 初始流通 S-K token 发行者应该在对应的链上把未流通的量 lock 到系统合约或者账户，使得两个链上的发行总量是 S。3）BEP2 token 的发行者在 BC 上发起绑定交易完成检查之后，绑定请求发送到 relayers4）BSC relayer 将跨链绑定信息转发给 TokenHub 合约5）BEP2E 的 owner 调用 TokenHub 合约的方法，后者确认 1.未被绑定 2.symbol 发行量和最小数量位 3。锁定正常6）BC 通过 Oracle 收到返回信息，将 contract address 和 decimal 信息写入 BC 注意，以上流程，需要 BC 上的系统托管账户，和 BSC 上的系统合约作为基础设施。 链互操作 平行链结构 官方这张图很不错。 注意 BSC Relayer 和 Oracle Relayer，分别负责把信息转发到 BSC 和 BC。 下面先介绍这两个角色，再介绍具体的跨链操作方式。 值得一提的是，币安在设计这两个角色的时候，已经考虑到了去中心化环境可能带来的问题和采取了一定的对策。 但是，这两个角色本身的合法性和提供的信息的验证问题，是不够清晰的。 BSC replayer BSC relayer 负责将信息从 BC传递到BSC。 需要存入一定量的 BNB 到BSC链上进行「注册」，BSC 只会接受注册的 relayers。 激励机制 1）用户操作，由用户买单 2）系统同步，由 BSC 系统买单 为了避免 relayers 垄断的情况 1）奖励是批量分配 2）在批量中，奖励不是线性分配 Oracle Relayers 负责将信息从 BSC 传递到BC，消息本身需要经过BC 验证者的共识。 在提交之前，Oracle 需要等待足够的 BSC 区块确认（PoA 确认需要 1 分钟）。 跨链奖励会成为区块奖励的一部分，分配给验证者。 将来也会引入对 Oracle 的 slashing BC-&gt;BSC 依赖BSC Replayers，消息将会进入到预编译的系统智能合约。 消息类型： 12345Token绑定转账错误处理验证者信息更新... BSC -&gt;BC 如果是通过交易产生的跨链事件，其流程是这样的： 1tx -&gt; EVM -&gt; event -&gt; oracle 每个BC 链验证者需要运行 oracle 进程作为 oracle relayer。 跨链消息包，也会被 BC 中的 validator 进行投票，签名超过2/3即为合法。 超时和错误处理 这个在跨链协议中很重要，涉及到回滚等。 当某个 sequence 的 tx 卡主，超时之后，将会有一个 skipsequence 交易出现，对卡主的 sequence 做出不可执行的标记。 社区决定如何处理。 链上无法解决的问题，最终还是推到社区||-_- Staking 和治理 BC 和 BSC 的Staking 的基本概念与其他基于 POS的链没有大不一样，要点如下： 1234567891）抵押，代理2）按照 token 排名，top n 作为验证者3）validator 分享收益给 delegator4）validator 会有被 slashing 的危险，delegator 需要分担5）token 有赎回期 具体到 BC 和 BSC 的配合： 12345671）BC 上抵押和代理 BNB2）BSC 的 validator 由 BC 上的 staking 模块决定，UTC 00:00:00 发出跨链通讯3）BSC 将验证者工作的信息，通过跨链通讯回传到 BC4）在 BC 上进行 reward 分配 罚没 基于 PoS 的公链，其活性需要全体 validator 的诚实、如实工作保证的。 为了从经济学上推动这类行为，引入了罚没机制。 双签 所谓的双签，是对于同一高度+同一个parent 的区块进行多与一次的签名。任何第三方都可以，以 slash request 的方式发到 BC 上。 1）从 validator 中移除——发出 update 事件 2）罚没一定量 3）一部分给提交者 4）另外的给验证者监管账户 不稳定 一个内部合约，统计工作情况。 1）如果超过不工作阈值，其已得收益，将不会发给 BC，而是分2给其他的 validators。 驱使运营不好的节点，delegator 将会离开 2）如果工作情况低于另外一个阈值，将会通知 BC，发生另外一个 slashing 总结 总的来讲，其技术结构和治理方式参考了一众跨链项目 （例如 cosmos 和 polkadot），也参考了 DPoS 的一众项目（例如 EOS 和 TRON）。机制设计上也留出了后续扩展的空间。在本文写作之时（2020-09），BSC 上已运行了若干 DeFi 应用，这也是 BSC 的实现最初目标（承接 DApp）的佐证。 在文章中，笔者也提出了一些疑问，例如 PoA 的区块确认时间过长，Relayer 和 Oracle 本身的信息正确性问题等。 在单链技术还没有实质性突破的情况下（以太坊 2.0 可能还需要若干年才能成熟，或者不会成功），这类平行扩展的思路，也不失为快速开展业务尝试的一种实干派做法。 参考 BC 官网 BSC白皮书 BC 浏览器 BSC 浏览器","categories":[{"name":"blockchain","slug":"blockchain","permalink":"https://kvh.io/categories/blockchain/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://kvh.io/tags/blockchain/"},{"name":"DeFi","slug":"DeFi","permalink":"https://kvh.io/tags/DeFi/"}]},{"title":"《影响力》读书笔记","slug":"reading-influence","date":"2020-08-17T03:18:16.000Z","updated":"2021-01-13T01:42:18.826Z","comments":true,"path":"reading-influence.html","link":"","permalink":"https://kvh.io/reading-influence.html","excerpt":"","text":"前言 这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。 通过阅读这本书，可以为运营活动或者销售技巧寻找理论根据，做到知其所以然。 🏷信息卡片 123456789101112131415作者:[美] 罗伯特·西奥迪尼出版社:&nbsp;中国人民大学出版社出品方:&nbsp;湛庐文化原作名:&nbsp;Influence: The Psychology of Persuasion译者:&nbsp;陈叙出版年:&nbsp;2006-5页数:&nbsp;353定价:&nbsp;45.00元装帧:&nbsp;平装丛书:&nbsp;湛庐文化· 商业智慧ISBN:&nbsp;9787300072487起止时间：&nbsp; &nbsp; &nbsp;&nbsp; 2020.07.15--2020.08.15阅读次数：&nbsp; &nbsp; &nbsp;&nbsp; 2推荐指数：&nbsp; &nbsp; &nbsp; 🌟🌟🌟🌟获奖情况： 🌱写作背景 作者社会心理学家，致力于影响力的研究 作者使用了所谓的参与式观察（间谍）参与到一些商品或者服务的销售工作中，以获取技巧 📒原著呈现 mindmap 🖇书摘&amp;批注 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121p3-4：绿宝石价格提高了，反而销量好了；人在成长过程中，接受了观念，价格贵=东西好；调高了价格，触发了用户的顺从按钮；在这一点上，人类也是某种基于反应的动物——跟雌火鸡一样；p9：文明的进步，就是人们在不假思索中可以做的事情更多所谓的专家，也就是在不断的训练中，形成了对于工作的问题的肌肉记忆p15-16：对比原理先看霹雳娇娃，会影响给自己对象的打分；先兜售贵的商品、其次是便宜商品——可能会让总收益最大先给一个不好的方案、然后给一个正常的方案，可能会有助于方案的接受第二章：互惠——给予、索取、在索取p25：给对方寄贺卡，会受到很多回信在一个社交网络早期，主动加别人，会有一定的会加率p28：给对方带一瓶可乐，就可以获得更高的彩票销售不要忽视小恩小惠的作用；要习惯对别人施以援手——赠人玫瑰，手留余香p33：政府高层的相互投票和联合奥巴马和特朗普该多难啊！p35：安利臭虫所谓的试吃，也是这道理吧p38：人有送礼的义务、接受的义务、更有偿还的义务想起了老教父柯里昂p48：拒绝-后撤常见的销售技巧——漫天要价，坐地还钱第三章：承诺和一致性——脑子里的怪物p63：一开始就拒绝，比最后返回要容易——达芬奇至理名言，特别是对于推销cold callp67：所有人都一次次的骗自己，以便在做出选择之后，坚信自己做的没错you've got a dream, you've to protecet itp68：信仰、言行和行为前后一致不一致的人，会被看成脑筋混乱表里不一；言行高度一致多数跟个性坚强、智力出众；它是逻辑性、稳定性、诚实感的核心胡忠献的忠，岳飞的忠吴三桂所谓没有定力p70：关于冥思会和缴费超自然的方法，可能是唯一解药；p73：玩具销售商的策略为了保持淡季的销量p85：战俘营的做法以小积大p86：个人承诺防止撕毁合同自己说出的话，自己要遵守承诺p90：额外的努力，费尽努力得到的东西，人人往往格外珍视追姑娘丈母娘设置困难公司的严格面试，也是一种投名状其中的成员，会强烈的维护这种准入建立团队凝聚力和卓越感，入会活动要艰辛p100：内心的压力你得找一个有力的理由，让他大多数情况下都保持城市，可这个理由又不能强大到让孩子觉得，自己完全是为了它才诚实太强烈的惩罚，可能不会奏效要是说谎，我会失望的这个对于教育孩子很有意义，要让遵守规则成为孩子自身的习惯，而不是被强迫的第四章：社会认同——脑子里的怪物p120：依照别人意见行事盖得排行，大众点评街头围观，网红店雇人排队p138:寻求帮助找到特定的人寻求帮助旁p150:自杀新闻会导致更高的自杀率第五章：喜好——友好的盗贼p175:销售外表广告模特和销售人员都要漂亮p179:喜好广告的作用。第一次陌生，看了广告之后就觉得是名牌了p181:所谓的融合策略融合过程中导致的恶意，难道不是留下更大的影响么p184:拼图学习法竞争与合作p199:体育运动乒乓球、排球、奥运会等对国民认同的形成的作用第六章：权威——教化下的敬重p223:头衔都喜欢挂一堆头衔第七章：稀缺——数量少说了算p243:稀缺销售管用伎俩，create urgentp247:逆反心理有屏障，挑衅；测试界限；罗密欧朱丽叶，如果没有限制，可能不多久就分掉了p253:信息审查「禁书」，快要被删，这都有助于传播p260:参与竞争稀缺资源，有强大的刺激性所谓的竞雄？拍卖 🙋‍♀️总结感悟 顺从的力量，来自大量「正统」观念影响 从理论上了解影响力的来源：互惠、承诺和一致性、社会认同、喜好、权威、稀缺 验证和对照了一些日常的销售和运营策略 👯‍♀️他山之石 🎥多媒体资料","categories":[{"name":"reading","slug":"reading","permalink":"https://kvh.io/categories/reading/"}],"tags":[{"name":"社会心理学","slug":"社会心理学","permalink":"https://kvh.io/tags/社会心理学/"}]},{"title":"开源许可证介绍与项目实战","slug":"open-source-license","date":"2020-04-28T03:18:16.000Z","updated":"2021-01-13T01:42:18.825Z","comments":true,"path":"open-source-license.html","link":"","permalink":"https://kvh.io/open-source-license.html","excerpt":"","text":"介绍 在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到： 使用和修改的条件是什么？ 商用和分发的条件是什么？ 本项目开源后使用什么许可证？ 本文将简要介绍对许可证（license）的理解，着重介绍一个实战项目处理方式。 许可证介绍 许可证的内容，其实是博大精深。 首先许可证的种类特别的多，其次不同的许可的条款和细节也特别的多。 下面主要是介绍若干主流且具有代表性的许可证。 主要参考了开源许可证教程-阮一峰的网络日志 名词解释 分发 将版权作品从一个人转移到另外一个人；例如提供给别人；如果是本公司使用，不算分发。 传染 一个项目用到了某个许可证的代码，在某些条件下（例如分发），这个项目本身也需要使用这种许可证 许可证版本 同一个许可证，有版本号之间的区别，例如 GPL 有 v1/v2/v3。 宽松的许可证 包含 MIT/ISC/BSD/Apache等，基本上这类许可证，是可以放心使用。 123456789101112131415（1）BSD（二条款版）分发软件时，必须保留原始的许可证声明。（2） BSD（三条款版）分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。（3）MIT分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。（4）Apache 2分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。 Copyleft 许可证 代码可以随意复制，有如下前提： 123- 如果分发二进制格式，必须提供源码- 修改后的源码，必须与修改前保持许可证一致- 不得在原始许可证以外，附加其他限制 核心在于，修改后的代码，不得闭源。 AGPL 最严格的 GPL，除非获得商业授权，否则无论以何种方式修改或者使用代码，都需要开源。 云服务使用AGPL 的源码，不构成分发，也也需要开源 GPL 如果分发软件，则使用和修改都必须开源，整个项目都必须采用 GPL许可。 LGPL 分发时，如果是使用动态类库的方式引用，可以不开源 MPL 分发时，只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。 无论是商业应用，还是开源项目，在采用 AGPL/GPL/LGPL/MPL都要特别的小心。 许可证检测 介绍两个工具，分别检测代码文件和依赖的 license。 检测代码 1go get -u github.com/google/addlicense 可以递归检测当前目录下的所有代码文件，许可证声明的情况，例如： 1addlicense -check ./ |sort &gt; lc.txt 可以把未添加许可证的文件都输出到lc.txt 文件中，方便后续进行检查。 检测依赖库 1go get -u github.com/google/go-licenses 查看一个依赖库所使用的版权信息： 1go-licenses csv repo 可以通过一个这个脚本项目进行批量测试： 123456cat dep.txt |while read linedo echo \"start checking package $line\"go-licenses csv $lineecho \"\"done 许可证添加 笔者主要使用 idea 的 IDE 进行程序开发，它有管理版权信息的功能： 1Preference-&gt;editor-&gt;Copyright 可以添加不同的 Profiles，然后使用 IDE的功能进行自动添加和更新。 12345671）设置默认 copyrightpreference-&gt;editor-&gt;Copyright设置 default project copyright，选中一种配置，这个可能会根据不同的文件需要切换2）选中代码文件或者文件夹3）菜单栏-&gt;Code-&gt;Update Copyright 项目实战 下文介绍对于一个实际项目进行许可证声明。 项目背景 该项目主语言是 golang，采用了自某 LGPL 的项目的一部分类库作为基础代码。 版权主体 也就是版权声明的第一行的关键信息，例如： go-ethereum 1Copyright 2016 The go-ethereum Authors go-algorand 1Copyright (C) 2019-2020 Algorand, Inc. 可以选择是作者主体，或者公司主体。 项目 license 由于该项目的代码，部分使用了修改了 LGPL 项目代码作为基础工具。 根据 LGPL 的规定，本项目也需要使用 LGPL 作为 license。 版权声明 声明版权，一般两部分： 1）项目级别的 LICENSE 文件 由于大部分的许可证都是控制包级别的许可，所以这种方式也足够 2）代码级别的 copyright 文件头 每一个原创的文件都设置了版权信息 项目级别的 license 一般而言，是找到你的 license 的文本，将文件放置于项目根目录。 不同许可证可能有点不一样 一般而言，在 github 建立公开项目的时候，会提示选择一个 license。 如果初始化忘记了，也可以web 界面上，新建一个名字是LICENSE的文件，来显式触发选择 license。 代码级别的 copyright 文件头 使用第三方代码，主要分为，fork 引用 和 library 依赖。 fork 是指把代码直接放到了代码库中，修改或者不修改。 library 是库依赖，例如通过 go.mod 的方式进行依赖。 fork 引用 代码分类 12345678910111213141）项目原创文件2）项目修改第三方库的文件3）项目直接引用第三方库的文件4）fork 过来的开源库可能存在包内 license，单文件可能没有copyright5）忽略 license 文件的内容非 golang 文件gencode 生成的以 gen_开头的文件其他自动生成的文件 有了如上的分类，你就可以使用 IDE 创建多个不同的 Copyright Profiles 来处理不同的文件了。 结合 addlicense 工具，相信这部分工作将可以顺利完成。 library 依赖 使用上述的依赖检测工具，查看是否有不合适的许可证。 如果一个依赖库，license 不是MIT/ISC/BSD/Apache 其中的一种，那就要小心了！ TBD-Topics 有一些话题需要进一步讨论： 11）如果项目源码计划商用，如何处理？ 总结 本文简要介绍了license 的原理，着重介绍了项目实战，希望对读者有启发，欢迎讨论！ 参考 https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html https://www.gnu.org/licenses/gpl-faq.html https://choosealicense.com/","categories":[],"tags":[]},{"title":"macOS 作为服务器","slug":"osx-as-server","date":"2017-12-04T03:21:55.000Z","updated":"2021-01-13T01:42:18.825Z","comments":true,"path":"osx-as-server.html","link":"","permalink":"https://kvh.io/osx-as-server.html","excerpt":"","text":"因为业务需要，我司有若干台服务器 Mac 作为服务器。下面总结一下注意事项，作为记录。 取消系统休眠 曾经在这个问题上困扰很长时间。在升级了 macOS High Sierra 之后，发现之前能够正常运行的程序出现问题。 具体表现是： ssh 登出之后不久，线上就开始报警 登陆进去查看 log，发现程序又是正常的 socket 连接提示传输错误 程序并没有 exit 一开始怀疑是后台程序的权限问题，于是更新了后台程序的 launchd 配置，确保了使用 root 用户运行，没有效果。 后来灵机一动，去具体分析程序的 log，发现只要用户登出，输出就会停止，看起来是程序被挂起了。 分析可能被挂起的原因，只可能是系统休眠了。 直接登陆 GUI 系统，在系统设置中将节能设置改成： \b节能设置 生效了！ \b守护进程 作为服务器，大多是需要运行守护进程。这就需要用到 launchd，它能确保这是确保设备重启之后，守护能够自动运行。 launchd 是一个开源框架，用于控制守护进程、程序、或者脚本，在 Mac OS X Tiger 中引入。 使用 launchd，主要需要注意下面几点： 正确区分系统全局的守护和用户相关的守护进程 类型 \b路径 运行用户 全局的守护进程 /Library/LaunchDaemons root 用户或者使用 UserName key 对应的用户 系统的守护进程 /System/Library/LaunchDaemons root 用户或者使用 一般而言，把 plist 文件放到 /Library/LaunchDaemons 即可。 正确设置 plist 文件的权限 1-rw-r--r-- 1 wheel 947 12 1 14:51 name_of_the_config.plist 也即是： 123用户：root组：wheel权限： 0644 被运行的程序，\b需要是处于前台运行，否则 launchd 会认为程序已经退出 如果需要全局性的\b守护进程，需要使用 sudo 运行 参考文档 http://www.launchd.info/ launchd.plist launchctl 内网穿透 很多时候，macOS 服务器并不是托管在机房，而是在某个比较方便管理的地方——例如办公室。 办公室的网络环境又千奇百怪，往往没有固定的外网 ip，往往是处于 NAT 的网络环境或者是\b防火墙内，如果服务出现了问题，总不能直接\b\b\b跑去办公室吧。 尝试过各种 VPN 方案，动静太大，不稳定，放弃。下面介绍一下 Ngrok。 官网简介： Secure tunnels to localhost ”I want to expose a local server behind a NAT or firewall to the internet.” 基本的构架图如下： Ngrok 这款软件是 C/S 结构，使用服务器作为中转，只需要设置好服务器和客户端，不需要在路由器做任何处理。软件的2.x 不开源，\bgithub 上只有 1.x 版本，已经足够。 使用方式，参考imququ 的博客。 基本流程是： 1. clone 源码 2. 生成\b证书，拷贝 base.pem 到 assets/client/tls/ngrokroot.crt 下 3. 运行 make release-server release-client 4. bin 的 ngrokd 和 ngrok 分别是服务器端和客户端 \b总结 以上是\b对于 \bmacOS 作为服务器的一些注意事项。","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://kvh.io/tags/macOS/"}]},{"title":"Spring Cloud 配置中心","slug":"spring-cloud-config","date":"2017-10-13T15:18:16.000Z","updated":"2021-01-13T01:42:18.830Z","comments":true,"path":"spring-cloud-config.html","link":"","permalink":"https://kvh.io/spring-cloud-config.html","excerpt":"","text":"闲话配置 老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就满足了需求。 配置（Configuration）是不修改代码的情况下，对程序的运行调整的能力。 简单来讲，配置可以分成两类： 系统配置：包括线程池大小、数据库连接等，变化频率较低 业务配置：功能开关，功能参数等，变化较为频繁 程序的配置一般而言，分为几个环境： 开发环境 测试环境 生产环境 这几个环境的配置是有差异的，所以配置管理功能应当能够根据当前环境读取对应的配置。 前面提到的不修改代码，只是最低要求，相当多的情况下，程序是不能停机的，这就提出了热更新的需求。 另外，配置的修改应该是有记录可追溯的。 Spring Boot 的配置管理 Spring 实现了非常友好的配置读取方式， Spring Boot 程序默认使用 application.properties 进行配置。 例如一个参数： 1flag=0 在程序中可以通过： 12@Value(\"${flag})int flag; 来读取。 也可以通过设置多个配置文件： 1234application.propertiesapplication-dev.propertiesapplication-test.propertiesapplication-prod.properties application-dev.properties 1flag=1 application-test.properties 1flag=2 application-prod.properties 1flag=3 和在 \bapplication.properties 中声明当前的活跃的 profile： 1spring.profiles.active=dev 来实现根据运行环境切换配置信息。 \b以上只是 Spring 强大的配置能力的冰山一角，有兴趣可以参考外部配置文档。 这还不够 其实以上描述的 Spring Boot 的配置能力已经很强了，但是有个很致命的问题——无法热更新。 如果非得实现热更新，那可以把配置做成 JSON 文件，再实现一个 \bendpoint，重新读取一次配置。 假设有一千个实例呢？ Spring Cloud \bConfig 项目 github\b：https://github.com/spring-cloud/spring-cloud-config 简介：External configuration (server and client) for Spring Cloud 这个项目包含两部分： Server 负责从 git/svn 等版本管理系统中读取配置，\b并以 http 的方式提供服务。 Client 根据客户端配置，从指定的 Server 中读取对应配置，并且与 Spring 本身的 PropertyResource 和 Environment 无缝结合。同时，提供了统一的方式进行配置热更新。 对于这个系统的基础配置和运行，可以参阅下面两个 url： https://spring.io/guides/gs/centralized-configuration/ http://blog.didispace.com/spring-cloud-starter-dalston-3/ 实操进阶 热更新 Spring Cloud Config 实现了非常优雅的热更新。 客户端的配置 Bean 添加 @RefreshScope 12345678910@Configuration@RefreshScopepublic class ConsumeConfig { @Value(\"${consume.desc}\") private String consumeDesc; @Value(\"#{'${api.server.round.card}'.split(',')}\") private List&lt;String&gt; cardList;} 在配置这个注解之后，调用客户端的 /refresh endpoint，这个 Bean 就会刷新，同时个 Bean 的依赖方下次方法调用时也会更新 Bean 引用。 有些时候，你需要监听这个更新事件，把拿到的最新配置，重新初始化一些部件。那你可以添加： @EventListener(EnvironmentChangeEvent.class) 这个 annotation。 1234567891011@Componentpublic class ConsumeService { @Autowired ConsumeConfig consumeConfig; @EventListener(EnvironmentChangeEvent.class) void onEnvChange() { //do re-init stuff }} 添加权限 Config Server 任何人都可以通过 http 访问配置，这个不大好，建议加上认证，最简单是使用 Spring-Security 添加一个 basic authentication。 服务器端配置 build.gradle 添加依赖： 123dependencies { compile('org.springframework.boot:spring-boot-starter-security')} application.properties 添加密码（用户名默认是 user）： 1security.user.password=xxx 重启服务器，再次通过 http 访问配置的时候需要验证。 客户端配置 服务器端做了验证，那客户端也需要添加相应的配置： bootstrap.yml 123456789spring: application: name: application cloud: config: uri: http://yourhost.com profile: dev username: user password: xxx 加载多组配置文件 很多时候，为了避免 application.properties 过于臃肿，你可能需要把一些配置文件拆出来，例如专门负责邀请奖励的配置： 1234invite.propertiesinvite-dev.propertiesinvite-test.propertiesinvite-prod.properties 同样，也区分了多个环境。 那在使用 Spring Cloud 的时候如何读取这个文件呢？ 123spring: application: name: application,invite 注意上面的 application.name 是以逗号分隔的两组配置名称。 一些问题 @EventListener 与 SpEL 我在实际使用中发现，在事件监听函数中，使用更新后的配置的时候： 12345@Value(\"${consume.desc}\")private String consumeDesc;@Value(\"#{'${api.server.round.card}'.split(',')}\")private List&lt;String&gt; cardList; 第一个配置是使用 @Value 绑定一个字符串类型，第二个配置是使用 @Value 中的 SpEL 去将配置中的字符串，切割成 List。 我发现第二个，无法切割成功。试验了多次，还没有找到答案。我已经在 Spring Cloud Config 的 github 上提交了 issue。 如果有了解这个的，请不吝赐教。 update 2017-10-26 * 我在 github 上提交了 issue： https://github.com/spring-cloud/spring-cloud-config/issues/821 得到回复：We have only ever documented that placeholders ${} work, not SpEL. 权限管理 在不做二次开发的情况下，这个配置中心的数据是对所有的 client 开放的。某些情况下，这种设定并不合适。 JSON 文件的读取和解析 Spring Cloud Config 本身是可以通过 http 来提供 JSON 文件的访问的，但是Spring Boot 原生并不支持 JSON 配置的读取和解析。 相关选择 其实配置管理工具，选择还是不少的，下面列举一下。 owner http://owner.aeonbits.org/ 配置文件管理，可以热更新，跟 Spring 没有绑定。 cfg4j http://www.cfg4j.org/ 专注管理配置文件，也可以实现热更，跟 Spring 没有绑定。 applolo https://github.com/ctripcorp/apollo 携程开源的，功能很全 disconf https://github.com/knightliao/disconf 百度的一位工程师的开源项目，功能也很全 diamond https://github.com/takeseem/diamond 来自阿里的开源，有些日子了 参考文献 http://blog.didispace.com/spring-cloud-starter-dalston-3/ http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html http://jm.taobao.org/2016/09/28/an-article-about-config-center/ https://blog.coding.net/blog/spring-cloud-config","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://kvh.io/tags/Spring/"}]},{"title":"小工具-sips-图片批量转大小","slug":"utility-sips","date":"2017-05-16T03:18:16.000Z","updated":"2021-01-13T01:42:18.830Z","comments":true,"path":"utility-sips.html","link":"","permalink":"https://kvh.io/utility-sips.html","excerpt":"","text":"家有设计师 我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。 看了她导了好几次，实在不能忍。得发挥程序员的能动性，做个小工具。 调研 imagemagick 是一个很好的工具，支持多个平台，功能丰富强大。考虑了一下，如果这个小工具还需要用户安装依赖的话，显然提高了使用门槛。 设计师们大多在 MacOS 下工作，最好是运用这个平台下现成的工具包。搜索了一下，发现今天的主角：sips。 sips 具有很友好的使用接口，可以实现大小转换、旋转、翻转等。这里我只需要大小转换功能，主要是如下命令： 1sips -Z 100 input.png --out output.png 上面的例子可以将 input.png 图片最大边调整成100像素，等比缩放。 实践 整个工具包含如下几个文件： 1234.├── convert.sh//转换程序├── icon.png//输入文件└── sizes.txt//目标尺寸 使用步骤如下： 替换 icon.png 文件为需要转换的文件 修改 sizes.txt 文件，编辑目标尺寸，每一行为一个尺寸 控制台运行 ./convert.sh 即可 为了很方便的让设计师同学使用这个工具，我在她的电脑上安装了一个 cdto 工具，可以在当前 finder 目录下打开 控制台。还把这个工具拖到了 finder 的左侧快捷方式。PS: 用户接口要友好。。。 源码 源码和配置文件都放在 github 上。 TODO 目前只支持 png","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://kvh.io/tags/产品/"},{"name":"用户体验","slug":"用户体验","permalink":"https://kvh.io/tags/用户体验/"}]},{"title":"亚马逊 Alexa Echo Dot——入门","slug":"play-alexa-1","date":"2017-03-21T03:18:16.000Z","updated":"2021-01-13T01:42:18.826Z","comments":true,"path":"play-alexa-1.html","link":"","permalink":"https://kvh.io/play-alexa-1.html","excerpt":"","text":"智能家居 大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。 亚马逊的 Alexa Echo 无疑是这个浪潮中的当红明星。 它是一个蓝牙音箱，是一个智能语音助手，是一个智能家居管理中心，它还提供了开放平台，允许第三方添加 Skills 来扩充功能。 本篇介绍一些购买和基本使用经验。 购买 在经过几代的发展之后，目前这个产品主要包含 Echo 和 Echo Dot。主要的区别是扬声器的规格。 如下图： Amazon-Echo-Dot Echo Dot 价格要亲民一些，500人民币左右，某宝可购买。 下单后很快到货，就是这么一个小盒子： Echo-Dot-实物 基础介绍 顶部有四个按钮，功能分别是，分别是：静音、操控、音量加减。 背面有两个插槽，分别是 3.5 mm 声频输出口、Micro-USB 电源插口。 Echo Dot 需要一个叫做 Alexa App的手机软件作为控制端，下面提供 Android 和 iOS 平台的下载地址。 Android-App iOS-App 注意在 iOS 平台上，这个 App 只允许美国区的账户进行下载。你可以折腾一下，注册一个美国区的 Apple ID，可能需要绑定信用卡。你也可以花钱买时间，在万能的某宝上买一个美国区账号。我选择了后者。 基础设置 Echo Dot 是需要连接到 WiFi 进行工作的，这就需要用 Alexa App 进行绑定和设置。 如果你曾经用过小米的空气净化器，你会发现设置的模式类似。 主要步骤为：EchoDot 进入设定模式、手机连上 Echo Dot 共享的 WiFi、操作 Echo Dot 连接家里的 WiFi。 1.长按 Echo Dot 顶部的操控键，会有提示进入设定模式(enter setup mode)； 2.在手机的 WiFi 设置页面，可以看到名字为 Amazon-XXX 的 WiFi，连接上去，会有提示：(connected)； 3.进入 Alexa App，在里面选择家里的 WiFi，输入密码，确定之后，Echo Dot 会尝试进行连接。 连接中，主要发现两个问题，一是卡，二是根本连不上。因为 Alexa 的服务器在国外，速度受一定的影响，卡是正常的。然而国内的网络环境比较复杂，例如我就遇到过家里的方正宽带下的 WiFi，根本连不上的情况。后来我只能使用手机的联通4G 开热点才能勉强使用。公司的电信宽带也没有问题。后面网络续费的时候，看来要换成电信或者联通了。 基础使用 Echo Dot 连接上网络之后，你就可以跟它对话了。默认唤醒口令是 Alexa。唤醒之后灯会亮。 例如就可以试一下，Alexa, what's the weather。它可能会告诉你美国西雅图现在的天气，地址可以在 Alexa App 中设置。（ps：我还没有找到设置成北京的方式） 一些后续 Alexa Echo 提供了开放平台，开发者可以将服务打包成 Skills 对系统进行扩展，这个就有点像苹果的 iOS 生态了。厂商只提供基础的服务和功能，开发者百花齐放。用户可以在 Alexa App 中添加 Skills，例如你可以添加一个读 CNN 新闻的功能。这一块还有待探索。 网络问题很严重，反应速度比较慢。后面如果想要愉快玩耍，还是得找一个比较好的联网方案。某一天亚马逊可以把服务器放一些到国内，就更好了。 总结 Alexa Echo Dot 入门初步介绍了购买、设置、使用。下面继续探索。","categories":[{"name":"product","slug":"product","permalink":"https://kvh.io/categories/product/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://kvh.io/tags/产品/"},{"name":"用户体验","slug":"用户体验","permalink":"https://kvh.io/tags/用户体验/"}]},{"title":"读一首诗——纪伯伦《孩子》","slug":"on-children","date":"2016-10-07T03:18:16.000Z","updated":"2021-01-13T01:42:18.825Z","comments":true,"path":"on-children.html","link":"","permalink":"https://kvh.io/on-children.html","excerpt":"","text":"今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（Kahlil Gibran）的《孩子》，很有感触。将冰心的译文和原文奉上。 1234567891011121314151617孩 子 你们的孩子，都不是你们的孩子。乃是生命为自己所渴望的儿女。他们是凭借你们而来，却不是从你们而来，他们虽和你们同在，却不属于你们。你们可以给他们以爱，却不可给他们以思想。因为他们有自己的思想。你们可以荫庇他们的身体，却不能荫庇他们的灵魂。因为他们的灵魂，是住在明日的宅中，那是你们在梦中也不能想见的。你们可以努力去模仿他们，却不能使他们来象你们。因为生命是不倒行的，也不与昨日一同停留。你们是弓，你们的孩子是从弦上发出的生命的箭矢。那射者在无穷之中看定了目标，也用神力将你们引满，使他的箭矢迅速而遥远地射了出去。让你们在射者手中的弯曲成为喜乐罢；因为他爱那飞出的箭，也爱了那静止的弓。 123456789101112131415161718192021222324On ChildrenYour children are not your children.They are the sons and daughters of Life's longing for itself.They come through you but not from you,And though they are with you yet they belong not to you.You may give them your love but not your thoughts, For they have their own thoughts.You may house their bodies but not their souls,For their souls dwell in the house of tomorrow, which you cannot visit, not even in your dreams.You may strive to be like them, but seek not to make them like you.For life goes not backward nor tarries with yesterday.You are the bows from which your childrenas living arrows are sent forth.The archer sees the mark upon the path of the infinite, and He bends you with His might that His arrows may go swift and far.Let your bending in the archer's hand be for gladness;For even as He loves the arrow that flies, so He loves also the bow that is stable. 这首诗，来自纪伯伦的名作《先知》。 相信每一个人，在不同的阶段，读到这首诗的感受，是不一样的。 年少的时候，觉得父母老师管束自己，想要自由，可能会以此诗句来抗争——看，纪伯伦说了……。 长大了，离开父母上学，父母还是希望给更多的意见，你却总觉得父母的意见不合时宜。 工作了，经济自由了，在享受自由的那一瞬间，却开始想父母了。你慢慢的发现，自己身上的思想与习惯，很多都是源自来自父母。 若干年后，父母在你该找谁结婚这事儿上，干预未果，你想，抗争终于成功了。 不久，你也终于为人父母，才感叹，当父母真不容易。既当弓，又为箭。 再过若干年，自己的孩子也到了叛逆期，你还是希望像当年自己的父母一样，把自己曾经犯过的错，提前告诉孩子。 你却发现，每个人该犯的错误，该趟的坑，一个都少不了。你，却只能在旁边看着，就像当年你的父母一样。 孩子终于活出了自己的世界，你发现，原来每一个人都有自己的命运，只要努力，还是有机会。 每个人的每个阶段，都有自己的局限和使命。努力，活在当下就好。","categories":[],"tags":[]},{"title":"SDK 开发最佳实践之一：为你的 SDK 增加 No-Op 版本","slug":"sdk-noop","date":"2016-09-29T03:20:30.000Z","updated":"2021-01-13T01:42:18.829Z","comments":true,"path":"sdk-noop.html","link":"","permalink":"https://kvh.io/sdk-noop.html","excerpt":"","text":"笔者在开发和维护 Bugtags SDK 的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK 开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags 这样快速成长的 SDK。 SDK 的使用场景 站在用户的角度来看，引入一个 SDK 可能会带来几方面的问题： - 包增大 - 可能不稳定 - 安全性问题 对于一些 SDK，产品形态是允许在测试阶段开启，上线移除的，例如性能调试工具，测试工具等。 区分版本方案 最简单的，就是手动注释代码，应用中如果只使用了这个 SDK 的一个 API，那还好，如果用到了多个，分布在不同的文件中， 这事儿就麻烦了。很不优雅。 最优雅的方案 思考一下这个需求 应用分为 debug/release 版本 无痛切换，最好能够实现自动化 大部分的编译系统，例如 Gradle/Maven 都可以区分版本，引入不同的包。利用这个特性，我们可以实现一个 No-Op SDK。 这个 SDK 具有如下特点： 具有正式 SDK 的所有可以被外部引用的类 具有正式 SDK 的所有对外 API 足够的精简 提示正在使用 No-Op SDK 最后的结果 以 bugtags 为例： 12debugCompile 'com.bugtags.library:bugtags-lib:2.0.0'releaseCompile 'com.bugtags.library:bugtags-noop:2.0.0' 以 leakcanary 为例： 12debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5'releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5' 扩展 如果你是一个 SDK 的使用者，即便官方没有提供 No-Op 版本，你完全可以自己写一个。","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"SDK","slug":"SDK","permalink":"https://kvh.io/tags/SDK/"}]},{"title":"Android Gradle 构建系统·初探","slug":"gradle-build-system-overview","date":"2016-08-13T03:18:16.000Z","updated":"2021-01-13T01:42:18.824Z","comments":true,"path":"gradle-build-system-overview.html","link":"","permalink":"https://kvh.io/gradle-build-system-overview.html","excerpt":"","text":"8月7号，应北京 GDG 邀请，我做了一个题为《Android Gradle 构建系统·初探》的分享。 主要内容是构建系统背景知识，源码库，代码亮点，写插件。 很明显这是一个很大的话题，有超过 2.5GB 的核心代码和超过50个子项目。 第一步，我进行了宏观的介绍。下一步，我会继续深入子项目，尝试发现更多有意思的点。 对这个话题感兴趣的，请加入技术交流 qq 群：583688711。 Slides 在下面，分别是 PDF 版本和图片版本。 PDF here. 图片： 有问题？在文章下留言或者加 qq 群：583688711，希望能帮到你。","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://kvh.io/tags/Gradle/"}]},{"title":"Android Gradle 技巧之二： 最爱命令行","slug":"gradle-indepth-cmd","date":"2016-06-04T03:18:16.000Z","updated":"2021-01-13T01:42:18.825Z","comments":true,"path":"gradle-indepth-cmd.html","link":"","permalink":"https://kvh.io/gradle-indepth-cmd.html","excerpt":"","text":"如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。 命令行 很多做 Android 开发不久的同学，习惯于使用图形界面，对命令行操作很陌生甚至恐惧。遇到 AS 运行错误，束手无策。 AS 为了确保易用性，也在 UI 界面上屏蔽了很多命令行运行的细节，导致很多人觉得 AS 难用。 这种情况，我在解决用户集成使用 Bugtags SDK 的问题的时候，经常能遇到。其实 GUI 界面的操作，绝大部分情况下，也是基于命令工具的。如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。 # 典型错误 AS 刚推出的时候，stackoverflow 上询问最多的问题，便是进入项目的时候，一直处于： 1Gradle: resolve dependancies '_debugCompile' 状态，一直无法前进，到底 IDE 在做什么呢？看不出来。 一句命令行 当用户遇到问题时，我最常提醒用户使用的是在项目根目录下，运行如下命令行： 12345mac:./gradlew clean build --info &gt; bugtags.logwindows:gradlew.bat clean build --info &gt; bugtags.log 这个命令行的意思，是运行 clean 和 build 两个 gradle task，并且打开 info 参数使得输出更多的信息，最终把所有输出的信息，输出到项目根目录下的 bugtags.log 文件。用户把这个文件发给我，我根据这个输出文件，通常就能分析出问题所在。 假设命令行去除重定向输指令： 1./gradlew clean build --info 信息将会输出在控制台，刚才提到的那个典型错误，可能是这样的： cmd-output 其实是在下载一个比较大的文件，不用惊慌，你要做的就是 just wait! 至于是在下载什么。我想在下一篇详细描述。 如果你对基本的命令行知识有所了解，前面就已经足够了，如果你想了解更多，请继续。 扩展 在哪运行 当我给出这个命令的时候，最常见的问题，就是在哪运行。答案是控制台（Terminal）。 控制台 在 mac 下，有 terminal（bash/zsh 等），在 windows 下，则是 powershell 或者 cmd。 关键一点： 12├── gradlew├── gradlew.bat AS 在使用 Gradle 的时候，为了灵活，或者为了应对 Gradle 系统的快速迭代，推荐使用在项目根目录中放置 Gradle 的 wrapper：gradlew 来实现对不同版本的使用。 因此，在控制台运行命令，主要是跟 gradlew 打交道。这个 wrapper，在 mac 下是一个具有执行权限的文件：gradlew，在 windows 下，是一个批处理文件：gradlew.bat。 通常，mac 下在当前目录下运行可执行文件是这样： 1./gradlew xxx windows 下在当前目录下运行批处理文件是这样： 1gradlew.bat xxx Terminal 插件 AS（Intellij IDEA）已经做了一个很实用的插件： as-terminal 点击 Terminal，AS 会帮你完成下面的操作： 模拟打开 terminal cd 到当前项目根目录下 快速定位文件夹 IDE 还支持将项目中的某个文件夹拖放到 Terminal 窗口中实现快速定位到这个文件夹： terminal-drag-location 使用 help 要知道都有哪些 gradle 命令运行的参数，可以使用： 1234$ ./gradlew --helpUSAGE: gradlew [option...] [task...]... 来获取。下面列举几个重要的参数。 build 某个指定 module AS 推荐的结构是 multiple project 结构，即一个 project 下，管理多个 module，如果每次都要 build 全部的 project 的话，有点浪费时间，则可以使用 -p module 参数，其中 module 是你要 build 的 module： 1$ ./gradlew -p app clean build 明确指定不执行某个 task Gradle 的命令存在依赖，例如 build task，是依赖于一系列的其他的 task，如果想要指定不执行某个 task，则可以使用 -x task 参数，其中 task 是要忽略的那个，这个参数可以传递多次。 1$ ./gradlew build -x test -x lint 总结 Gradle 的命令行还有很多其他技巧，上面只是列举到了本人日常用到最多的几个。有兴趣可以留言深入讨论。 参考资料 mac-terminal windows-terminal 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"Gradle 技巧","slug":"Gradle-技巧","permalink":"https://kvh.io/tags/Gradle-技巧/"}]},{"title":"Android Gradle 技巧之一： Build Variant 相关","slug":"gradle-indepth-build-variant","date":"2016-06-03T03:18:16.000Z","updated":"2021-01-13T01:42:18.824Z","comments":true,"path":"gradle-indepth-build-variant.html","link":"","permalink":"https://kvh.io/gradle-indepth-build-variant.html","excerpt":"","text":"Build Variant android gradle 插件，允许对最终的包以多个维度进行组合。 1BuildVariant = ProductFlavor x BuildType 两个维度 最常见的就是这样： 1234567891011121314151617productFlavors { pro { } fre { }}lintOptions { abortOnError false}buildTypes { debug { } release { }} 其中，buildTypes 一般都会有 debug 或者release，标示编译的类型，通常在混淆代码、可调式、资源压缩上做一些区分。 productFlavor 则为了满足“同一个project，根据一个很小的区分，来打不同的包”这个需求。 这两个维度的组合，会产生如下包： proDebug proRelease freDebug proRelease 更多的维度 1234567891011121314151617181920212223242526flavorDimensions 'abi', 'version'productFlavors { pro { dimension 'version' } fre { dimension 'version' } arm { dimension 'abi' } mips { dimension 'abi' }}buildTypes { debug { } release { }} productFlavor 本身定义了2个维度，记上 buildType，则有三个维度，会产生如下的包： armProDebug armProRelease armFreDebug armFreRelease mipsProDebug mipsProRelease mipsFreDebug mipsFreRelease 其中每个维度组合，都可以设置本身的 dependency、test source。下面做一个举例。 Flavor 与 Dependency 需求 module 中有若干个 flavors，例如：fre 和 pro，分别依赖不同的库，这些库有的是本地 jar 库，有的是远程库。 方案 flavor-dependency 遍历 Build Variant 需求 Bugtags 的 android sdk，有一个自动上传符号表功能， 在最初，是这样配置的： 123456apply plugin: 'com.bugtags.library.plugin'bugtags { appKey \"APP_KEY\" appSecret \"APP_SECRET\" mappingUploadEnabled false} 后来，我们增加了一个 beta-live 的机制，用来区分测试和上线的 APP，这样，同一个 APP，就有两套 APP_KEY 和 APP_SECRET 了，很明显上方的配置方式就不在适用。 方案 android gradle 插件提供了 android.applicationVariants 索引来遍历所有的 build variant 后来，我们采取了一个方案，遍历 Build Variant，设置 extension 信息来兼容这种需求。 12345678910111213141516171819afterEvaluate { android.applicationVariants.each { variant -&gt; def bugtagsAppKey = null; def bugtagsAppSecret = null; if (variant.name.contains(\"debug\")) { bugtagsAppKey = 'APP_KEY_BETA' bugtagsAppSecret = 'APP_SECRET_BETA' } else if (variant.name.contains(\"release\")) { bugtagsAppKey = 'APP_KEY_LIVE' bugtagsAppSecret = 'APP_SECRET_LIVE' } variant.ext.bugtagsAppKey = bugtagsAppKey variant.ext.bugtagsAppSecret = bugtagsAppSecret }}apply plugin: 'com.bugtags.library.plugin' 总结 本文主要是介绍了 build variant 的概念，还介绍了两个日常应用案例。希望对大家有帮助。 参考资料 android-build-tool 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"Gradle 技巧","slug":"Gradle-技巧","permalink":"https://kvh.io/tags/Gradle-技巧/"}]},{"title":"拥抱 Android Studio 之五：Gradle 插件开发","slug":"embrace-android-studio-gradle-plugin","date":"2016-03-28T03:20:30.000Z","updated":"2021-01-13T01:42:18.823Z","comments":true,"path":"embrace-android-studio-gradle-plugin.html","link":"","permalink":"https://kvh.io/embrace-android-studio-gradle-plugin.html","excerpt":"","text":"官方文档给出了比较详细的实现步骤，本文的脉络会跟官方文档差不了太多，额外增补实际例子和一些实践经验。文中的代码已经托管到了 github 项目中。 需求 默认的 Android 打包插件会把 apk 命名成 module-productFlavor-buildType.apk，例如 app-official-debug.apk，并且会把包文件发布到固定的位置： module/build/outputs/apk 有的时候，这个命名风格并不是你所要的，你也想讲 apk 输出到别的目录。咱们通过 gradle 插件来实现自定义。这个插件的需求是： 输入一个名为 nameMap 的 Closure，用来修改 apk 名字 输入一个名为 destDir 的 String，用于输出位置 原理简述 插件之于 Gradle 根据官方文档定义，插件打包了可重用的构建逻辑，可以适用于不同的项目和构建过程。 Gradle 提供了很多官方插件，用于支持 Java、Groovy 等工程的构建和打包。同时也提供了自定义插件的机制，让每个人都可以通过插件来实现特定的构建逻辑，并可以把这些逻辑打包起来，分享给其他人。 插件的源码可以使用 Groovy、Scala、Java 三种语言，笔者不会 Scala，所以平时只是使用 Groovy 和 Java。前者用于实现与 Gradle 构建生命周期（如 task 的依赖）有关的逻辑，后者用于核心逻辑，表现为 Groovy 调用 Java 的代码。 另外，还有很多项目使用 Eclipse 或者 Maven 进行开发构建，用 Java 实现核心业务代码，将有利于实现快速迁移。 插件打包方式 Gradle 的插件有三种打包方式，主要是按照复杂程度和可见性来划分： ### Build script 把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见，笔者常用来做原型调试，本文将简要介绍此类。 ### buildSrc 项目 将插件源代码放在 rootProjectDir/buildSrc/src/main/groovy 中，只对该项目中可见，适用于逻辑较为复杂，但又不需要外部可见的插件，本文不介绍，有兴趣可以参考此处。 ### 独立项目 一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。 Build script 插件 首先来直接在 build.gradle 中写一个 plugin： 1234567891011class ApkDistPlugin implements Plugin&lt;Project&gt; { @Override void apply(Project project) { project.task('apkdist') &lt;&lt; { println 'hello, world!' } }}apply plugin: ApkDistPlugin 命令行运行 123$ ./gradlew -p app/ apkdist:app:apkdisthello, world! 这个插件创建了一个名为 apkdist 的 task，并在 task 中打印。 插件是一个类，继承自 org.gradle.api.Plugin 接口，重写 void apply(Project project) 方法，这个方法将会传入使用这个插件的 project 的实例，这是一个重要的 context。 接受外部参数 通常情况下，插件使用方需要传入一些配置参数，如 bugtags 的 SDK 的插件需要接受两个参数: 1234bugtags { appKey \"APP_KEY\" //这里是你的 appKey appSecret \"APP_SECRET\" //这里是你的 appSecret，管理员在设置页可以查看} 同样，ApkDistPlugin 这个 plugin 也希望接受两个参数： 1234567apkdistconf { nameMap { name -&gt; println 'hello,' + name return name } destDir 'your-distribution-dir'} 参数的内容后面继续完善。那这两个参数怎么传到插件内呢？ org.gradle.api.Project 有一个 ExtensionContainer getExtensions() 方法，可以用来实现这个传递。 声明参数类 声明一个 Groovy 类，有两个默认值为 null 的成员变量： 1234class ApkDistExtension { Closure nameMap = null; String destDir = null;} 接受参数 1project.extensions.create('apkdistconf', ApkDistExtension); 要注意，create 方法的第一个参数就是你在 build.gradle 文件中的进行参数配置的 dsl 的名字，必须一致；第二个参数，就是参数类的名字。 获取和使用参数 在 create 了 extension 之后，如果传入了参数，则会携带在 project 实例中， 1234def closure = project['apkdistconf'].nameMap;closure('wow!');println project['apkdistconf'].destDir 进化版本一：参数 1234567891011121314151617181920212223242526272829303132class ApkDistExtension { Closure nameMap = null; String destDir = null;}class ApkDistPlugin implements Plugin&lt;Project&gt; { @Override void apply(Project project) { project.extensions.create('apkdistconf', ApkDistExtension); project.task('apkdist') &lt;&lt; { println 'hello, world!' def closure = project['apkdistconf'].nameMap; closure('wow!'); println project['apkdistconf'].destDir } }}apply plugin: ApkDistPluginapkdistconf { nameMap { name -&gt; println 'hello, ' + name return name } destDir 'your-distribution-directory'} 运行结果： 12345$ ./gradlew -p app/ apkdist:app:apkdisthello, world!hello, wow!your-distribution-directory 独立项目插件 代码写到现在，已经不适合再放在一个 build.gradle 文件里面了，那也不是我们的目的。建立一个独立项目，把代码搬到对应的地方。 理论上，IntelliJ IDEA 开发插件要比 Android Studio 要方便一点点，因为有对应 Groovy module 的模板。但其实如果我们了解 IDEA 的项目文件结构，就不会受到这个局限，无非就是一个 build.gradle 构建文件加 src 源码文件夹。 最终项目的文件夹结构是这样： Java-Library 下面我们来一步步讲解。 ## 创建项目 在 Android Studio 中新建 Java Library module “plugin”。 修改 build.gradle 文件 添加 Groovy 插件和对应的两个依赖。 12345678//removed java plugin apply plugin: 'groovy'dependencies { compile gradleApi()//gradle sdk compile localGroovy()//groovy sdk compile fileTree(dir: 'libs', include: ['*.jar'])} 修改项目文件夹 src/main 项目文件下： 移除 java 文件夹，因为在这个项目中用不到 java 代码 添加 groovy 文件夹，主要的代码文件放在这里 添加 resources 文件夹，存放用于标识 gradle 插件的 meta-data 建立对应文件 12345678910111213141516.├── build.gradle├── libs├── plugin.iml└── src └── main ├── groovy │&nbsp;&nbsp; └── com │&nbsp;&nbsp; └── asgradle │&nbsp;&nbsp; └── plugin │&nbsp;&nbsp; ├── ApkDistExtension.groovy │&nbsp;&nbsp; └── ApkDistPlugin.groovy └── resources └── META-INF └── gradle-plugins └── com.asgradle.apkdist.properties 注意： groovy 文件夹中的类，一定要修改成 .groovy 后缀，IDE 才会正常识别。 resources/META-INF/gradle-plugins 这个文件夹结构是强制要求的，否则不能识别成插件。 com.asgradle.apkdist.properties 文件 如果写过 Java 的同学会知道，这是一个 Java 的 properties 文件，是 key=value 的格式。这个文件内容如下： 1implementation-class=com.asgradle.plugin.ApkDistPlugin 按其语义推断，是指定这个插件的入口类。 英文敏感的同学可能会问了，为什么这个文件的承载文件夹是叫做 gradle-plugins，使用复数？没错，这里可以指定多个 properties 文件，定义多个插件，扩展性一流，可以参考 linkedin 的插件的组织方式。 使用这个插件的时候，将会是这样： 1apply plugin:'com.asgradle.apkdist' 因此，com.asgradle.apkdist 这个字符串在这里，又称为这个插件的 id，不允许跟别的插件重复，取你拥有的域名的反向就不会错。 将 plugin module 传到本地 maven 仓库 参考上一篇：拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建，和对应的 demo 项目，将包传到本地仓库中进行测试。 添加 gradle.properties 1234567891011121314151617181920212223PROJ_NAME=gradlepluginPROJ_ARTIFACTID=gradlepluginPROJ_POM_NAME=Local RepositoryLOCAL_REPO_URL=file:///Users/changbinhe/Documents/Android/repo/PROJ_GROUP=com.as-gradle.demoPROJ_VERSION=1.0.0PROJ_VERSION_CODE=1PROJ_WEBSITEURL=http://kvh.ioPROJ_ISSUETRACKERURL=https://github.com/kevinho/Embrace-Android-Studio-Demo/issuesPROJ_VCSURL=https://github.com/kevinho/Embrace-Android-Studio-Demo.gitPROJ_DESCRIPTION=demo apps for embracing android studioPROJ_LICENCE_NAME=The Apache Software License, Version 2.0PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txtPROJ_LICENCE_DEST=repoDEVELOPER_ID=your-dev-idDEVELOPER_NAME=your-dev-nameDEVELOPER_EMAIL=your-email@your-mailbox.com 在 build.gradle 添加上传功能 12345678910apply plugin: 'maven'uploadArchives { repositories.mavenDeployer { repository(url: LOCAL_REPO_URL) pom.groupId = PROJ_GROUP pom.artifactId = PROJ_ARTIFACTID pom.version = PROJ_VERSION }} 上传可以通过运行： 1$ ./gradlew -p plugin/ clean build uploadArchives 在 app module 中使用插件 在项目的 buildscript 添加插件作为 classpath 123456789101112buildscript { repositories { maven{ url 'file:///Users/your-user-name/Documents/Android/repo/' } jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.1.0-alpha3' classpath 'com.as-gradle.demo:gradleplugin:1.0.0' }} 在 app module 中使用插件： 1apply plugin: 'com.asgradle.apkdist' 命令行运行： 12345$ ./gradlew -p app apkdist:app:apkdisthello, world!hello, wow!your-distribution-directory 可能会遇到问题 12Error:(46, 0) Cause: com/asgradle/plugin/ApkDistPlugin : Unsupported major.minor version 52.0&lt;a href=\"openFile:/Users/your-user-name/Documents/git/opensource/embrace-android-studio-demo/s5-GradlePlugin/app/build.gradle\"&gt;Open File&lt;/a&gt; 应该是本机的 JDK 版本是1.8，默认将 plugin module 的 groovy 源码编译成了1.8版本的 class 文件，放在 Android 项目中，无法兼容。需要对 plugin module 的 build.gradle 文件添加两个参数： 12sourceCompatibility = 1.6targetCompatibility = 1.6 真正的实现插件需求 读者可能会观察到，到目前为止，插件只是跑通了流程，并没有实现本文提出的两个需求， 那接下来就具体实现一下。 123456789101112131415161718192021222324252627282930313233class ApkDistPlugin implements Plugin&lt;Project&gt; { @Override void apply(Project project) { project.extensions.create('apkdistconf', ApkDistExtension); project.afterEvaluate { //只可以在 android application 或者 android lib 项目中使用 if (!project.android) { throw new IllegalStateException('Must apply \\'com.android.application\\' or \\'com.android.library\\' first!') } //配置不能为空 if (project.apkdistconf.nameMap == null || project.apkdistconf.destDir == null) { project.logger.info('Apkdist conf should be set!') return } Closure nameMap = project['apkdistconf'].nameMap String destDir = project['apkdistconf'].destDir //枚举每一个 build variant project.android.applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; File file = output.outputFile output.outputFile = new File(destDir, nameMap(file.getName())) } } } }} 必须指出，本文插件实现的需求，其实可以直接在 app module 的 build.gradle 中写脚本就可以实现。这里做成插件，只是为了做示范。 上传到 bintray 的过程，就不再赘述了，可以参考拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建。 后记 至此，这系列开篇的时候挖下的坑，终于填完了。很多人借助这系列的讲解，真正理解了 Android Studio 和它背后的 Gradle、Groovy，笔者十分高兴。笔者也得到了很多读者的鼓励和支持，心中十分感激。 写博客真的是一个很讲究执行力和耐力的事情，但既然挖下了坑，就得填上，对吧？ 这半年来，个人在 Android 和 Java 平台上也做了更多的事情，也有了更多的体会。 AS 系列，打算扩充几个主题： Proguard 混淆 Java &amp; Android Testing Maven 私有仓库深入 持续集成 ……待发掘 记得有人说，只懂 Android 不懂 Java，是很可怕的。在这半年以来，笔者在工作中使用 Java 实现了一些后端服务，也认真学习了 JVM 字节码相关的知识并把它使用到了工作中。在这个过程中，真的很为 Java 平台的活力、丰富的库资源、几乎无止境的可能性所折服。接下来，会写一些跟有关的学习体会，例如： Java 多线程与锁 JVM 部分原理 字节码操作 Java 8部分特性 ……待学习 随着笔者工作的进展，我也有机会学习使用了别的语言，例如 Node.js，并实现了一些后端服务。这个语言的活力很强，一些比 Java 现代的地方，很吸引人。有精力会写一写。 因为业务所需，笔者所经历的系统，正在处于像面向服务的演化过程中，我们期望建立统一的通讯平台和规范，抽象系统的资源，拆分业务，容器化。这是一个很有趣的过程，也是对我们的挑战。笔者也希望有机会与读者分享。 一不小心又挖下了好多明坑和无数暗坑，只是为了激励自己不断往前。在探索事物本质的旅途中，必然十分艰险，又十分有趣，沿途一定风光绚丽，让我们共勉。 参考文献 官方文档 系列导读 本文是笔者《拥抱 Android Studio》系列第四篇，其他篇请点击： 拥抱 Android Studio 之一：从 ADT 到 Android Studio 拥抱 Android Studio 之二：Android Studio 与 Gradle 深入 拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础 拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建 拥抱 Android Studio 之五：Gradle 插件使用与开发 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。 想要及时收到最新博客文章，请关注： 番外 笔者 kvh 在开发和运营 bugtags.com，这是一款移动时代首选的 bug 管理系统，能够极大的提升 app 开发者的测试效率，欢迎使用、转发推荐。 笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。 我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭： bugtags","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"EmbraceAndroidStudio","slug":"EmbraceAndroidStudio","permalink":"https://kvh.io/tags/EmbraceAndroidStudio/"},{"name":"拥抱 Android Studio","slug":"拥抱-Android-Studio","permalink":"https://kvh.io/tags/拥抱-Android-Studio/"}]},{"title":"如何更好的提出技术问题","slug":"a-good-question","date":"2016-02-03T03:18:16.000Z","updated":"2021-01-13T01:42:18.817Z","comments":true,"path":"a-good-question.html","link":"","permalink":"https://kvh.io/a-good-question.html","excerpt":"","text":"下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。 笔者从事 Bugtags.com 开发运营以来，除了开发任务以外，最重要的工作就是在 qq 群里面回答用户的问题。 这半年来，少说也接待了上千个用户了。笔者发现，有相当一部分的用户，提问方式和技巧都有问题，这样导致了我们额外的客服量，也使得自己的问题得不到及时满意的回答。 下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。 直接了当 有的用户，喜欢先问：『有人在吗？』 其实这个问句真的是很无意义，有问题直接提出来就好，有工作人员或者热心人看到了，能回答的自然就会回答，为什么还需要问有没有人在家呢？ 目的明确 有的用户，其实只是对某些技术点感兴趣，但是表现出来，是要给我们反馈 bug。这样我们就很摸不着头脑。 是吐槽、建议、反馈、赞扬还是学习？请一上来就说明。 有价值 列举一些个人认为没有价值的问题： PHP 是不是最好的语言？ VIM 还是 Emacs 好？ 学 Android 有没有前途？ 这种问题，没有讨论的价值。 已尝试求解 其实大部分我们遇到的技术问题，只要在谷歌或者百度上查找，大多能找到答案。 大部分情况下，使用 Bugtags 遇到的问题，都能通过我们的帮助文档解决。 但是我发现中国人真的很着急，文档也不看，帮助也不看，上来就问。 问题着眼点小 切忌提一些特别大的问题，例如『安卓如何管理内存』，这种是需要一些列文章才能阐述清楚的问题，显然是不适合在 QQ 群上提问的。 背景信息充足 举个例子，Bugtags SDK 支持 Android 和 iOS，但是大部分用户提问的时候，会忽略了这个信息。同样，常用的操作系统，也有 OSX 和 Windows，很多人也会忽略。 这里面其实有个思维盲点，提出问题的人，会忽略一些显而易见的环境差异，认为别人了解背景信息，具有跟他一样的运行环境和操作步骤。 问题描述信息充分 这个也需要换位思考，假设你是一个热心人，尝试帮助群上的人解答问题。是不是希望问题越准确越好？ 一些要点请备齐： 软硬环境及版本 操作步骤 期待结果 错误信息，最好是文本而不是截图 设备运行的 log 现场截图 已尝试过的解决方案 怀疑的点 重现问题的 Demo 创建你自己的 demo 程序，操作要友好 加上使用说明，描述你所遇到的问题，具体环境，操作步骤，帮助别人快速重现你的问题 打包你的 demo，上传到 github 或者百度云盘，让别人可以很快下载到 一个范例 stack-overflow 总结 提问技巧，也是属于沟通技巧之一。 笔者认为要达到有效的沟通，双方都需要有同理心，要换位思考。 愿这篇文章能为大家带来一些启发，能够收获更多满意的答案。","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"程序员必读","slug":"程序员必读","permalink":"https://kvh.io/tags/程序员必读/"}]},{"title":"拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建","slug":"embrace-android-studio-maven-deploy","date":"2016-01-20T03:20:30.000Z","updated":"2021-01-13T01:42:18.824Z","comments":true,"path":"embrace-android-studio-maven-deploy.html","link":"","permalink":"https://kvh.io/embrace-android-studio-maven-deploy.html","excerpt":"","text":"使用、创造和分享 笔者曾经不思量力的思考过『是什么推动了互联网技术的快速发展？』这种伟大的命题。结论是，除了摩尔定律之外，技术经验的快速积累和广泛分享，也是重要的原因。 有人戏称，『写 Java，首先要学会选包』，在这里不好评论对错。不过这句话里面，至少包含两层意思：首先 Java 有大量的现成的依赖包，不必要自己造轮子；其次，Java 的包存放较为集中，集成方式也方便。 笔者从事 Android 和 Java 开发以来，经历了几个阶段： 闭门造轮子 &gt; 使用别人的轮子 &gt; 开门造轮子 &gt; 分享轮子 在使用、创造、分享轮子的过程中，maven 仓库的使用可谓必备技能。 相信各位使用 Android Studio，对于 jcenter()、mavenCentral() 等概念应该是司空见惯了。程序员要知其然，知其所以然。本篇将按照如下脉络介绍在 Android Studio 中 Maven 仓库相关的概念和应用。 Maven 包 Maven 仓库 发布包到本地仓库 发布包到 Bintray Jcenter 远程仓库 发布包到 Sonatype MavenCentral 远程仓库 搭建私有 Sonatype 仓库 搭建私有 Artifacotory 仓库 Maven 包（Package） 至于 Maven 是什么，请参考 Apache Maven。 对于 Android 开发者而言，只需要知道 Maven 是一种构建工具，Maven 包是由所谓 POM（Project Object Model）所定义的文件包格式即可。 Gradle 可以使用 Maven 包，而且大部分的 Android 能够使用的远程依赖包都是 Maven 包。 先来看一个托管在某仓库上的 Maven 包：Bugtags-Android-Lib 所包含的内容： 12345678bugtags-lib-1.1.0-javadoc.jar//javadoc 文件bugtags-lib-1.1.0-javadoc.jar.asc//javadoc 文件的签名bugtags-lib-1.1.0-sources.jar//源码文件bugtags-lib-1.1.0-sources.jar.asc//源码文件的签名bugtags-lib-1.1.0.aar//Android Library 的主文件包bugtags-lib-1.1.0.aar.asc//主文件包的签名bugtags-lib-1.1.0.pom//包描述文件bugtags-lib-1.1.0.pom.asc//描述文件的签名 对于一个合符规范的 Maven Package，pom 文件、aar（或者 jar） 文件是必须的。 而 javadoc 文件、源码文件、签名文件都不是必要的，但是某些公开仓库（如 mavenCentral ）有此要求。 使用这个包的方式，相信大家已经很熟悉了： 123dependencies { compile 'com.bugtags.library:bugtags-lib:1.1.0'} POM 文件 一个 Maven Package，最重要就是 POM（Project Object Model） 文件，这其实是一个 XML 文件，这里截取 Bugtags-Android-Lib POM 主要内容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bugtags.library&lt;/groupId&gt; &lt;artifactId&gt;bugtags-lib&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;packaging&gt;aar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.android.support&lt;/groupId&gt; &lt;artifactId&gt;support-v4&lt;/artifactId&gt; &lt;version&gt;19.0.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; modelVersion: 从 mvn 2.x 起，这个数值都是4.0.0 packaging：打包方式，aar 是 Android Libirary 的打包方式，常用的还有 jar dependency：声明依赖列表 包的唯一标示： 123456&lt;!--包组 id，通常是发布者拥有的域名的反向，以免跟别人的重复--&gt;&lt;groupId&gt;com.bugtags.library&lt;/groupId&gt;&lt;!--包 artifactId，不好意思我也不知道如何准确翻译，其实就是组以下应该有一个更小的归类--&gt;&lt;artifactId&gt;bugtags-lib&lt;/artifactId&gt;&lt;!--包版本--&gt;&lt;version&gt;1.1.0&lt;/version&gt; 其中三个字段与 Gradle 的依赖格式 'com.bugtags.library:bugtags-lib:1.1.0' 冒号分割的三段一一对应。这就解释了所谓的 Gradle 兼容 Maven 包。 Maven 仓库 Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下面是笔者日常开发用的库列表： 123456789101112mavenCentral();jcenter()maven { url 'file:///Users/my-user-name/Documents/Android/repo/'}maven { url 'http://192.168.99.100:8081/content/repositories/releases/'}maven { url \"https://jitpack.io\" } Android Studio Gradle 主要支持两个 Maven 中央库：mavenCentral 和 jcenter。 mavenCentral 是最早的 maven 中央仓库 jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库 第三个是笔者的本机的仓库 第四个是笔者部署在内网服务器的私有仓库 第五个是可以把 github 项目发不成 maven 库（jitpack 本身是一个很酷的 idea） 读者可能会发现两个问题： 为什么有了 mavenCentral，谷歌还切换到了 jcenter？ maven { url : xxx}，这种格式可以配置任何一个存在的仓库？ 解释如下： jcenter VS. mavenCentral 根据这篇博客，jcenter 具有如下优胜特点，使得谷歌进行切换： jcenter 是一个 mavenCentral 的超集，jcenter 还包含了其他 maven 包 jcenter 具有更好的 cdn，默认支持 https，这个对于谷歌有巨大吸引力 bintray（jcenter 的服务提供商）表示 jcenter 具有更好的性能 有数据表明 bintray jcenter 占用更少的本地缓存空间 更好的交互界面，可以从 jcenter 向 mavenCentral 同步包（下面两个平台的使用教程将会证实这一点） 笔者亲测，在 bintray 上发布包到 jcenter 在易用性上的确比 在 sonatype 发布到到 mavenCentral 要好得多。 使用符合规范的 maven 仓库 没错，你可以通过 maven { url : xxx }使用任何一个符合 maven 规范的仓库。 存在本地的 123maven { url 'file:///Users/my-user-name/Documents/Android/repo/'} 存在内网服务器的 123maven { url 'http://192.168.99.100:8081/content/repositories/releases/'} 存在某个远程服务器的 123maven { url 'https://raw.githubusercontent.com/liaohuqiu/umeng-libs/master/repository'} 此仓库由 liaohuqiu 同学为方便大家使用友盟开发者工具，把相应的包做成了符合规范的 Maven 包，托管在 github 项目中。 发布 Maven 包 使用 maven 包相信已经很清楚了，让我们更进一步。 当我们在日常开发实践中，积累了一些公共库，想要固定下来，被自己或者别人方便的使用，就需要发布 maven 包。 一个符合规范的 maven 包至少包含 pom 文件和主文件包。难道这些都要手动编写和创建么？ 答案是：有了 gradle 插件，你只需要干很少的事儿。 全局设定 下面以发布这系列包为示例： groupId: com.as-gradle.demo //改成你的 groupId artifcatId: x //artifactId 会有些变化，这里先用 x 代替，下面会修改。 version: 1.0.0 也就是'com.as-gradle.demo:x:1.0.0' 读者要进行练习的时候，最好改一下你的 groupId，否则可能会发布失败 下面使用到的示例工程已经放在了 github 上。 为了后面使用方便，首先在工程的项目 gradle.properties 中定义一些属性，这些属性，主要是用生成 POM 文件，将会在通篇文章中用到： 12345678910111213141516171819# 包信息PROJ_GROUP=com.as-gradle.demoPROJ_VERSION=1.0.0# 项目的描述PROJ_WEBSITEURL=https://bugtags.comPROJ_ISSUETRACKERURL=https://github.com/bugtags/Bugtags-Android/issuesPROJ_VCSURL=https://github.com/bugtags/Bugtags-Android.gitPROJ_DESCRIPTION=Simple and effective bug &amp; crash reporting tool for Android apps# Licence信息PROJ_LICENCE_NAME=The Apache Software License, Version 2.0PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txtPROJ_LICENCE_DEST=repo# Developer 信息DEVELOPER_ID=your-dev-idDEVELOPER_NAME=your-dev-nameDEVELOPER_EMAIL=your-email@your-mailbox.com 发布包到本地仓库 创建一个 module：localrepo 将本地某个路径设置为仓库根目录： /Users/your-user-name/Documents/Android/repo/（ Mac 下） 这里使用了一个叫做 your-user-name 的用户下的某个目录，请读者__自行替换__成自己的登录用户名。 为了优雅，在 localrepo 这个 module 的 gradle.properties 定义属性： 123456PROJ_NAME=localrepoPROJ_ARTIFACTID=localrepoPROJ_POM_NAME=Local RepositoryLOCAL_REPO_URL=file:///Users/your-user-name/Documents/Android/repo/#以上是 Mac 的本地路径，如果是 Windows，则是类似：#LOCAL_REPO_URL=file:///C:/Users/cadmanager/Documents/repo/ 在 module 中应用和配置 maven plugin： 123456789apply plugin: 'maven'uploadArchives { repositories.mavenDeployer { repository(url: LOCAL_REPO_URL) pom.groupId = PROJ_GROUP pom.artifactId = PROJ_ARTIFACTID pom.version = PROJ_VERSION }} 在控制台运行： 1$ ./gradlew -p localrepo clean build uploadArchives --info 一切顺利的话，你的第一个本地包已经发布到设定的目录的本地仓库了： 1234567891011121314| ├── com│&nbsp;&nbsp; ├── as-gradle│&nbsp;&nbsp; │&nbsp;&nbsp; └── demo│&nbsp;&nbsp; │&nbsp;&nbsp; └── localrepo│&nbsp;&nbsp; │&nbsp;&nbsp; ├── 1.0.0│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── localrepo-1.0.0.aar│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── localrepo-1.0.0.aar.md5│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── localrepo-1.0.0.aar.sha1│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── localrepo-1.0.0.pom│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── localrepo-1.0.0.pom.md5│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── localrepo-1.0.0.pom.sha1│&nbsp;&nbsp; │&nbsp;&nbsp; ├── maven-metadata.xml│&nbsp;&nbsp; │&nbsp;&nbsp; ├── maven-metadata.xml.md5│&nbsp;&nbsp; │&nbsp;&nbsp; └── maven-metadata.xml.sha1 使用本地包（两个疑问向读者请教） 要使用这个包，首先在项目的 build.gradle 中添加这个本地仓库： 123456789allprojects { repositories { jcenter() maven{ url 'file:///Users/your-user-name/Documents/Android/repo/' } }} 在某个 module（如 demo 项目中的 app） 的 build.gradle 中添加依赖： 1compile 'com.as-gradle.demo:localrepo:1.0.0@aar' 这里有两个奇怪的地方，笔者也没有深入研究，初步猜测是 Android Studio 的 Bug，知道答案的读者请到我博客文章下留言赐教： * 依赖末尾一般都需要加一个`@aar`，在某些版本的 Android Studio，又不需要，这是为什么？ * 另外，如果本地包本身使用了了远程的依赖，也需要在使用本地包的时候，一并加上，否则会报缺少包，这又是为什么？ 想要让更多的人使用到你的劳动成果，你就需要把 Maven 包放在一个别人有权访问的远程仓库上，而不是本机，接下来要介绍发布 Maven 到 jcenter 仓库和 mavenCentral 仓库。因为前者的使用简单，本着『先易后难，快速出成效』的原则，我先介绍 jcenter 的上传。 发布包到 Bintray jcenter 远程仓库 简介 jcenter 是由 bintray 提供的 maven 中央库托管服务，bintray 又是 jfrog 公司的一款产品。jfrog 是一个商业公司，通过提供高级服务盈利，又为普通开发者提供了足够用的免费基础功能（截止至2016-01-24），笔者较为推崇这种开发者服务的商业模式。 引用一张图来表述 bintray 的工作方式 how-bintray-works 图片来源，http://inthecheesefactory.com/ 使用 jcenter 需要在 bintray 上注册账号，在本地进行加密签名配置，下面开始介绍。 1. 注册账号 登陆 jcenter 首页 sigin -&gt; signup，填写表单，注意 username 这一栏是后面的 bintray 私有库的后缀，要慎重选择。 2. 创建 GPG 签名 前方高能预警：比较繁琐，切勿半途放弃 前面介绍过，可以把 bintray 的包同步到 mavenCentral，而后者需要对包文件进行签名，签名和验证过程需要用到一个叫做 GPG 的工具产生的公钥和私钥。这里有适合多个平台的 GPG 程序，下面只介绍 OSX 平台。 这种工具大概的意义是产生公钥和私钥，把公钥发送到公开的服务器，私钥用来产生包文件签名。包的使用者在拿到包文件之后，通过公钥来验证文件的有效性，运行具体原理参考这里。 下载 gpgtool，安装 检测安装成功，在命令行运行 123$ gpg --versiongpg (GnuPG/MacGPG2) 2.0.28libgcrypt 1.6.3 有类似的输出，就是正常安装了 产生证书，运行命令，按照提示输入 1$ gpg --gen-key 检查结果 1$ gpg --list-keys 找到刚才创建证书的时候，输入的相关信息那三行，例如： 123pub 2048R/2E686B39 2015-06-02uid [ultimate] Your Name &lt;your-email@your-mailbox.com&gt;sub 2048R/your-sub-key-id 2015-06-02 上传公钥到服务器，找到你的 pub 的那一行，2048R/后的那一串八位字符串，如上面的：2E686B39，就是公钥 ID 1$ gpg --keyserver hkp://pool.sks-keyservers.net --send-keys your-public-key-id 输出公钥和私钥成文件 12$ gpg -a --export your-email@your-mailbox.com &gt; public_key_sender.asc$ gpg -a --export-secret-key your-email@your-mailbox.com &gt; private_key_sender.asc 配置本地 gradle 运行环境的属性，位于~/.gradle/gradle.properties，添加内容： 123signing.keyId=your-public-key-idsigning.password=your-gpg-passwordsigning.secretKeyRingFile=/Users/your-user-name/.gnupg/secring.gpg bintray 本身可以通过在 profile-&gt;GPG Sining中配置 public key 和 private key 来自动对上传的文件进行签名，在下图中，对应填入 public_key_sender.asc 与 private_key_sender.asc 的内容即可。 设置 bintray maven 包自动签名 选取 maven 仓库首页，进入 edit： auto-sign 最下面有两个选项： 12GPG sign uploaded files using Bintray's public/private key pair.GPG Sign uploaded files automatically 因为咱们是希望使用自己的 key，所以勾选第二个。 3. 创建 bintray 项目 首页-&gt; maven -&gt; add new package，填入对应的信息，其中 name 是在下面 bintray gradle 插件上传的时候，使用的项目名称，例如：bintryaar，这是要上传一个 Android Library，上传纯 Java 包的方式有点点不一样，下面有介绍。 create-package 4. 配置插件 bintray 官方在 github 上托管了 bintray-examples，方便用户使用 gradle 上传包。 因为这里要上传的是 aar 格式的包，所以，具体是参考 gradle-aar-example 例子，然而例子有一些地方没有更新，请注意下面的描述。 在项目中创建 local.properties 来配置 bintray 登陆信息以及 gpg 证书密码 123bintray.user=your-bintray-userbintray.apikey=your-bintray-apikeybintray.gpg.password=your-gpg-password 其中 your-bintray-user 就是 bintray 右上角显示的用户名称，your-bintray-apikey 在 profile-&gt;API Key 可以找到，your-gpg-password 则是创建 gpg 证书的时候的密码 在项目的 build.gradle 配置 buildscript 的 classpath 1234567891011buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:1.3.0' //下面两个包是用于上传的插件 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'//注意此处 }} 在 module 的 gradle.properties 文件中定义属性 123PROJ_NAME=bintrayaarPROJ_ARTIFACTID=bintrayaarPROJ_POM_NAME=Bintray Aar Repository 在 module 的 build.gradle 中使用插件 12apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray' 为了build.gradle 文件干净，笔者创建了一个名为 bintray.gradle 的文件配置插件信息，请参考这个文件。 关键点： 1234artifacts { archives javadocJar archives sourcesJar} 是为了同时生成 javadoc.jar 和 sources.jar 文件 build，上传 1$ ./gradlew -p bintrayrepo/ clean build bintrayUpload --info 如果一切顺利，你会在控制台看到多个文件上传成功的标输出 踩坑实录 HTTP/1.1 401 Unauthorized apikey 或者 user 填写错误 HTTP/1.1 409 Conflict 包的该版本已经存在，需要在 bintray 管理界面上删除该版本后才可以再次上传 想让 sources.jar 或者 javadoc.jar 为空 12345task sourcesJar(type: Jar) { classifier = 'sources' from sourceSets.main.java.srcDirs exclude '**'} 5. 上传 Jar 包 在上传 jar 的时候，使用的插件有些区别 12apply plugin: 'maven-publish'apply plugin: 'com.jfrog.bintray' 在生成符合规定的 pom 文件的时候，要调用 groovy 的API，具体请参考这个文件 6. 通过私有仓库的方式引用 至此，刚才上传的两个库，已经可以通过如下方式引用了 1234567allprojects { repositories { maven { url 'https://dl.bintray.com/freefaces/maven'//这个地址在包的页面的右方 } }} 12compile 'com.as-gradle.demo:bintrayaar:1.0.0'compile 'com.as-gradle.demo:bintrayjar:1.0.0' 但是你也发现了，包的用户需要添加一个额外的 maven 仓库。作为一个以用户价值为先的库的开发者，那当然不希望用户麻烦的。那就需要把这个私有的库，推送到 jcenter 上去。 7. 推送到 jcenter 在 bintray 的 maven 库的界面，有 add to jcenter add-to-jcenter 点击之后，会进入一个消息页面，写或者不写都可以。提交，等待回复即可。 记住,包必须满足如下条件： 包含 sources.jar 和 javadoc.jar 文件 必须是 maven 包 bintray 的消息系统有些 bug，假设你的包提交申请被驳回，你修改之后再提交申请，可能没有人回复你。请不要傻等。直接找页面右侧的 Feedback，这个他们是很快有人回答的。 成功了之后，会出现如下的标记： inclusion-succeed 你可以在 jcenter 服务器上看到你的包了 8. 推送到 mavenCentral 在包管理页面，可以找到推送到 mavenCentral 功能， 一个包要从 bintray 推送到 jcenter，有几个前提： 已经推送到了 jcenter[已完成] 每个文件都有对应的签名[已完成] 有 sonatye 账户[未完成] maven 仓库经过审核[未完成] 点击 Sync 之后，一段时间之后，右边的 Sync Status 会反馈出结果。 当然了，现在咱还干不了这个，因为还有两个条件没准备好。那咱们就进入 mavenCentral 的条件准备。 发布包到 Sonatype MavenCentral 远程仓库 1. 注册 sonatye 账户 进入 sonatype issue 页面，注册账号。 2. 创建 issue 登陆之后，顶部有按钮，Created，下面是关键的条目 Project: Community Support - Open Source Project Repository Hosting (OSSRH) Issue Type: New Project Group Id：就是你的包的 groupId 其他的都认真填写。确认之后，大概两个工作日， Issue 会变成 resolved 状态，就可以发布你的包了。有了这两部，其实就可以从 bintray 上直接反向推到 mavenCentral ，而不需要走下面的步骤了，但是我还是简略介绍一下下面的步骤。如果很感兴趣详情，可以参考 trinea 的介绍。 3. 上传包 也有方便的 gradle 插件帮助我们进行传送，可以参考 chrisbanes/gradle-mvn-push 项目。配置好插件，上传。 4. 发布包 登陆 oss sonatype，登陆，选择左边栏里的 Staging Repositories, 然后点Close 按钮，sonatype 会做响应的 validation，通过的话，就可以点 Release 发布啦，如果不通过，就检查问题，先 Drop，并重新做 Staging 发布。 5. 检查包 在 https://oss.sonatype.org/content/repositories/releases 可以看到你发布的包。 6. 为何如此简略 因为这个过程真的很繁琐，ui 也不友好，在体验了 bintray 的便捷和友好，并发现 bintray 可以反向推送到 mavenCentral 之后，我就再也不想使用 sonatype 了。无奈，贪嗔痴是人类天性。 搭建私服 由于“你懂得”的原因，在国内访问 jcenter，总是偶尔不稳定，经常会出现诸如 peer not found 这种错误。为了保证用户的稳定使用库，那就要考虑搭建放在自己服务器上的私有仓库。 Sonatype 和 bintray 都提供了可供自己部署的 maven 库管理软件。Sonatype 提供了免费的 sonatype/nexus，bintray 提供了免费的 artifactory-oss。 为了部署简便，笔者使用了 docker 进行这两个私服搭建。对于 docker 是什么，怎么用，并不是系列文章的重点。有兴趣可以自行学习。入门文档在此。 搭建私有 Sonatype 仓库 下载安装 docker 镜像 1$ docker pull sonatype/nexus 运行镜像 1$ docker run -d -p 8081:8081 --name nexus sonatype/nexus:oss 访问服务器 因为的 docker-machine ip 是：192.168.99.100，于是可以通过在浏览器访问http://192.168.99.100:8081/ 这个 URL 来访问 sonatype 私服。 你会发现这个界面跟你在https://oss.sonatype.org/看到的几乎一样。 默认账户密码是： 12adminadmin123 设置仓库 点击左侧 repository，会出现 repository 的列表，把其中的 Releases 的 Configutation-&gt;Access Setting-&gt; Deploy Polocy 设置成 Allow Redeploy 使得可以重复发布包。 配置和使用插件 我还是使用了 chrisbanes/gradle-mvn-push 插件，稍微改动了一下字段的值，主要改动是环境配置，如账号密码，repository URL 等，具体请参考这里 mvn-push。 关键设置 要在gradle.properties 中设置： 123456PROJ_NAME=sonatyaarPROJ_ARTIFACTID=sonatyaarPROJ_POM_NAME=Sonatye Aar RepositoryPOM_PACKAGING=aarRELEASE_REPOSITORY_URL=http://192.168.99.100:8081/content/repositories/releasesSNAPSHOT_REPOSITORY_URL=http://192.168.99.100:8081/content/repositories/snapshots 查看 上传成功之后，就可以在浏览器的http://192.168.99.100:8081/content/repositories/releases看到这个包。并可引用了。 错误 上传的时候，返回400，可能是Configutation-&gt;Access Setting-&gt; Deploy Polocy没设置好；返回401，可能是账号密码错误。 搭建私有 Artifactory 仓库 bintray 其实提供了多个私有部署仓库的版本，分别是： 123Artifactory OSSArtifactory ProArtifactory Pro Registry 按名字来看，后两者可能是收费的，这里就只介绍 Artifactory OSS，依然是使用 docker 进行部署运行。更详细的使用手册，参考 Running with Docker。 下载镜像（截止至2016-01-27，最新版本是4.4.1） 1$ docker pull jfrog-docker-reg2.bintray.io/jfrog/artifactory-oss:4.4.1 运行镜像 1$ docker run -d -p 8080:8081 jfrog-docker-reg2.bintray.io/jfrog/artifactory-oss:4.4.1 在浏览器中访问http://192.168.99.100:8080/，默认账号密码是： 12adminpassword 笔者写到这，发现这个篇幅已经太长了。现在的读者，其实也没有太多耐心看长篇大论，所以考虑将更详细的私服的部署，放在一篇独立的博客中讲解。 kevinho/gradle-maven-complete 为了方便读者使用 gradle 将 aar、jar包推送到 jcenter 和 mavenCentral，笔者决定将本文所使用的 sample 项目，分离出一个独立的 github 项目：kevinho/gradle-maven-complete，里面包含如下范例： localrepo：本地仓库推送 bintrayaar：bintray 的 aar 包推送 bintrayjar：bintray 的 jar 包推送 sonatypearr：mavenCentral 的 aar 包推送 基本上覆盖到了主流的场景了，希望我这个小轮子，也能帮助大家，喜欢记得 star 哦！ 总结 这一篇，笔者结合实例讲解了 maven 仓库相关的知识，以及将 maven 包通过 gradle 插件上传本地仓库、bintray jcenter、sonatype mavenCentral，还简要介绍了 sonatype 和 artifactory 私服的 docker 搭建。或许你已经蠢蠢欲动了，那就赶紧打开你的电脑，把你的轮子，用 maven 武装起来吧！下一篇会介绍 gradle 插件的编写以及发布使用，敬请期待！ 参考文献 inthecheesefactory.com trinea.cn wikipedia apache-maven sonatype-central bintray-manual 系列导读 本文是笔者《拥抱 Android Studio》系列第四篇，其他篇请点击： 拥抱 Android Studio 之一：从 ADT 到 Android Studio 拥抱 Android Studio 之二：Android Studio 与 Gradle 深入 拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础 拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建 拥抱 Android Studio 之五：Gradle 插件使用与开发 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。 番外 笔者 kvh 在开发和运营 bugtags.com，这是一款移动时代首选的 bug 管理系统，能够极大的提升 app 开发者的测试效率，欢迎使用、转发推荐。 笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。 我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭： bugtags","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"EmbraceAndroidStudio","slug":"EmbraceAndroidStudio","permalink":"https://kvh.io/tags/EmbraceAndroidStudio/"},{"name":"拥抱 Android Studio","slug":"拥抱-Android-Studio","permalink":"https://kvh.io/tags/拥抱-Android-Studio/"}]},{"title":"拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础","slug":"embrace-android-studio-groovy-gradle","date":"2016-01-04T03:20:30.000Z","updated":"2021-01-13T01:42:18.823Z","comments":true,"path":"embrace-android-studio-groovy-gradle.html","link":"","permalink":"https://kvh.io/embrace-android-studio-groovy-gradle.html","excerpt":"","text":"关于学习方式续 回忆起大学那个白衣飘飘的年代，开始金工实习却发现基础学的不牢靠，越来越胆小，越来越糊涂。所幸得到一位高年级学姐指导，赶紧找当时的书或者笔记，快速把基础知识温习一遍，再结合实践中思考，终于豁然开朗。 相信看过前一篇 《Android Studio 与 Gradle 深入》的同学，有一部分就会遇到我初识 Gradle 时的困惑：代码我也依稀看得懂，但就是不知道还能这样写，为什么这样写。 问题与解决方案 回想我在 Gradle 的学习过程中遇到的问题与及其解决方案，总结出下面三点： 原理不懂：学习 Groovy 与 Gradle 的基础原理 Gradle 实践不懂：学会找示例，学习开源例子 方法和属性不懂：学会查文档 下面的我将以解决三个问题为线索，介绍 Groovy 和 Gradle。 学习 Groovy Groovy 概述 Gradle 采用了 Groovy 语言作为主要的脚本语言。一个 build.gradle 文件，其实是一个 Groovy 类。 Groovy 是一个基于 JVM 的语言，代码最终编译成字节码（bytecode）在 JVM 上运行。它具有类似于 Java 的语法风格，但是语法又比 Java 要灵活和方便，同时具有动态语言（如 ruby 和 Python）的一些特性。 Groovy 的诸多特定，很适合用来定义 DSL（Domain Specific Language）。 简单的来讲 DSL 是一个面向特定小领域的语言，如常见的 HTML、CSS 都是 DSL，它通常是以配置的方式进行编程，与之相对的是通用语言（General Purpose Language），如 Java 等。 既然是一门语言，就肯定有自己的特性。我们要从下面几个步骤来介绍 Groovy： * 环境安装 * 语言基础 * 语言特性及其本质 环境安装 Groovy 官方安装文档提供多种方式进行安装，确保你不会在跪在环境配置的路上 - ： Windows 下推荐 binary 包配置环境变量 Mac 下推荐使用 sdkman 或者 Brew 进行安装 Linux 下推荐 sdkman 嵌入在程序中，则推荐使用 Maven 远程依赖 初学者也没有必要使用IDE，平添障碍，后期用 Intellij IDEA Community 版本足矣。 下面只介绍 Mac 下使用 sdkman 的安装方式。 下载安装 sdkman，执行下面命令，按照提示安装即可 1$ curl -s http://get.sdkman.io | bash 使环境变量生效 1$ source \"$HOME/.sdkman/bin/sdkman-init.sh\" 安装 Groovy 1$ sdk install groovy 查看当前版本，如果能否运行且输出对应版本，就是成功了 12$ groovy -versionGroovy Version: 2.4.4 JVM: 1.8.0_25 Vendor: Oracle Corporation OS: Mac OS X 初探 安装好环境之后，先来一个 hello, world！ 新建文件 1$ vim test.groovy 在其中写上内容 1println \"hello, world!\" 保存退出，执行 12$ groovy test.groovyhello, world! Wow, So easy! 语言基础 下面将会用一些实际的例子，介绍一些最重要的点， &gt; 例子都已经传到 github 的 demo 项目中。 &gt; 第一次使用 demo 项目的时候，需要等待自动下载几个远程包。 &gt; 笔者一个 Java 程序员，可以你能够看到很多 Java 的习性还是留在代码中。 文件与类，变量与函数 Groovy 代码文件，支持不显式声明类： &gt; ScriptClass.groovy 1println 'hello,world' 这样一个 Groovy 脚本，经过编译之后，会产生一个继承自 groovy.lang.Script 类的子类： 是不是能看出点什么？ groovy/build/classes/main/io/kvh/as/groovy/ScriptClass.class 1234567891011121314151617181920public class ScriptClass extends Script { public ScriptClass() { CallSite[] var1 = $getCallSiteArray(); } public ScriptClass(Binding context) { CallSite[] var2 = $getCallSiteArray(); super(context); } public static void main(String... args) { CallSite[] var1 = $getCallSiteArray(); var1[0].call(InvokerHelper.class, ScriptClass.class, args); } public Object run() {//关键方法 CallSite[] var1 = $getCallSiteArray(); return var1[1].callCurrent(this, \"hello,world\");// got it? }} Groovy 支持如下的方式来定义变量和函数： &gt; VarAndMethod.groovy 12345678910def varAndMethod() { def a = 1//不显式声明变量类型 a = \"abc\"//运行时改变类型 println a//无需；结束一行代码 a = 4//最后一行作为返回值}def ret = varAndMethod()//文件内运行方法println ret//输出4 字符串 Groovy 支持单引号，双引号，三单引号声明一个字符串； Quoted.groovy 12345678910def quoted() { def singleQ = 'hello, single quot'// 声明为java.lang.String def doubleQ = \"hello, double quot ${singleQ}\"// 如果有${},则为groovy.lang.GString，支持变量替换;否则为java.lang.String def tripleQ = '''hello,triple quot'''// 允许多行，而不需要+号 println singleQ println doubleQ println tripleQ} Groovy 还支持以： 123\"\"\"...\"\"\"/.../$/.../$ 来声明字符串，详情参见参考文档。 List，Array 和 Map Groovy 默认使用 java.util.ArrayList 来提供 List 服务，但提供了更加灵活易用的操作方式： &gt; Collections.groovy 1234567def playList() { def lst = [\"a\",2,true]//支持不同类型元素 println(lst)}playList() 要使用 Array，需要显式声明： 123456789def playArray() { def intArr = [1, 2, 3] as int[]//显示声明 String[] strArr = [\"a\", \"b\"]//另外一种方式 println(intArr) println(strArr)}playArray() 使用 key:value 的方式定义 Map，注意 key 的正确使用方式： 1234567891011121314def playMap() { def map = [a: \"a\", b: \"b\"] println(map) def key = \"name\" def map2 = [key: 'a']//未使用 def map3 = [(key): 'a']//使用 println(map2) println(map3)}playMap() import Groovy 提供了更强大的 import 默认 import，这些类都是被默认 import 到代码中的，可以直接使用 12345678import java.lang.*import java.util.*import java.io.*import java.net.*import groovy.lang.*import groovy.util.*import java.math.BigIntegerimport java.math.BigDecimal import alias 引入一个类，通过 as 关键字赋予一个别名，有点 JavaScript 的意思么？ Import.groovy 123import java.lang.String as KStringprintln(new KString(\"aaa\")) 语言特性及其本质 Closure（闭包） 闭包的概念不再赘述，大概就是可以将函数作为参数传递和使用，详情参见 [wikipedia](https://zh.wikipedia.org/zh/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)。 1{ [closureParameters -&gt; ] statements } 可以省略方括号内的内容，也就是说，可以没有参数列表。 Closure.groovy 当闭包不声明参数列表，默认参数是 it；闭包被定义之后，是一个 Closure 对象，可以对其调用 call 方法使其执行。 123456789101112131415def defaultIt() { 3.times { println it //默认参数 it }}defaultIt()def closureObj() { def obj = { a -&gt; ++a } println obj.call(1)}closureObj() 面向对象特性 定义和实例化一个类 GroovyCLass.groovy 1234567class People{ String name int age}People p1 = new People();People p2 = new People(name:\"Luis\",age: 29)//通过类似 map 的方式赋值参数 方法的默认参数 123456def foo(String p1, int p2 = 1) { println(p1) println(p2)}foo(\"hello\") Field 和 Property Field 是以各种修饰符修饰的变量。Property是私有变量和自带的 gettters/setters， 下面的类具有私有变量 name、age，并自带这两个变量的 getter 和 setter： 1234class People{ String name int age} 当变量声明为 final 的时候，默认就没有 setter Trait Groovy 提供了一个叫做 Trait 特性实现了多继承，还有很多强大的功能，读者可以自己探索。 12345678910111213141516171819trait Fly { void fly() { println(\"fly\") }}trait Walk { void walk() { println(\"walk\") }}class Duck implements Fly, Walk {}Duck duck = new Duck()duck.fly()duck.walk() Groovy 基础小结 至此，我们已经熟悉了 Groovy 的基本语法和特性，相信你也能够使用 Groovy 写一些基础程序了。Groovy 还有很多深入的内容，请用到的时候，参考这本这个 pdf： 《Programming Groovy 2》。 下面开始介绍使用 Groovy 写 Gradle 程序，主要的内容来自 《Gradle Sser Guide》。 学习 Gradle Gradle 安装 三种方式安装 Gradle： 下载 zip 安装包 Mac 下使用 home brew 1brew install gradle 推荐：使用 IntelliJ IDEA（Android Studio）自带的 wrapper 结构来下载 Gradle Wrapper 是为了让不同版本的插件能够使用其对应版本的 Gradle 的一个机制 Gradle Wrapper 会把不同的版本 Gradle 安装在： 1$USER_HOME/.gradle/wrapper/dists Gradle Build 的生命周期 回忆一下《Android Studio 与 Gradle 深入》中的 Android Studio 项目文件结构： 12345678.├── app //app module│&nbsp;&nbsp; ├── build.gradle //app module 的 build.gradle├── build.gradle //项目 build.gradle，通常配置项目全局配置，如 repositories 和 dependencies├── gradle.properties //项目属性文件，通常可以放置一些常量├── lib //lib module│&nbsp;&nbsp; ├── build.gradle //lib module 的 build.gradle└── settings.gradle //项目总体设置，通常是配置项目中所有的 module Gradle 构建三个阶段： 初始化：Gradle 支持单 module 构建和多 module 构建（Android Studio 创建的项目默认是多 module）。初始化阶段，Gradle 会为每一个 module 中的 build.gradle 文件创建一个 Project 实例。 配置：项目根目录的 build.gradle 会首先被执行 执行：执行所选取的 task Settings.gradle 多 module 构建要求在项目根目录下有一个 settings.gradle，用来指定哪些 module 参与构建，如： settings.gradle 123include ':app', ':groovy'println 'print in settings.gradle' 在 settings.gradle 文件中，添加一行打印语句，在控制台中，切换到当前项目根目录下执行： 1./gradlew -p groovy build 可以在看出 settings.gradle 的代码每次都会率先执行。 Task 接下来，我们开始学习 Gradle 的核心 Task。 groovy/build.gradle 定义一个 Task： 12345task hello { doLast { println 'Hello,' }} 执行命令，查看输出： 12$ ./gradlew helloHello, Task 也可以这样定义： 123task World &lt;&lt; { println 'World!'} 注意，如果定义成这样： 123task hi { println 'description hi'} 在进行初始化和配置的时候，下面语句就会运行。 1println 'hi' 这种语法通常是用来定义 task 的描述信息。 Task 可设置 dependsOn 和 finalizedBy： 1234567891011task hello { doLast { println 'Hello,' }}task intro(dependsOn: hello) &lt;&lt; { println 'intro'}World.finalizedBy hello 执行 intro 之前，会先执行 hello；执行 World 之后，会自动执行 hello。 Plugin Gradle 的核心代码，只提供了一个框架，具体的功能（如构建 Android 工程）是通过插件机制来实现的。 Gradle 提供了大量官方的插件，如 Maven、Groovy、Java、Publishing、Signing等，也有大量第三方的插件（Android），甚至每个人都可以自己实现一个插件(如 笔者开发的 Bugtags 插件，这个将在最后一篇讲述)。 这些 plugin 定义了一系列的 task、DSL 和约定，在build.gradle 文件使用这些 plugin： 1apply plugin: java 当你写了一个独立的 file_uri.gradle 文件，你可以通过： 1apply from: 'file_uri.gradle' 来引入你的 gradle 文件，这个文件甚至可以在某个服务器上。 Gradle 实践参考 学习了基础理论之后，如果你还是不知道如何开始写，那就先来实现一个自定义 apk 名称的功能吧！ 12345678910111213android.applicationVariants.all { variant -&gt;//获取 variant 参数，就是 productFlavor x buildType variant.outputs.each { output -&gt;//获取输出文件 def file = output.outputFile//修改实例 output.outputFile = new File( (String) file.parent, (String) file.name.replace( file.name, // alter this string to change output file name \"Your_Apk_Name_\" + variant.name + \"_\" + variant.versionName + \".apk\" ) ) }} 你问我怎么知道 android 下有个 applicationVariants？其实我也不知道的，也得找文档。 因为使用的是 Android 的插件，那就得在谷歌搜 “android gradle plugin dsl”，果然有个 Android Plugin DSL Reference。 点进去找找，里面有关于 build variant 的文档： applicationVariants，既然是一个 Set，那就可以调用 all 方法。 写代码调试，再配合文档，你就晓得该怎么写了。 如果你还是不知道如何入手，那我提供几个开源参考： gradle-bintray-plugin：bintray 提供的开源插件 gradle-node-plugin： 一个运行 NodeJS 脚本的插件 linkedin-gradle-plugins： linkedin的 Gradle 插件集合 参考文档 相信参照开源项目动手写了几个小程序之后，你已经小有感觉了，那就记得把文档地址备齐了，用到的时候，查一下： Groovy Documentation：Groovy 的详细介绍文档 Groovy API Reference：Groovy 的 API 文档，必要的时候查阅 Gradle User Guid：Gradle 的详细介绍文档，很有必要过一遍 Gradle Build Language Reference：Gradle DSL 参考，重点的几个 DSL 过一下，其他的用到再查 Android Plugin DSL Reference：使用 Android 插件必备 另外，也有大量很好的中文文档，比如这几篇： 邓凡平老师的 Gradle 介绍 Gradle User Guide 中文版 总结 笔者从 Gradle 入门到现在略懂，经历了大量懵懂的时光。最后狠下心去系统学习了 Groovy 和 Gradle 的基础之后，最终茅塞顿开。希望读者遇到类似的情况，一定要沉下心，多学多练。 在接下来的两篇，我将分别介绍将发布远程库和编写 Gradle 插件。 系列导读 本文是笔者《拥抱 Android Studio》系列第三篇，其他篇请点击： 拥抱 Android Studio 之一：从 ADT 到 Android Studio 拥抱 Android Studio 之二：Android Studio 与 Gradle 深入 拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础 拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建 拥抱 Android Studio 之五：Gradle 插件使用与开发 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。 番外 笔者 kvh 在开发和运营 bugtags.com，这是一款能够极大的提升 app 开发者测试效率的 SDK 产品，欢迎使用、转发推荐。 笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。 我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭： bugtags","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"EmbraceAndroidStudio","slug":"EmbraceAndroidStudio","permalink":"https://kvh.io/tags/EmbraceAndroidStudio/"},{"name":"拥抱 Android Studio","slug":"拥抱-Android-Studio","permalink":"https://kvh.io/tags/拥抱-Android-Studio/"}]},{"title":"拥抱 Android Studio 之二：Android Studio 与 Gradle 深入","slug":"embrace-android-studio-indepth","date":"2015-12-17T03:20:30.000Z","updated":"2021-01-13T01:42:18.823Z","comments":true,"path":"embrace-android-studio-indepth.html","link":"","permalink":"https://kvh.io/embrace-android-studio-indepth.html","excerpt":"","text":"关于学习方式 曾经跟朋友讨论过我们所接受过的大学工科教育，都是一上来先学基础理论，最后再来一个金工实习。一开始不知道为什么而学，学不进去，荒废了基础，等到金工实习的时候，又发现基础不牢，后悔不已。 考虑到传统教育方式的不足之处，笔者在组织本系列文章的时候是先讲入门实例，进而学习 Gradle 和 Groovy 基础原理，最后学习进阶实例。 上篇文章介绍了从 ADT 迁移到 Android Studio，相信经过很短时间的使用之后，已经开始熟悉和爱上 Android Studio 了。基础的功能我就不讲了，下面列举一些较为深入又比较实用的功能。 Android Studio 相关功能介绍 文件夹组织视图 最常用的有 Project 和 Android 视图，前者按照项目文件树进行组织，后者是以 Gradle 构建文件作为核心进行组织： Project 视图与 Android 视图 Gradle 相关文件结构 让我们来观察一下Android Studio 中 Gradle 相关的结构： 1234567891011121314151617181920212223242526.├── gradle│&nbsp;&nbsp; └── wrapper //所使用的 Gradle 包装器配置├── .gradle //所使用 Gradle 版本│&nbsp;&nbsp; └── 2.8├── AsInDepth.iml├── app //app module│&nbsp;&nbsp; ├── app.iml│&nbsp;&nbsp; ├── build│&nbsp;&nbsp; ├── build.gradle //app module 的 build.gradle│&nbsp;&nbsp; ├── libs│&nbsp;&nbsp; ├── proguard-rules.pro│&nbsp;&nbsp; └── src├── build.gradle //项目 build.gradle，通常配置项目全局配置，如 repositories 和 dependencies├── gradle.properties //项目属性文件，通常可以放置一些常量├── gradlew //Gradle 包装器可执行文件├── gradlew.bat //Gradle 包装器可执行文件(Windows)├── lib //lib module│&nbsp;&nbsp; ├── build│&nbsp;&nbsp; ├── build.gradle //lib module 的 build.gradle│&nbsp;&nbsp; ├── lib.iml│&nbsp;&nbsp; ├── libs│&nbsp;&nbsp; ├── proguard-rules.pro│&nbsp;&nbsp; └── src├── local.properties //项目的本地属性，通常是 sdk 所在位置└── settings.gradle //项目总体设置，通常是配置项目中所有的 module Invalidate Cache Android Studio 会出现索引的问题，那可以从删除 cache 重建索引，File-&gt;Invalidate Caches/Restart Multiple Language Editor 多语言文字可以通过右击文件 Open Translation Editor，可以同时进行编辑，但是我发现如果把 strings.xml 改了别的名字，这个功能就不 work 了。 Gradle 相关功能介绍 Gradle View 点击红色三角运行按钮，其实是执行了 Gradle 的 一些列任务，如果你想分别执行一些任务，则可以从 Gradle View 里面查看： gradle view 命令行 工作区下方，有一个叫做 Terminal 的 tab，点击之后，会自动 cd 到当前 project 根目录下，可以输入如下命令来尝试下： 1./gradlew build Windows 下应该是 gradlew.bat build，下面均以 Mac 为例，不再赘述 可使用 help 参数来查看有哪些选项： 1./gradlew --help 下面介绍一些重要的选项： * 查看运行 log 有些时候，一个任务运行失败，只给出一个错误，没有给具体原因，你就需要查看更多信息，可以使用参数 --info 或者 --stacktrace： 1./gradlew build --info 指定 module 或者 build.gradle Gradle 默认是当前目录下寻找 build.gradle 文件执行任务，这样执行 build 会使得整个 project 所有的 module 的 build 任务都会运行，浪费不必要的时间，可以指定 module (-p) 或者 build.gradle (-b)文件以缩小作用范围： 1./gradlew -p app build Sync 正常情况下，修改了 build.gradle 文件，文件上方就会有一个 sync 的按钮，点击之后会重新构建整个 build.gradle。但是某些特殊情况，这个同步可能会失败。那就需要一个额外的触发。 方法有四： * 再修改一下文件，便会再次出现 sync 按钮 * 点击上方工作区的按钮 * 点击 Gradle View 中的同步按钮 sync button top 命令行执行一次 build Build Variant 首先要了解两个概念: ### Build Type 分为 debug 和 release，这个概念容易懂 ### Product Flavor 这个概念主要是为了满足如下需求：同一份代码要打多个包，例如收费 pay 和免费 free，逻辑上有一些小区别，又不想通过逻辑判断这种丑陋的方式。或者你要实现所谓多渠道打包。 ### Build Variant = Build Type x Product Flavor 配置好了Build Type 和 Product Flavor 之后，Gradle 会生成若干个包，分别为： 1234payDebugpayReleasefreeDebugfreeRelease 配置实例 build variant 假设这两个版本的 app，有一个类 DiffBean 需要做大量的逻辑判断，则可以通过在 build.gradle 中配置 product flavor，在代码中添加两个与 main 平齐的文件夹， 把 DiffBean 从 main 中抽出来，分别放在两个文件夹中，只关注对应的逻辑即可。 关于 Product Flavor 中都能定义哪些属性，请参考 Android Gradle DSL。 Gradle 使用的仓库 要使用远程依赖，就得有个库的仓库，Gradle 支持 maven 仓库。这些库可以是公用的，例如 mavenCentral 或者 jcenter，也可以使用私有库。 笔者曾经上传过公用库到 mavenCentral 和 jcenter，前者的繁琐与难以管理，让人深恶痛绝。Android Studio 在0.8.0版本以后，将 jcenter 作为默认的 maven 库公用库来源。 私有库可以托管在任何一个能访问到的地方，可以托管在 bintray 上的私有空间，也可以是内网服务器上，甚至可以是本机磁盘上。 下面是本人使用的仓库的一个例子： 123456789allprojects { repositories { jcenter() mavenCentral() maven { url 'file:///Users/myusername/repo/' } }} 关于库，会在本系列的四篇会有更详细的叙述。 使用 jni 预编译 .so 库 默认情况下，可以放在与 java 平级的 jniLibs 文件夹中 1234567891011.├── AndroidManifest.xml├── java│&nbsp;&nbsp; └── io│&nbsp;&nbsp; └── kvh├── jniLibs│&nbsp;&nbsp; ├── armeabi│&nbsp;&nbsp; │&nbsp;&nbsp; └── libweibosdkcore.so│&nbsp;&nbsp; └── armeabi-v7a│&nbsp;&nbsp; └── libweibosdkcore.so└── res 很多人喜欢放在与 src 平级的 libs 文件夹中 12345678├── build.gradle├── libs│&nbsp;&nbsp; ├── armeabi│&nbsp;&nbsp; │&nbsp;&nbsp; └── libweibosdkcore.so│&nbsp;&nbsp; └── armeabi-v7a│&nbsp;&nbsp; └── libweibosdkcore.so├── proguard-rules.pro└── src 这样需要在 build.gradle 文件添加如下说明： 123456android { sourceSets { main { jniLibs.srcDirs = ['libs'] } } 升级 gradle 插件 在 bintray 上查找最新的版本 修改项目的 build.gradle 中插件的版本 12345678buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.0.0-alpha5'//这里 }} 如果有提示错误，则可能需要 gradle 的运行环境版本，修改项目根目录下文件 gradle/wrapper/gradle-wrapper.properties 中的 distributionUrl为最新，例如 1distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip 遇到的坑 笔者所在的项目的包已经发布到了 mavenCentral 和 jcenter，很多用户的在集成的时候，遇到问题，其中最经典的问题，便是下面的三个。 ## 下载依赖库失败，报 peer not found 连接 jcenter 库默认使用 https 协议，出现这个错，多数情况下都是因为连接失败了，原因嘛，你懂的。 可以尝试将 jcenter 改成默认使用 http 连接： 123jcenter { url \"http://jcenter.bintray.com/\" } 下载不到特定的版本 Maven 和 Gradle 都会有一个缓存库，默认安装的情况下，是在用户根目录下的 .m2 或者 .gradle 文件夹中。 可以尝试删除里面的文件。例如将 Gradle 的 cache 文件删除： 1rm -rf ~/.gradle/caches/ 注意这个操作可能会导致所有的远程库都需要重新下载，要三思后行。 库重复冲突 笔者的包使用了 com.android.support:support-v4:19.0.0 包，可能用户的 app 也使用了这个包，就可能在编译进行代码合并到时候出类似的错： 12UNEXPECTED TOP-LEVEL EXCEPTIONmultiple dex files define Landroid/support/annotation/AniRes 这个时候，在 module 的 build.gradle 的 dependency 添加依赖时，加入 exclude 规则： 123compile ('com.bugtags.library:bugtags-lib:latest.integration') { exclude group: 'com.android.support', module: 'support-v4'} 后续引言 讲到这里，有些读者可能会遇到跟我当时开始使用 Gradle 一样的问题：遇到问题就 stackoverflow，找到 workaround 了但不知道为什么，gradle 版本更新了，发现不 work 了，甚为惆怅。 究其原因，都是不理解基础。下面扼要勾勒个大概。 首先 Gradle 是一个构建平台，它使用的是 Groovy 语言。 Groovy是一种基于 Java 的语言，提供了更好的动态特性，可以使用闭包使得编程更灵活，很适合做脚本语言。 上面提到的 settings.gradle 和 build.gradle 在 Gradle 平台中，其实都是一个 Groovy 对象。 Gradle 通过插件（plugin）的方式来支持构建。插件是很多任务（task）的集合，task 中又包含了许多 action。 而例如 productFlavors 都是一个所谓的 DSL，插件都定义了很多的 DSL，我理解的所谓的 DSL 就是一个小语言规范用来处理一个特定的事情（大多情况下是配置）。Android 的插件的 DSL 文档在 Android Gradle DSL 有说明。 理解了以上基础之后，你就会知其然，知其所以然了。 以上知识，下一篇将会详细介绍。敬请留意。 本文所使用的 demo 已经上传到了 github 中，可以参阅 embrace-android-studio-demo 参考文献 Android Studio Overview Android Studio Installation Android Gradle DSL Android New Build System 系列导读 本文是笔者《拥抱 Android Studio》系列第二篇，其他篇请点击： 拥抱 Android Studio 之一：从 ADT 到 Android Studio 拥抱 Android Studio 之二：Android Studio 与 Gradle 深入 拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础 拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建 拥抱 Android Studio 之五：Gradle 插件使用与开发 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。 番外 笔者 kvh 在开发和运营 bugtags.com，这是一款能够极大的提升 app 开发者测试效率的 SDK 产品，欢迎使用、转发推荐。 笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。 我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭： bugtags","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"EmbraceAndroidStudio","slug":"EmbraceAndroidStudio","permalink":"https://kvh.io/tags/EmbraceAndroidStudio/"},{"name":"拥抱 Android Studio","slug":"拥抱-Android-Studio","permalink":"https://kvh.io/tags/拥抱-Android-Studio/"}]},{"title":"拥抱 Android Studio 之一：从 ADT 到 Android Studio","slug":"embrace-android-studio-migration","date":"2015-12-01T03:20:30.000Z","updated":"2021-01-13T01:42:18.824Z","comments":true,"path":"embrace-android-studio-migration.html","link":"","permalink":"https://kvh.io/embrace-android-studio-migration.html","excerpt":"","text":"拥抱变化，拥抱新事物 多年前央视有一套电视系列片：大国崛起，主要讲述那些曾经在站在世界舞台中央的国家的兴衰历程。纵观历史，正是创新使得一个国家得以崛起。 Android 开发因为涉及到代码编辑、UI 布局、打包等工序，最好使用一款 IDE。Google 最早提供了基于 Eclipse 的 ADT 作为开发工具，后于2013年 Google I/O 大会发布基于 IntelliJ IDEA 开发 Android Studio。后者正式版发布之后，Google 宣布不再持续支持 ADT。Android Studio 有更快的速度，更好的代码完成等特性。 时至今日（2015-11-30），在我们运营 bugtags.com 这一款高效的 app 测试服务的时候，在帮助用户集成 Android SDK 的过程中，我们发现很多遗留项目依旧没有从 ADT 迁移过来，依然有很多用户对 Android Studio 怀着恐惧与不信任。我想我们有义务去做一个系列介绍，让更多的人拥抱变化，拥抱新鲜事物。 本文系列一，主要介绍两个工具的比较及其迁移。 Android Studio（IntelliJ IDEA）vs. ADT（Eclipse） 本文并不打算涉及 IDE 的圣战，理论上只要配上插件，用得趁手，都差不多。然而本文也是带有倾向性的，因为工作原因，笔者使用过 Eclipse 多年，也使用过多款 JetBrains 的 IDE，均不辱 XXX 语言开发第一 IDE 之名。下面介绍一些 Android Studio 的优胜的地方。 更快的运行速度； 更智能的自动补全； &gt; 你不用自动补全？那其实你 ADT 也不需要的， vi 或者一个记事本就足够了； 更好的重构，IDEA 会帮你找到每一个需要重构的地方； 更好的索引与搜索，双击 shift 键搜索，文件搜索，代码搜索，都很方便； 更好的版本管理功能（git/SVN）； 更灵活强大集成脚本 gradle； 原生支持的从项目文件到操作系统的文件浏览器功能； &gt; ADT 可以通过插件支持？问题来了，我为啥要去花宝贵的时间折腾这个插件呢； …… 以上省略一万字。 相信我，对于 Android 开发者，切换到 Android Studio，经过短短学习曲线之后，你会爱上这个 IDE，并且即将由奢入俭难，再也回不去了。 从 ADT 迁移到 Android Studio 如果你看到上面的优点，已经克服了心中的怀疑和恐惧，准备动手迁移，下面提供一些迁移提示。 常用网站 部分需要科学上网 你无法科学上网？赶紧搜一下，自己搭或者买一个吧。世界如此多娇，人生苦短。将你遇到过问题的出错信息用 Google 搜索，第一条来自 stackoverflow 的答案就是你想要的。 Android Studio 下载页 Android Studio：Android Developer 上 Android Studio 的介绍 Android Tools：Android 工具首页，有大量的深度的技术文档 Android Build Sytem：基于 gradle 的 Android 构建系统，最为关键的一篇文章 从 ADT 迁移指南：官方提供的迁移手册 Android Studio 国内下载渠道：良心网站，你懂的，但是笔者不对 Xcode Ghost之类的事情负责 ADT 与 Android Studio 目录结构对比 ADT 项目结构 ADT 项目结构 project/src/：放置代码文件 project/libs：放置 .jar 库或者 .so 库 project/res：项目资源文件 project/AndroidManifest.xml：工程 manifest 文件 Android Studio 项目结构 Android Studio 项目结构 Android Studio 的一个 project (项目)下可以包含多个独立的 module（模块），图中 Bugtags-Android-Demo 便是一个项目，app 便是一个 module。结构如下。 project/build.gradle：项目的 build.gradle 文件，主要是全局的远程库配置、gradle 插件版本等信息 project/app：名字为 app 的模块 project/app/build.gradle：模块的 build.gradle 文件，是最关键的配置文件，后续会有文章继续专门介绍 project/app/src：源码文件夹 project/app/src/java：放置代码文件 project/app/src/jniLibs：默认的.so 库放置的位置，可以在模块的 build.gradle 中通过jniLibs.srcDirs 值来修改所在位置 project/app/libs：放置 .jar 库 从 ADT 迁移 本文主要参考这篇迁移指南。Android Studio 提供了非常友好的导入向导。 在 Android Studio 导入 File-&gt;New-&gt;Import Project，找到你的 ADT 的 workspace 下的项目，一路点击 YES，会生成一个全新的项目。 导入成功 问题 项目之间有依赖 直接导入使用依赖的项目，被依赖的项目就会自动被导入到同一个项目中，作为一个模块。 下文中的左侧是 ADT 项目，右侧是 Android Studio 项目。 其中 Bugtags-Android-Eclipse-Demo 使用 Bugtags-Android-Eclipse-Lib 作为依赖。 依赖 停留在界面上不动 错误 这个状态是 gradle 构建脚本尝试去下载 gradle 的 wrapper，这个 wrapper 大概 3M，需要科学上网，早期很多人就是在这个页面卡住，放弃了 Android Studio。确保你已经科学上网，并且耐心等待，又或者点击取消，先进项目看看。 Android Studio 的几个关键概念 如果上面没有问题，你已经能够正常的看到 Android Studio 的项目工程了。 IDE 使用、快捷键什么的，笔者认为没什么可写的。自己熟悉吧。下面介绍一个对于 ADT 而言全新的概念。 build.gradle 在项目的 build.gradle 文件中，有如下内容： 123456789101112131415// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript { repositories { jcenter()//这是构建插件所使用的远程库，后续会有一篇介绍库的含义 } dependencies { classpath 'com.android.tools.build:gradle:2.0.0-alpha1'//这是项目所使用的 Android gradle 版本 }}allprojects { repositories { jcenter()//这是使用远程库依赖的时候，的远程库 }} 在每个模块的 build.gradle 文件中，初始会有如下内容： 12345678910111213141516171819202122232425apply plugin: 'com.android.library'//com.android.library标示是一个库模块；//com.android.application标示这是一个应用模块android { compileSdkVersion 19//编译 sdk 版本 buildToolsVersion \"23.0.2\"//构建工具版本 defaultConfig { minSdkVersion 9 targetSdkVersion 19 } buildTypes {//打包类型 release { minifyEnabled false//是否混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' } }}dependencies {//依赖管理 compile 'com.bugtags.library:bugtags-lib:1.0.8'//远程 compile fileTree(dir: 'libs', include: ['*.jar'])//本地 jar 依赖} 依赖管理 远程依赖： 123dependencies { compile 'com.bugtags.library:bugtags-lib:1.0.8'} Android Studio 使用 gradle 进行依赖管理，兼容了 maven 的库，一个经典的 maven 库的配置如下： 12345&lt;dependency&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;com.bugtags.library&lt;/groupId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;bugtags-lib&lt;/artifactId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;1.0.8&lt;/version&gt;&lt;/dependency&gt; 对比之后，你会发现 compile 的内容中，分为三部分 groupdId:artifactId:version com.bugtags.library对应groupId bugtags-lib对应 artifactId 1.0.8对应 version 本地依赖 123dependencies { compile fileTree(dir: 'libs', include: ['*.jar'])//本地 jar 依赖} Android Studio 工程创建的时候，默认会有如上依赖，意义是把放在与该 build.gradle 文件同一层的 libs 文件夹中所有的 jar 文件都作为库依赖。 同步依赖 一般情况下，你配置完了build.gradle之后，该编辑框的上方会出现正在 sync 的标记。耐心等待完成即可。如果发现没有同步成功，可以使用下面这个按钮： sync 如果长时间未成功，则可以在控制台使用： 1./gradlew build --info 以上命令来看控制台输出。 build variant Android Studio 内置了多渠打包功能，就是所谓的 build variant，可以新建若干个 productflavor 来达到目的。 大致可以这样： flavors 这个功能十分的灵活和强大，举个例子，你想要有两个版本，一个收费版，一个免费版，在若干代码文件和资源文件上，都不大一样。 以前你可能选择在代码中判断当前版本，加载不同的代码和资源。或者使用 git 的 branch。 现在你可以使用 Android Studio 直接使用多个 productflavor， 在对应的 flavor 放置那些有区别的代码和文件。一次打包，即可完成。 在下一篇系列文章中，笔者将会详细介绍这个功能。 总结 新版本的 Android Studio 还有更多强大的功能，包括最新 preview 的 instant build，将会极大提升构建速度。后文将会详细介绍。 一个工程从 ADT 迁移到 Android Studio 只需要很短的时间，连带熟悉基本概念，半天基本可以完成。如果还没有进行迁移的同学，要抓紧了，不要被世界抛弃了。 笔者kvh先在这里挖一个系列坑，希望这个系列能够让读者快速掌握 Android Studio 与 gradle，请持续关注。 系列导读 本文是笔者《拥抱 Android Studio》系列第一篇，其他篇请点击： 拥抱 Android Studio 之一：从 ADT 到 Android Studio 拥抱 Android Studio 之二：Android Studio 与 Gradle 深入 拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础 拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建 拥抱 Android Studio 之五：Gradle 插件使用与开发 有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。 番外 笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。 笔者在开发和运营bugtags.com，这是一款能够极大的提升 app 开发者测试效率的 SDK 产品，欢迎使用、转发推荐。 我们团队长期求 PHP 后端，有兴趣请加下面公众号勾搭： bugtags","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"EmbraceAndroidStudio","slug":"EmbraceAndroidStudio","permalink":"https://kvh.io/tags/EmbraceAndroidStudio/"},{"name":"拥抱 Android Studio","slug":"拥抱-Android-Studio","permalink":"https://kvh.io/tags/拥抱-Android-Studio/"}]},{"title":"在  OSX 上安装使用 Supervisor","slug":"osx-supervisor","date":"2015-11-28T03:21:55.000Z","updated":"2021-01-13T01:42:18.825Z","comments":true,"path":"osx-supervisor.html","link":"","permalink":"https://kvh.io/osx-supervisor.html","excerpt":"","text":"OSX 作为 Server OSX 大部分情况都是用作个人电脑，少数情况下需要将其作为服务器使用。Bugtags 就有一些服务跑在 OSX 系统上。 遇到的一个问题：keep process alive！ 背景 OSX 作为 Server OSX 大部分情况都是用作个人电脑，少数情况下需要将其作为服务器使用。Bugtags 就有一些服务跑在 OSX 系统上。 ## Supervisor 管理后台进程 系统服务大多需要以后台进程的方式运行，开机自动运行，进程意外退出自动重启。有大量的教程讲述在 Linux 的各种发行版上安装和使用，本文主要关注 OSX 系统。废话少叙，直接上 bash 命令和遇到的坑。 ### 安装 python 12curl -O http://python-distribute.org/distribute_setup.pypython distribute_setup.py 安装pip 1sudo easy_install pip 安装 supervisor 1sudo pip install supervisor 配置文件 生成配置文件 1echo_supervisord_conf &gt; /etc/supervisord.conf 设置 include 12[include]files = /etc/supervisor/conf.d/*.conf 创建目录以及文件 12mkdir -p /etc/supervisor/conf.d/touch /etc/supervisor/conf.d/your_conf.conf 进程配置 12345678[program:your_programe]command=your_cmdstartsecs=0stopwaitsecs=0autostart=trueautorestart=truestdout_logfile=your_log_filestderr_logfile=your_error_file 管理 supervisord 需要使用sudo 运行 supervisord 与 supervisorctl 命令 检查是否正常运行 1ps ax|grep supervisor 管理 supervisord 1sudo supervisorctl -c /etc/supervisord.conf supervisorctl 常用命令 reread 不重启supervisiond 及其运行任务，读取新配置 status 当前运行状态 配置 OSX \b开机启动启动 保存如下xml为 1/Library/LaunchDaemons/your_package_name.plist 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;dict&gt; &lt;key&gt;SuccessfulExit&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;your_package_name&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/supervisord&lt;/string&gt; &lt;string&gt;-n&lt;/string&gt; &lt;string&gt;-c&lt;/string&gt; &lt;string&gt;/etc/supervisord.conf&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 注入命令 1sudo launchctl load /Library/LaunchDaemons/your_package_name.plist 注意 此处必须为 sudo，因为只有在 sudo 运行权限下，supervisord 与 supervisorctl 才可以正常使用 普通用户的 launchctl list和 sudo 用户的是不一样的 错误参考 应该先启动 supervisord，再使用 supervisorctl 管理， unix:///tmp/supervisor.sock 不存在，是因为 supervisord 没有正确启动 进入 supervisorctl 后报 python 错误，是因为没有使用 sudo 运行 参考文献 https://gist.github.com/fadhlirahim/78fefdfdf4b96d9ea9b8 https://nicksergeant.com/running-supervisor-on-os-x/ http://oldhammade.net/blog/2014/08/04/installing-supervisord-on-osx-mavericks.html http://blog.jackriver.im/run-supervisor-on-osx/","categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://kvh.io/tags/macOS/"},{"name":"后端","slug":"后端","permalink":"https://kvh.io/tags/后端/"}]},{"title":"面向开发者服务的用户体验","slug":"2d-ux","date":"2015-11-28T03:18:16.000Z","updated":"2021-01-13T01:42:18.817Z","comments":true,"path":"2d-ux.html","link":"","permalink":"https://kvh.io/2d-ux.html","excerpt":"","text":"面向开发者的产品，需要恰到好处的用户体验，就像锤子新品宣传的那样 &gt; 内敛和克制的，使用起来舒服和体贴 最近的工作是开发运营一项面向开发者的服务，而我们的团队是做社交产品出身。在关乎到用户体验的问题上，这里面仿佛存在一个矛盾。 开发者服务不需要用户体验？ 给程序员用的东西，要什么用户体验，功能可以work不就行了么？这是我们一开始的想法。当我们观察一些市面上的一些开发者服务的时候，我们发现，好和坏，真的不一样。举个例子，挑选国内两家数据统计服务提供商的界面进行对比一下： 腾讯分析 百度统计 单从界面上看，就可以明显看出腾讯果然是一家以产品能力见长的公司。 于是，我们有了第一层理解：开发者服务也是需要好的用户体验。 开发者服务应该极致用户体验？ 我们团队面向消费者的产品思维根深蒂固，产品经理往往会为一个按钮的大小和对齐纠结半天。极致体验，就是我们的口头禅。不干扰用户，让用户爽，就是我们的信条。于是我们系统最早的注册登陆，都不需要验证手机和邮箱——为了的让用户快速进入。 产品进入运营期，需要做用户回访和召回，问题来了，最早的用户都没有验证手机和邮箱啊。于是我们赶紧改版加了验证。 至此，我们突破了第二层理解：开发者服务，需要恰到好处的用户体验。 内部测试工具的用户体验 本人目前主要从事移动开发，客户端需要调用后端 RESTFUL API，后端开发的同事希望能够给他安装一个 demo app，有完整的功能，要能够跑跑关键点API的TEST，最好还能切换“开发|测试|上线”三级环境，方便调试。于是我开发了一个测试工具。 主界面 切换环境 主要实现了如下的功能： 切换环境，倒数三秒后 kill app，重新打开后进入对应环境，并记住当前环境设置 修改对应环境的 appkey 常用的 TEST CASE 功能不多，但是后端同事觉得就足够用了。 官网、文档、反馈渠道 我们尝试去做推广，用户点广告过来之后，就考验我们转化率了。官网是否能够准确传达产品的理念和特点，开发文档是否足够的简明易懂，遇到问题是否能够找到最快速的途径进行反馈，这些都关乎用户体验。 这里我就说说Android平台集成文档。Android平台上有两大主流的开发工具，Eclipse 和 Android Studio，前者是 Google 最早提供的开发工具，后者是基于 \bIntelliJ Idea 新开发的，有较多新的特性，用起来也比较方便，缺点是还不是非常成熟，偶尔有 bug 。 我个人从 Android Studio 还是 alpha 的时候就从 Eclipse 迁移过来了，用的也比较熟。在写集成文档的时候，我想当然的侧重 Android Studio 的用户集成，没过多考虑 Eclipse 的文档，只是随便写写。 用户逐渐上来了，百分之七十都在问 Eclipse 的问题啊。于是我赶紧做了修改： 精简依赖包 降低 demo app 的 api level，降低用户使用成本 精简回调函数 反复调整集成文档，关键点加上注释 做了这些修改后，关于集成的反馈才渐渐少了，在可预见的未来，我还将在易用性上做更多的工作。 总结 面向开发者的产品，需要恰到好处的用户体验，就像锤子新品宣传的那样 &gt; 内敛和克制的，使用起来舒服和体贴 我们还将持续改善用户体验，力求开发者用的顺畅，用的舒服。","categories":[{"name":"product","slug":"product","permalink":"https://kvh.io/categories/product/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://kvh.io/tags/产品/"},{"name":"用户体验","slug":"用户体验","permalink":"https://kvh.io/tags/用户体验/"}]},{"title":"关于 KVH","slug":"about","date":"2015-11-28T03:18:16.000Z","updated":"2021-01-13T01:42:18.818Z","comments":true,"path":"about.html","link":"","permalink":"https://kvh.io/about.html","excerpt":"","text":"关于我 博主近年常用昵称「kvh」，是一名生活在北京的互联网从业者。从研究生毕业之后，基本上是在从事互联网产品研发，曾涉猎过社交、教育、SaaS、游戏、区块链等领域。 目前主要是关注互联网技术构架，对于对共识协议、P2P 系统有一定的研究。 博主对面向开发者的产品有着浓厚的兴趣，同时也是在线教育产品的使用者和倡导者。 业余时间，博主是一位特斯拉车主和Elon Musk的粉丝，维护了「特香」公众号、车友群。 联系我 欢迎关注我的微信公众号「KVHTalk」、 github 与微博。","categories":[{"name":"personal","slug":"personal","permalink":"https://kvh.io/categories/personal/"}],"tags":[{"name":"个人","slug":"个人","permalink":"https://kvh.io/tags/个人/"}]}],"categories":[{"name":"code","slug":"code","permalink":"https://kvh.io/categories/code/"},{"name":"blockchain","slug":"blockchain","permalink":"https://kvh.io/categories/blockchain/"},{"name":"reading","slug":"reading","permalink":"https://kvh.io/categories/reading/"},{"name":"product","slug":"product","permalink":"https://kvh.io/categories/product/"},{"name":"personal","slug":"personal","permalink":"https://kvh.io/categories/personal/"}],"tags":[{"name":"zkp","slug":"zkp","permalink":"https://kvh.io/tags/zkp/"},{"name":"wallet","slug":"wallet","permalink":"https://kvh.io/tags/wallet/"},{"name":"defi","slug":"defi","permalink":"https://kvh.io/tags/defi/"},{"name":"education","slug":"education","permalink":"https://kvh.io/tags/education/"},{"name":"blockchain","slug":"blockchain","permalink":"https://kvh.io/tags/blockchain/"},{"name":"DeFi","slug":"DeFi","permalink":"https://kvh.io/tags/DeFi/"},{"name":"社会心理学","slug":"社会心理学","permalink":"https://kvh.io/tags/社会心理学/"},{"name":"macOS","slug":"macOS","permalink":"https://kvh.io/tags/macOS/"},{"name":"Spring","slug":"Spring","permalink":"https://kvh.io/tags/Spring/"},{"name":"产品","slug":"产品","permalink":"https://kvh.io/tags/产品/"},{"name":"用户体验","slug":"用户体验","permalink":"https://kvh.io/tags/用户体验/"},{"name":"SDK","slug":"SDK","permalink":"https://kvh.io/tags/SDK/"},{"name":"Android","slug":"Android","permalink":"https://kvh.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://kvh.io/tags/Gradle/"},{"name":"Gradle 技巧","slug":"Gradle-技巧","permalink":"https://kvh.io/tags/Gradle-技巧/"},{"name":"EmbraceAndroidStudio","slug":"EmbraceAndroidStudio","permalink":"https://kvh.io/tags/EmbraceAndroidStudio/"},{"name":"拥抱 Android Studio","slug":"拥抱-Android-Studio","permalink":"https://kvh.io/tags/拥抱-Android-Studio/"},{"name":"程序员必读","slug":"程序员必读","permalink":"https://kvh.io/tags/程序员必读/"},{"name":"后端","slug":"后端","permalink":"https://kvh.io/tags/后端/"},{"name":"个人","slug":"个人","permalink":"https://kvh.io/tags/个人/"}]}