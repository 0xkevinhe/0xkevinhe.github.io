<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin He&#39;s Website | e/acc</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0xkevinhe.xyz/"/>
  <updated>2023-12-11T08:51:59.016Z</updated>
  <id>https://0xkevinhe.xyz/</id>
  
  <author>
    <name>0xkevinhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>比特币生态-Overview</title>
    <link href="https://0xkevinhe.xyz/bitcoin-ecosystem-overviews.html"/>
    <id>https://0xkevinhe.xyz/bitcoin-ecosystem-overviews.html</id>
    <published>2023-12-11T03:18:16.000Z</published>
    <updated>2023-12-11T08:51:59.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>站在 2023 的年末回望，比特币生态的异军突起绝对可以算上 Crypto 编年史的一部分。</p><p>从上半年兴起的铭文概念到下半年冒出来的大量比特币 Layer2，可谓百花齐放，百家争鸣。</p><p>面对日新月异的比特币生态项目和相关技术，很多朋友（包括笔者）都经历了：看不见–看不起–看不懂–追不上的过程。</p><p>本系列研报，旨在剥开项目表层概念，从技术本质出发，给出这一波繁荣的来龙去脉，进而从技术维度为这些项目划分框架。期望通过信息掌握和框架建立，读者在遇到新项目时能够从技术上快速分析和判断。</p><h1 id="新从何来"><a href="#新从何来" class="headerlink" title="新从何来"></a>新从何来</h1><p>对于比特币扩容的话题读者相信都是耳熟能详了，这里不再赘述，有兴趣可以<a href="https://en.wikipedia.org/wiki/Bitcoin_scalability_problem">自行检索</a>补齐背景知识。</p><p>从整体生态的发展规律来看，首先会出现资产发行的协议，人们会利用发行协议发行大量资产，进而产生应用（兑换/借贷/支付等），大量的应用汇聚起来将会形成一个繁荣的 Layer2。</p><p>因此，资产（协议/案例）/ Layer2（协议/应用）将是笔者做分析的核心主线，其中<strong>资产协议</strong>和 <strong>Layer2 协议</strong>是重点。</p><p>在比特币生态发展的这么多年里面，在各类经典书籍和权威分析文章中提及的比特币生态基本可以归纳为下图:<img src="/./bitcoin-ecosystem-overviews/Bitcoin-Ecosystem-Original.png" alt="Bitcoin-Ecosystem-Classic"></p><p>比特币生态的发展日新月异，上述内容已无法涵盖最新发展。然而万事皆有因，作者总结如下。</p><h2 id="新动力何在"><a href="#新动力何在" class="headerlink" title="新动力何在"></a>新动力何在</h2><ul><li>内因</li></ul><p>经济动力：</p><ol><li>BTC 作为一种有价值易流通的资产，自然应该具有金融属性，但是由于种种原因，BTC@DeFi 比例很低，BTC 持有者有参与 DeFi 的诉求。</li><li>2024 年比特币将进入减半周期，矿工的 coinbase 收入将会降低，矿工群体有通过更繁荣的生态获得更多收入的诉求。</li></ol><p>技术动力：</p><ol><li>比特币的最近两次重大升级（SegWit 和 Taproot）结合在一起，使得比特币链上本身的处理能力和链下表达空间更大，这也推动了新的资产和新的 Layer2 出现。</li><li>客户端验证等技术观念的普及带来了新的方向。</li></ol><ul><li>外因</li></ul><ol><li>以太坊生态在 DeFi summer 中的繁荣表现和在 Layer2上的实践，客观影响着其它公链的发展。</li><li>模块化区块链观念（DA 等）和零知识证明技术的落地，为比特币扩容带来了新的思路。</li></ol><p>受到上述动力的驱使，我们可以将上面框架内容更新到最新版本。</p><h1 id="分类概述-DEC-2023"><a href="#分类概述-DEC-2023" class="headerlink" title="分类概述[DEC. 2023]"></a>分类概述[DEC. 2023]</h1><p><img src="/./bitcoin-ecosystem-overviews/Bitcoin-Ecosystem-New.png" alt="Bitcoin-Ecosystem-New"></p><p>在本篇中，作者会尝试知识范畴之内，为每一个子分类以及协议做一些技术概述。后续如果有时间，会再对重点具体的协议做技术分析。</p><h2 id="资产协议"><a href="#资产协议" class="headerlink" title="资产协议"></a>资产协议</h2><p>比特币白皮书定义是一种 P2P 支付系统，因此它采用了类似<strong>现金支付和找零</strong>的UTXO 模型。</p><p><img src="/./bitcoin-ecosystem-overviews/Bitcoin-TX.png" alt="Bitcoin-TX"></p><p>在这笔交易中，Alice 要支付给 Bob 1 BTC。Alice构造交易：输入为 Alice 控制的 10 BTC 的UTXO，输出为 Bob 1 BTC 和找零 8.99 BTC，剩余 0.01 BTC 是交易费。</p><p>其中输出的 UTXO 可以附带一些额外的信息，例如曾经有人把<a href="https://blockstream.info/tx/e81f708ca09fc93337c3950158c4a4f8a9bcf57176fcee6e2869bc6ac4dc5db5">结婚信息</a>登记到比特币链上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_RETURN</span><br><span class="line">0.00000000 BTC</span><br><span class="line">TYPEOP_RETURN</span><br><span class="line">SCRIPTPUBKEY (ASM)OP_RETURN OP_PUSHBYTES_27 416c657820616e6420446172696120676f74206d61727269656421</span><br><span class="line">SCRIPTPUBKEY (HEX)6a1b416c657820616e6420446172696120676f74206d61727269656421</span><br><span class="line">OP_RETURN DATAAlex and Daria got married!</span><br></pre></td></tr></table></figure><p>随着比特币的升级，UTXO 中附带信息的方式也有多种，常见的是 OP_RETURE，SegWit，Taproot 等。</p><p>比特币网络的代码共识只认可 BTC 这一种资产。如果想要借助比特币发行其它的资产，目前大家想到的办法是 UTXO 中添加信息，然后在<strong>链下</strong>通过一个程序来解析 UTXO 中的额外信息。</p><p>一个例子是，在美元纸币至上建立一个「珍稀」美元收藏协议，描述如下：</p><p><img src="/./bitcoin-ecosystem-overviews/us-dollar.jpeg" alt="us-dollor-collection"></p><p>以美元编号展开叙事，建立如下 Rare-USD 协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">B__03__54__27__54__F</span><br><span class="line">||</span><br><span class="line">H__C1__C2__C3__C4__T</span><br><span class="line"></span><br><span class="line">设定 C1, C2, C3, C4 带有数字 8 的数量越多，珍稀度越高。</span><br><span class="line">这个协议的典型的操作有：铸造/转移。其中铸造是在这个纸币上面做一些特殊标记（可能会有法律问题，只是一个简单例子）。</span><br></pre></td></tr></table></figure><p>可以看到，Rare-USD 协议的一些特质：</p><ol><li>Layer1（美联储） 不感知这个收藏协议的存在</li><li>在链下（藏家）形成共识，需要有一个索引（共识）系统来保证其正常运作</li></ol><p>上面的框架中的资产协议 Rare-USD 协议没有本质区别，与模块化区块链中的 DA（数据可用层）分离也有千丝万缕的关系。</p><p>其中 client-side-verification 是一种更官方的说法，inscription 则是社区自发形成的一种称谓。</p><h2 id="Layer2-协议"><a href="#Layer2-协议" class="headerlink" title="Layer2 协议"></a>Layer2 协议</h2><p>有了资产协议和相应的资产实例，Layer2 才有存在的价值。</p><h2 id="核心的三个问题"><a href="#核心的三个问题" class="headerlink" title="核心的三个问题"></a>核心的三个问题</h2><p>作者认为，BTC 的 Layer2 核心要回答三个问题：</p><ul><li>资产</li></ul><p>资产是否丰富，是否能实现去中心化跨链，是否有逃生能力。</p><ul><li>执行</li></ul><p>Layer2 的状态转移，是否具备图灵完备的虚拟机，用户和开发者是否友好。</p><ul><li>验证</li></ul><p>Layer2 的执行状态，如何自证清白，验证成本多高等。</p><h2 id="Layer2-分析框架"><a href="#Layer2-分析框架" class="headerlink" title="Layer2 分析框架"></a>Layer2 分析框架</h2><p>本文为Layer2 协议建立如下分析框架，例如：</p><table><thead><tr><th align="left"><strong>项目</strong></th><th align="left">技术路线</th><th align="left"><strong>资产安全跨链</strong></th><th><strong>资产逃生</strong></th><th><strong>图灵完备</strong></th><th align="left"><strong>L1验证状态</strong></th></tr></thead><tbody><tr><td align="left">Lighting Network</td><td align="left">State Channel</td><td align="left">YES</td><td>YES</td><td>NO</td><td align="left">YES</td></tr><tr><td align="left">Stacks</td><td align="left">Side Chain</td><td align="left">-</td><td>NO</td><td>YES</td><td align="left">NO</td></tr></tbody></table><p>特别值得注意的是 Rollup 类型的 Layer2 出现是亮点。Rollup 严格意义上包含 validity 和 sovereign 两种，前者可以实现链上验证。</p><p><strong>BitVM</strong> 作为一个有可能实现 validity rollup 的技术方案，将有望真正打开比特币 Layer2 的新篇章。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章阐述了回顾了比特币生态的历史和创新发展的驱动力，从资产/Layer2 协议两个大类出发，尝试为读者建立比特币生态的分析框架。</p><p>无论是资产还是 Layer2 协议，理解技术本质最好的办法就是看它们与比特币一层的交互方式，更具体来讲就是UTXO 中 input 和 output 的构造。后续将撰文从比特币交易角度分析生态协议。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/">https://www.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/</a><br><a href="https://bitvm.org/bitvm.pdf">https://bitvm.org/bitvm.pdf</a><br><a href="https://rgb.tech/">https://rgb.tech/</a><br><a href="https://www.drivechain.info/">https://www.drivechain.info/</a><br><a href="https://www.dlc.link/">https://www.dlc.link/</a><br><a href="https://domo-2.gitbook.io/brc-20-experiment/">https://domo-2.gitbook.io/brc-20-experiment/</a><br><a href="https://research.web3caff.com/zh/archives/6501?ref=1&ref=200">https://research.web3caff.com/zh/archives/6501?ref=1&ref=200</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;站在 2023 的年末回望，比特币生态的异军突起绝对可以算上 Crypto 编年史的一部分。&lt;/p&gt;
&lt;p&gt;从上半年兴起的铭文概念到下半年冒
      
    
    </summary>
    
      <category term="web3" scheme="https://0xkevinhe.xyz/categories/web3/"/>
    
    
      <category term="bitcoin" scheme="https://0xkevinhe.xyz/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>blockchain-governance</title>
    <link href="https://0xkevinhe.xyz/blockchain-governance.html"/>
    <id>https://0xkevinhe.xyz/blockchain-governance.html</id>
    <published>2022-10-07T00:47:42.000Z</published>
    <updated>2023-09-27T07:37:55.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>BNB Chain 因为官桥被黑，停止工作。</p><ul><li><p>事件官方 Twitter<br><a href="https://twitter.com/BNBCHAIN/status/1578148078636650496">https://twitter.com/BNBCHAIN/status/1578148078636650496</a></p></li><li><p>社区跟踪<br><a href="https://twitter.com/samczsun/thread/1578182840751050752">https://twitter.com/samczsun/thread/1578182840751050752</a></p></li></ul><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>去中心化和治理的边界在哪里</p><p>社会共识是什么</p><p>治理的边界在哪里</p><p>是否应该治理</p><p>以什么程序启动治理</p><p>有没有预设方案来更好的治理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;BNB Chain 因为官桥被黑，停止工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事件官方 Twitter&lt;br&gt;&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>web3-nft-overviews</title>
    <link href="https://0xkevinhe.xyz/web3-nft-overviews.html"/>
    <id>https://0xkevinhe.xyz/web3-nft-overviews.html</id>
    <published>2022-07-05T15:07:14.000Z</published>
    <updated>2023-09-27T07:01:22.200Z</updated>
    
    <content type="html"><![CDATA[<p>Last month, we did a small-scale web3 and NFT sharing offline, and the audience was a group of Tesla owners.</p><p>Considering that most of the audience are non-crypto users, the content of the sharing will focus on the overview level, introducing concepts and specific cases, but also involving some personal practical work experience and insights.</p><p>Admittedly, these two topics are still sensitive words in China, so I don’t expect the audience to fully accept my insights, but I do ask them to keep an open mind and be willing to learn about some content that is offensive to the mainstream media.</p><p>Finally, a word to all bystanders: when the bubble rises, some people choose to be a wise onlooker, others choose to experience it, and when the bubble dissipates, the wise reap the wisdom, and the pro-lifers reap the experience or wealth.</p><p><a href="https://raw.githubusercontent.com/changbinhe/images/master/static/Web3%26NFT-overviews.pdf">PDF</a></p><p>================================================================================================</p><p>上月在线下做了一场小规模的web3和NFT的分享，受众是一个兴趣群的群友。</p><p>考虑到大部分听众都是非链圈或者币圈用户，分享内容会集中在overview层次，介绍概念和具体的case为主，也会涉及到一些个人的实际工作体会和行业判断。</p><p>诚然，这两个话题在国内依然处于准敏感词的状态，我也不强求听众能够完全接受我的见解，但求大家保持一颗开放的心，愿意去了解一些主流媒体所不齿的内容。</p><p>最后，给所有的旁观者一句话，当泡沫起来的时候，有的人选择做一个旁观的智者，另外一些人选择亲身去体验和深入，当泡沫散去，智者收获了智慧，亲历者收获了体验或者财富。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Last month, we did a small-scale web3 and NFT sharing offline, and the audience was a group of Tesla owners.&lt;/p&gt;
&lt;p&gt;Considering that most
      
    
    </summary>
    
      <category term="web3" scheme="https://0xkevinhe.xyz/categories/web3/"/>
    
    
      <category term="nft" scheme="https://0xkevinhe.xyz/tags/nft/"/>
    
  </entry>
  
  <entry>
    <title>zksync 存储：sparse-merkle-tree 存储</title>
    <link href="https://0xkevinhe.xyz/sparse-merkle-tree.html"/>
    <id>https://0xkevinhe.xyz/sparse-merkle-tree.html</id>
    <published>2021-02-09T12:02:00.000Z</published>
    <updated>2023-09-27T07:01:22.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。</p><h1 id="merkle-tree"><a href="#merkle-tree" class="headerlink" title="merkle tree"></a>merkle tree</h1><p><a href="https://en.wikipedia.org/wiki/Merkle_tree">merkle tree</a> 常用于区块链存储数据和快速校验数据。其构造特点是叶节点使用数据的 hash 进行标记，中间节点使用所有子节点的 hash进行标记。</p><p><img src="/./sparse-merkle-tree/merkle-tree.png" alt="merkle-tree"></p><p>对于 merke tree 的操作，包含：插入节点、获取树根、计算 merkle 证明、检验 merkle 证明。</p><p>计算 merkle 证明包含：</p><p>1）计算存在证明</p><p>2）计算不存在证明</p><p>在原始的 merkle tree 上，很容易生成存在性证明，但是难以生成不存在证明。</p><h1 id="sparse-merkle-tree"><a href="#sparse-merkle-tree" class="headerlink" title="sparse merkle tree"></a>sparse merkle tree</h1><p>为了解决这个问题，同时零知识证明也要求账号在树上的位置具有确定性，因此引入 sparse merkle tree，有如下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一棵满二叉树</span><br><span class="line">数据是索引的，每个数据会放到对应的索引的叶子上</span><br><span class="line">存在性证明，merkle path</span><br><span class="line">不存在性证明，需要证明是 null</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>1）预计算空值哈希</p><p>由于大部分情况下，树并不会真的满，而是非常的稀疏。可以预计算H(null)、H(H(null)|H(null))、H(H(H(null)|H(null))|H(H(null)|H(null)))等层级上的值，达到加速的效果。</p><p>2）并行计算左右子树哈希</p><p>H(H(left)|H(right)) 这类操作要求 快速计算左右子树的哈希值，并行计算可以计算。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><a href="https://github.com/matter-labs/zksync/blob/master/core/lib/crypto/src/merkle_tree/parallel_smt.rs">rust-matter-labs</a></p><p><a href="https://github.com/iden3/iden3js/blob/master/src/sparse-merkle-tree/sparse-merkle-tree.js">js-iden3</a></p><p><a href="https://github.com/iden3/go-iden3-core/blob/master/merkletree/merkletree.go">golang-iden3</a></p><h1 id="文献参考"><a href="#文献参考" class="headerlink" title="文献参考"></a>文献参考</h1><p><a href="https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837">whats-a-sparse-merkle-tree</a></p><p><a href="https://blog.iden3.io/sparse-merkle-trees-visual-introduction.html">sparse-merkle-trees-visual-introduction</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。&lt;/p&gt;
&lt;h1 id=&quot;merkle-tree
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="zkp" scheme="https://0xkevinhe.xyz/tags/zkp/"/>
    
  </entry>
  
  <entry>
    <title>关于智能钱包</title>
    <link href="https://0xkevinhe.xyz/smart-wallet.html"/>
    <id>https://0xkevinhe.xyz/smart-wallet.html</id>
    <published>2021-01-13T01:58:57.000Z</published>
    <updated>2023-09-27T07:01:22.192Z</updated>
    
    <content type="html"><![CDATA[<p>Vitalik 在 1-11 在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。</p><p>原文不赘述，下文将主要记录要点和思考。</p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://vitalik.ca/general/2021/01/11/recovery.html">英文</a></p><p><a href="https://www.chainnews.com/articles/195564221840.htm">中文</a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="guardian-的选择"><a href="#guardian-的选择" class="headerlink" title="guardian 的选择"></a>guardian 的选择</h2><p>抵抗 guardian 联合作恶：</p><p>1）不公开</p><ul><li>对 list 进行哈希</li></ul><blockquote><p>fulllist，如何获得？</p></blockquote><ul><li>guardian 确定性的生成一个用于恢复的地址；只在需要恢复的时候用到一次；</li></ul><p>2）来自不同的 social circle</p><h2 id="对于加密价值的讨论"><a href="#对于加密价值的讨论" class="headerlink" title="对于加密价值的讨论"></a>对于加密价值的讨论</h2><p>有一种论调认为，社交恢复，是恢复到了相信人，是对区块链和加密的背叛。</p><p>Vitalik 认为，加密不是移除所有的信任，其目的是提供更多的选择，来决定去相信谁；允许可控的信任：容许某些人代替做某些事，而没有能力做所有事。</p><h2 id="对抗小偷"><a href="#对抗小偷" class="headerlink" title="对抗小偷"></a>对抗小偷</h2><p>sign key 可能丢失，可以增加一个保险柜功能，把 token 进入其中；在保险柜中的 token，交易可消。在发起交易和交易生效中间，增加了一个可撤回的缓冲期；还可以通过增加 vault 的可编程性支持更多的功能。</p><h2 id="Argent-和路印等现行社交钱包的两大挑战"><a href="#Argent-和路印等现行社交钱包的两大挑战" class="headerlink" title="Argent 和路印等现行社交钱包的两大挑战"></a>Argent 和路印等现行社交钱包的两大挑战</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）对中继的依赖</span><br><span class="line">2）交易费高</span><br></pre></td></tr></table></figure><p>目前的流行做法，是中继官方的签名的在链下进行，收集之后打包发送到服务器；</p><blockquote><p>对于这里的「收集」的概念有一定疑问；<br>假设一个用户有 7 个guardian，路印是收集齐了4 个guardian的签名，才发送到链上？</p></blockquote><h2 id="两大挑战的解决方案："><a href="#两大挑战的解决方案：" class="headerlink" title="两大挑战的解决方案："></a>两大挑战的解决方案：</h2><ul><li>当前改造方式</li></ul><p><a href="https://docs.opengsn.org/learn.html">generalized decentralized relayer network</a></p><blockquote><p>以太坊加油站（与 heco 的元交易有异曲同工之处）</p></blockquote><p><a href="https://our.status.im/account-abstraction-eip-2938/">allow transactions to begin from contracts</a></p><blockquote><p>修改以太坊协议，允许合约主动发起交易。</p></blockquote><ul><li>彻底改造方式：迁移到 layer2</li></ul><blockquote><p>为什么能解决问题？资金首先来自 1 层？在二层里面实现智能钱包逻辑？</p></blockquote><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li><p>如果是一个定制的链的场景，可以采用更激进的方式来改造链，是否可以定制一个对用户友好的钱包系统？</p></li><li><p>思考免费钱包或者网络可能性，可以使用<a href="https://docs.hecochain.com/#/en-us/dev/meta_tx">原生元交易</a>，对交易费进行补贴。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>钱包本身存在易用性和安全性的矛盾。公私钥、备份助记词这种操作，对于习惯了只记录一个 pin 的 web2.0 用户而言不友好，这可能也是阻碍区块链向更大量的用户普及的一部分原因。</p><p>支持社交恢复的智能钱包，免去了用户记录助记词的困难，将安全性托付于社交关系，易用性上有了提升，但是也存在一些问题。Vitalik 难得之处在于，不止提出问题，还提供了解决方案的思考。</p><p>当前以太坊社区，开始逐步理解和使用 layer2，将 layer2 和智能钱包结合，将有利于以太坊网络向更大体量的用户推广。</p><p>欢迎留言或者联系博主对相关问题讨论！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vitalik 在 1-11 在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。&lt;/p&gt;
&lt;p&gt;原文不赘述，下文将主要记录要点和思考。&lt;/p&gt;
&lt;h1 id=&quot;原文&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="wallet" scheme="https://0xkevinhe.xyz/tags/wallet/"/>
    
  </entry>
  
  <entry>
    <title>0x协议-介绍</title>
    <link href="https://0xkevinhe.xyz/0x-intro.html"/>
    <id>https://0xkevinhe.xyz/0x-intro.html</id>
    <published>2021-01-01T02:49:05.000Z</published>
    <updated>2023-09-27T07:01:22.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>链下撮合（订单簿在链下）、链上结算（资金划转）</p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>maker 挂单者</p><p>taker 吃单者</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>maker 创建订单信息，签名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">makerAddress</span><br><span class="line">takerAddress</span><br><span class="line">makerAssetData</span><br><span class="line">takerAssetData</span><br><span class="line">makerAssetAmount</span><br><span class="line">takerAssetAmount</span><br><span class="line">expirationTimeSeconds</span><br><span class="line">fee</span><br><span class="line">...</span><br><span class="line">签名</span><br><span class="line">哈希</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：</p></blockquote><p>takerAddress 是空——直到taker接单</p><ul><li><p>relayer 链下撮合<br>taker 接受 maker 的订单，签名，提交到智能合约</p></li><li><p>链上结算<br>合约实现资金划转</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>1）maker 如何取消交易</p><p>订单过期</p><p>2）交易效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">预先检查</span><br><span class="line">链上成交</span><br></pre></td></tr></table></figure><h1 id="与-uniswap-对比"><a href="#与-uniswap-对比" class="headerlink" title="与 uniswap 对比"></a>与 uniswap 对比</h1><p>1）uni 有流动性提供者，一个 pair 的两个 token 都需要提供</p><p>2）uni 的价格是链上发现的</p><p>3）0x 只是交易意愿撮合，用户的资产不需要抵押</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>0x 协议核心是定义了一个「链下撮合，链下成交」的结构，但正式由于分离了链上和链下，其成交效率有一定折扣。</p><p>其后继者 uniswap 是一个整体闭环。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://0x.org/docs/core-concepts">0x-protocol</a></p><p><a href="https://www.jinse.com/blockchain/247474.html">0x-intro-jnse</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h1&gt;&lt;p&gt;链下撮合（订单簿在链下）、链上结算（资金划转）&lt;/p&gt;
&lt;h1 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="defi" scheme="https://0xkevinhe.xyz/tags/defi/"/>
    
  </entry>
  
  <entry>
    <title>《你就是孩子最好的玩具》读书笔记</title>
    <link href="https://0xkevinhe.xyz/reading-emotion-coaching.html"/>
    <id>https://0xkevinhe.xyz/reading-emotion-coaching.html</id>
    <published>2020-10-05T10:05:12.000Z</published>
    <updated>2023-09-27T07:01:22.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。</p><p>人生来就是一张白纸，父母是第一位老师，家庭教育对于塑造一个人的品格，有关键作用。</p><p>在教育这个事情上，说实话，也是战战兢兢，一不留神，就可能把原先的不那么正确的观念带给了孩子。</p><p>这个时候，不能盲目，不能下意识，只能多阅读、多思考、多观察、多实践，或许能减少一些内心的焦虑。</p><p>这是一本儿童教育的书，核心观点是对孩子进行情感引导式教育。作者摒弃了控制式、放任式、奖励式、惩罚式的教育。等等，这都是不对的？感觉颠覆了三观。细读下来，发现奖励和惩罚还是会在，不过占主导的是发挥同理心，进行情感引导和沟通。</p><p>这本书又是一本手册类的书，列举儿童 0-7 岁能出现的大部分让家长抓狂的情形再现、原因分析和解决方案，是值得多次翻阅和查找的一本书。</p><h1 id="🏷信息卡片"><a href="#🏷信息卡片" class="headerlink" title="🏷信息卡片"></a>🏷信息卡片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">名称：《你就是孩子最好的玩具》</span><br><span class="line">作者: 金伯莉·布雷恩</span><br><span class="line">译者: 夏欣茁</span><br><span class="line">出版年: 2011-8</span><br><span class="line">页数: 191</span><br><span class="line">定价: 29.80元</span><br><span class="line">ISBN: 9787550102996</span><br><span class="line">豆瓣评分：       8.2</span><br><span class="line">起止时间：       2020.10.05--2020.10.05</span><br><span class="line">阅读次数：       1</span><br><span class="line">推荐指数：      🌟🌟🌟🌟</span><br><span class="line">获奖情况：     </span><br></pre></td></tr></table></figure><h1 id="🌱写作背景"><a href="#🌱写作背景" class="headerlink" title="🌱写作背景"></a>🌱写作背景</h1><p>作者是儿童教育专家，最早提出「情感引导式教育」概念，同时也是 2 个男孩的母亲。</p><h1 id="📒原著呈现"><a href="#📒原著呈现" class="headerlink" title="📒原著呈现"></a>📒原著呈现</h1><p>p9 你是希望孩子处于对你的恐惧而听从你的建议，还是处于对你的爱戴和尊重而听从你的建议呢？<br>p149 我们唯有甘心忍耐，才可能从刻意逃避转为欣然面对</p><h1 id="🖇书摘-批注"><a href="#🖇书摘-批注" class="headerlink" title="🖇书摘&批注"></a>🖇书摘&批注</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">p3 情感引导是什么：想孩子传授情感规则，让他们知道如何辨认情感并且以恰当的方式来表达。</span><br><span class="line">懂得辨认和他人的情感，是形成和谐的人际关系的关键。</span><br><span class="line"></span><br><span class="line">p6 常见误区：</span><br><span class="line">1）控制和放任型</span><br><span class="line">2）轻视、低估和否定孩子的感受 </span><br><span class="line">3）采用外部激励和奖赏的手段 </span><br><span class="line">4）以消极后果作为惩罚</span><br><span class="line">小朋友没有去权利生气？不是的，小朋友要学会知道自己是否在生气，为什么生气，如何处理情绪。</span><br><span class="line"></span><br><span class="line">p33 同情的力量</span><br><span class="line">所谓同理心——站在别人角度看问题；对待小朋友，也需要如此。</span><br><span class="line"></span><br><span class="line">p38 情感引导的关键步骤：</span><br><span class="line">1）播下种子——提前预告</span><br><span class="line">2）观察和判断——了解孩子的情况</span><br><span class="line">3）聆听——倾听孩子的感受</span><br><span class="line">4）体察和同情</span><br><span class="line">期前预告接下来要发生的事情，以一种协商的姿态告知孩子，争取他的配合。</span><br><span class="line"></span><br><span class="line">p56 安抚毯、毛绒玩具</span><br><span class="line">作者提到她的孩子对于安抚毯有强烈的依赖。</span><br><span class="line"></span><br><span class="line">p62 不眠之夜</span><br><span class="line">在某些转折点之前，可能会折腾一阵子——例如突然开始说话之前</span><br><span class="line"></span><br><span class="line">p63 带婴儿外出</span><br><span class="line">做好心理建设最重要——孩子不大可能能长时间配合</span><br><span class="line"></span><br><span class="line">p79 为什么打屁股没用</span><br><span class="line">打屁股会影响孩子的学习能力，教唆使用暴力，体罚会造成伤害，打击自信心</span><br><span class="line">因为暴力而屈服，并不是真的理解，也没有主观产生能动性</span><br><span class="line"></span><br><span class="line">p92 奖励无法奏效</span><br><span class="line">核心是孩子应该是靠情感来激励，而不是物质；幸福感只能来源自身；</span><br><span class="line">久而久之，孩子会对奖励有过高的期望或者依赖。</span><br><span class="line">准确的夸赞孩子，而不是使用某种激励手段。</span><br><span class="line"></span><br><span class="line">p96 孩子耍脾气怎么办</span><br><span class="line">不要针锋相对</span><br><span class="line">提前计划，表达对孩子的理解和同情，保持冷静，不去理睬</span><br><span class="line"></span><br><span class="line">p149 无条件的爱</span><br><span class="line">了解自己，了解孩子</span><br></pre></td></tr></table></figure><h1 id="🙋‍♀️总结感悟"><a href="#🙋‍♀️总结感悟" class="headerlink" title="🙋‍♀️总结感悟"></a>🙋‍♀️总结感悟</h1><ol><li><p>核心观点是父母与孩子建立良好的沟通和互动关系，理解、疏导孩各类「不良」行为。进而形成亲子之间的感情纽带，教会孩子正确理解和处理自己的情感，成长为一个具有良好社交能力的人。</p></li><li><p>孩子发展是分阶段的，不同孩子的发展又不是完全同步的，因此父母要尊重规律，抛弃不切实际的计划和目标——例如要求 2 岁的孩子能安静坐着看电影。</p></li><li><p>作者认为新生儿阶段，应该给与足够的照料，这也是跟李玫瑾的观点类似。</p></li><li><p>2 岁以前，转移注意力的做法是可取的。</p></li><li><p>夸赞的方式：询问孩子自身的感受（你觉得怎么样？），站在主观的角度来观察（我喜欢你穿的衣服），而不是下一个看似客观的定义（你真会穿衣服）。</p></li><li><p>这本书实用性比较强，用了大量的案例来支撑观点。3-4-5 章更是针对各类儿童的问题，都给出了分析和对策。</p></li><li><p>教会孩子与大人进行协作。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。&lt;/p&gt;
&lt;p&gt;人生来就是一张白纸，父母是第一位
      
    
    </summary>
    
      <category term="reading" scheme="https://0xkevinhe.xyz/categories/reading/"/>
    
    
      <category term="education" scheme="https://0xkevinhe.xyz/tags/education/"/>
    
  </entry>
  
  <entry>
    <title>币安链（BC）与币安智能链（BSC）简介</title>
    <link href="https://0xkevinhe.xyz/blockchain-bsc-intro.html"/>
    <id>https://0xkevinhe.xyz/blockchain-bsc-intro.html</id>
    <published>2020-09-19T03:46:03.000Z</published>
    <updated>2023-09-27T07:01:22.149Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。</p><h1 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h1><p>总所周知，币安基于Cosmos-SDk 搭建了币安链（Binance Chain，下称 BC），并于 2019 年上线了主网。那为什么还要有另外一个智能链（Binance Smart  Chain，下称 BSC）呢。白皮书解释和言外之意都描述下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）实际应用要求有更强的可编程性（要有智能合约）</span><br><span class="line">2）保证现有的 dex 的高性能（基于 cosmos-sdk的链交易并发是有瓶颈的）</span><br><span class="line">3）开发者的学习曲线（以太坊的 DApp 生态最完善）</span><br></pre></td></tr></table></figure><p>有了以上的需求，采用下面的技术路线和架构几乎是水到渠成。</p><h1 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h1><h2 id="设计目标-1"><a href="#设计目标-1" class="headerlink" title="设计目标"></a>设计目标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）BC 为主链，新链是一个独立区块链，对BC的依赖少</span><br><span class="line">2）兼容以太坊生态，保留跟随以太坊升级的可能性（改动越少，越好升级）</span><br></pre></td></tr></table></figure><h2 id="分工和职责"><a href="#分工和职责" class="headerlink" title="分工和职责"></a>分工和职责</h2><p>为了旧链和新链的合理性，设计了下面的职责和结构。</p><p>BC核心职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）原有的 dex 功能</span><br><span class="line">2）平行链信息， staking 与治理</span><br></pre></td></tr></table></figure><blockquote><p>平行staking 放在 BC 上，也可能是考虑以后还会有别的新链出现~</p></blockquote><p>BSC 核心职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）运行区块链，输出 staking 和治理依据</span><br><span class="line">2）运行复杂的 DApp</span><br></pre></td></tr></table></figure><p>由于两个链是相对独立的，所以称为是<code>平行链</code>。</p><h1 id="BSC-共识协议"><a href="#BSC-共识协议" class="headerlink" title="BSC 共识协议"></a>BSC 共识协议</h1><p>BSC 采用了 所谓的 PoSA（Proof of Staked Authority），你可以认为是以太坊代码中的 Clique 的一个小改动，综合了 PoA 和 DPoS 的思路。大致流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）验证者或者代理人在 BC 上抵押</span><br><span class="line">2）BC 每24 小时重选合法验证者列表（21 个），通过跨链消息传递给 BSC</span><br><span class="line">3）BSC 根据验证者列表，选择节点轮流产块</span><br></pre></td></tr></table></figure><blockquote><p>PoA这个协议只能实现秒级的产块，但是无法实现秒级的确认（finality）。不确定做这个选择是为什么？可能是为了简单？个人认为有点偷懒了，采用基于 BFT 的快速确认的共识协议可能会更好。</p></blockquote><p>简单而言，实现了基于 PoS 治理，PoA 产块。</p><p>从区块浏览器观察来看，BC 的区块周期大约1秒 2 个区块（ sub-second），BSC 的区块周期是大约 3 秒。</p><p>因为 BC 使用的 tendermint 共识，所以交易确认时间也就是区块周期，BSC 使用了是 PoA 共识，如果等待 21 个节点中的 +1/2确认，需要大约 30s-1m。</p><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>设计了在 BC 和 BSC 双向映射和转账的机制。</p><h2 id="Token-定义"><a href="#Token-定义" class="headerlink" title="Token 定义"></a>Token 定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BC：</span><br><span class="line">BEP2</span><br><span class="line">BNB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BSC：</span><br><span class="line">BEP2E</span><br><span class="line">BNB</span><br></pre></td></tr></table></figure><p>BNB 是两个平行链的 native token，交易手续费、抵押、奖励等都使用 BNB。</p><p>BEP2 是 BC 上类似于 ERC20 的 Token。</p><p>BEP2E 是 BSC 上类似于 ERC20 的 Token，多了几个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol()</span><br><span class="line">decimals()</span><br><span class="line">onwer() //比较重要，声明拥有者地址，后面只有这个地址可以发起绑定操作</span><br></pre></td></tr></table></figure><p>那核心问题就是Token映射和转账，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEP2 of BC <--?-->BEP2E of BSC </span><br></pre></td></tr></table></figure><h2 id="Token-绑定"><a href="#Token-绑定" class="headerlink" title="Token 绑定"></a>Token 绑定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）确定 BC 上的BEP2和 BSC 上的 BEP2E 存在</span><br><span class="line">2）确定和锁定发行量</span><br><span class="line">  假如总发行量 S，</span><br><span class="line">  BC 初始流通 K</span><br><span class="line">  BSC 初始流通 S-K</span><br><span class="line">token 发行者应该在对应的链上把未流通的量 lock 到系统合约或者账户，使得两个链上的发行总量是 S。</span><br><span class="line">3）BEP2 token 的发行者在 BC 上发起绑定交易</span><br><span class="line">完成检查之后，绑定请求发送到 relayers</span><br><span class="line">4）BSC relayer 将跨链绑定信息转发给 TokenHub 合约</span><br><span class="line">5）BEP2E 的 owner 调用 TokenHub 合约的方法，后者确认 1.未被绑定 2.symbol 发行量和最小数量位 3。锁定正常</span><br><span class="line">6）BC 通过 Oracle 收到返回信息，将 contract address 和 decimal 信息写入 BC</span><br></pre></td></tr></table></figure><p>注意，以上流程，需要 BC 上的系统托管账户，和 BSC 上的系统合约作为基础设施。</p><h1 id="链互操作"><a href="#链互操作" class="headerlink" title="链互操作"></a>链互操作</h1><h2 id="平行链结构"><a href="#平行链结构" class="headerlink" title="平行链结构"></a>平行链结构</h2><p>官方这张图很不错。<br><img src="https://raw.githubusercontent.com/changbinhe/images/master/blog/blockchain-bsc-intro/para-chain.png" alt="para-chain"></p><p>注意 BSC Relayer 和 Oracle Relayer，分别负责把信息转发到 BSC 和 BC。</p><p>下面先介绍这两个角色，再介绍具体的跨链操作方式。</p><blockquote><p>值得一提的是，币安在设计这两个角色的时候，已经考虑到了去中心化环境可能带来的问题和采取了一定的对策。</p><p>但是，这两个角色本身的合法性和提供的信息的验证问题，是不够清晰的。</p></blockquote><h2 id="BSC-replayer"><a href="#BSC-replayer" class="headerlink" title="BSC replayer"></a>BSC replayer</h2><p>BSC relayer 负责将信息从 BC传递到BSC。</p><p>需要存入一定量的 BNB 到BSC链上进行「注册」，BSC 只会接受注册的 relayers。</p><ul><li>激励机制</li></ul><p>1）用户操作，由用户买单</p><p>2）系统同步，由 BSC 系统买单</p><ul><li>为了避免 relayers 垄断的情况</li></ul><p>1）奖励是批量分配</p><p>2）在批量中，奖励不是线性分配</p><h2 id="Oracle-Relayers"><a href="#Oracle-Relayers" class="headerlink" title="Oracle Relayers"></a>Oracle Relayers</h2><p>负责将信息从 BSC 传递到BC，消息本身需要经过BC 验证者的共识。</p><p>在提交之前，Oracle 需要等待足够的 BSC 区块确认（PoA 确认需要 1 分钟）。</p><p>跨链奖励会成为区块奖励的一部分，分配给验证者。</p><blockquote><p>将来也会引入对 Oracle 的 slashing</p></blockquote><h2 id="BC-BSC"><a href="#BC-BSC" class="headerlink" title="BC->BSC"></a>BC->BSC</h2><p>依赖BSC Replayers，消息将会进入到预编译的系统智能合约。</p><p>消息类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Token绑定</span><br><span class="line">转账</span><br><span class="line">错误处理</span><br><span class="line">验证者信息更新</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="BSC-BC"><a href="#BSC-BC" class="headerlink" title="BSC ->BC"></a>BSC ->BC</h2><p>如果是通过交易产生的跨链事件，其流程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tx -> EVM -> event -> oracle</span><br></pre></td></tr></table></figure><p>每个BC 链验证者需要运行 oracle 进程作为 oracle relayer。</p><p>跨链消息包，也会被 BC 中的 validator 进行投票，签名超过2/3即为合法。</p><h2 id="超时和错误处理"><a href="#超时和错误处理" class="headerlink" title="超时和错误处理"></a>超时和错误处理</h2><p>这个在跨链协议中很重要，涉及到回滚等。</p><p>当某个 sequence 的 tx 卡主，超时之后，将会有一个 skipsequence 交易出现，对卡主的 sequence 做出不可执行的标记。</p><p>社区决定如何处理。</p><blockquote><p>链上无法解决的问题，最终还是推到社区||-_-</p></blockquote><h1 id="Staking-和治理"><a href="#Staking-和治理" class="headerlink" title="Staking 和治理"></a>Staking 和治理</h1><p>BC 和 BSC 的Staking 的基本概念与其他基于 POS的链没有大不一样，要点如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）抵押，代理</span><br><span class="line"></span><br><span class="line">2）按照 token 排名，top n 作为验证者</span><br><span class="line"></span><br><span class="line">3）validator 分享收益给 delegator</span><br><span class="line"></span><br><span class="line">4）validator 会有被 slashing 的危险，delegator 需要分担</span><br><span class="line"></span><br><span class="line">5）token 有赎回期</span><br></pre></td></tr></table></figure><p>具体到 BC 和 BSC 的配合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）BC 上抵押和代理 BNB</span><br><span class="line"></span><br><span class="line">2）BSC 的 validator 由 BC 上的 staking 模块决定，UTC 00:00:00 发出跨链通讯</span><br><span class="line"></span><br><span class="line">3）BSC 将验证者工作的信息，通过跨链通讯回传到 BC</span><br><span class="line"></span><br><span class="line">4）在 BC 上进行 reward 分配</span><br></pre></td></tr></table></figure><h1 id="罚没"><a href="#罚没" class="headerlink" title="罚没"></a>罚没</h1><p>基于 PoS 的公链，其活性需要全体 validator 的诚实、如实工作保证的。</p><p>为了从经济学上推动这类行为，引入了罚没机制。</p><h2 id="双签"><a href="#双签" class="headerlink" title="双签"></a>双签</h2><p>所谓的双签，是对于同一高度+同一个parent 的区块进行多与一次的签名。任何第三方都可以，以 slash request 的方式发到 BC 上。</p><p>1）从 validator 中移除——发出 update 事件</p><p>2）罚没一定量</p><p>3）一部分给提交者</p><p>4）另外的给验证者监管账户</p><h3 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h3><p>一个内部合约，统计工作情况。</p><p>1）如果超过不工作阈值，其已得收益，将不会发给 BC，而是分2给其他的 validators。</p><p>驱使运营不好的节点，delegator 将会离开</p><p>2）如果工作情况低于另外一个阈值，将会通知 BC，发生另外一个 slashing</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来讲，其技术结构和治理方式参考了一众跨链项目 （例如 cosmos 和 polkadot），也参考了 DPoS 的一众项目（例如 EOS 和 TRON）。机制设计上也留出了后续扩展的空间。在本文写作之时（2020-09），BSC 上已运行了若干 DeFi 应用，这也是 BSC 的实现最初目标（承接 DApp）的佐证。</p><p>在文章中，笔者也提出了一些疑问，例如 PoA 的区块确认时间过长，Relayer 和 Oracle 本身的信息正确性问题等。</p><p>在单链技术还没有实质性突破的情况下（以太坊 2.0 可能还需要若干年才能成熟，或者不会成功），这类平行扩展的思路，也不失为快速开展业务尝试的一种实干派做法。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.binance.org/">BC 官网</a></p><p><a href="https://dex-bin.bnbstatic.com/static/Whitepaper_%20Binance%20Smart%20Chain.pdf">BSC白皮书</a></p><p><a href="https://explorer.binance.org/">BC 浏览器</a></p><p><a href="https://bscscan.com/">BSC 浏览器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。&lt;/p&gt;
&lt;h1 id=&quot;出发点&quot;&gt;&lt;a href=&quot;#出发点&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/tags/blockchain/"/>
    
      <category term="DeFi" scheme="https://0xkevinhe.xyz/tags/DeFi/"/>
    
  </entry>
  
  <entry>
    <title>《影响力》读书笔记</title>
    <link href="https://0xkevinhe.xyz/reading-influence.html"/>
    <id>https://0xkevinhe.xyz/reading-influence.html</id>
    <published>2020-08-17T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。</p><p>通过阅读这本书，可以为<code>运营活动</code>或者<code>销售技巧</code>寻找理论根据，做到知其所以然。</p><h1 id="🏷信息卡片"><a href="#🏷信息卡片" class="headerlink" title="🏷信息卡片"></a>🏷信息卡片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作者:[美] 罗伯特·西奥迪尼</span><br><span class="line">出版社: 中国人民大学出版社</span><br><span class="line">出品方: 湛庐文化</span><br><span class="line">原作名: Influence: The Psychology of Persuasion</span><br><span class="line">译者: 陈叙</span><br><span class="line">出版年: 2006-5</span><br><span class="line">页数: 353</span><br><span class="line">定价: 45.00元</span><br><span class="line">装帧: 平装</span><br><span class="line">丛书: 湛庐文化· 商业智慧</span><br><span class="line">ISBN: 9787300072487</span><br><span class="line">起止时间：       2020.07.15--2020.08.15</span><br><span class="line">阅读次数：       2</span><br><span class="line">推荐指数：      🌟🌟🌟🌟</span><br><span class="line">获奖情况：                                                                                                </span><br></pre></td></tr></table></figure><h1 id="🌱写作背景"><a href="#🌱写作背景" class="headerlink" title="🌱写作背景"></a>🌱写作背景</h1><p>作者社会心理学家，致力于影响力的研究</p><p>作者使用了所谓的参与式观察（间谍）参与到一些商品或者服务的销售工作中，以获取技巧</p><h1 id="📒原著呈现"><a href="#📒原著呈现" class="headerlink" title="📒原著呈现"></a>📒原著呈现</h1><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/blog/reading-influence/mindmap.png" alt="mindmap"></p><h1 id="🖇书摘-批注"><a href="#🖇书摘-批注" class="headerlink" title="🖇书摘&批注"></a>🖇书摘&批注</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">p3-4：绿宝石价格提高了，反而销量好了；</span><br><span class="line"></span><br><span class="line">人在成长过程中，接受了观念，价格贵=东西好；</span><br><span class="line">调高了价格，触发了用户的顺从按钮；在这一点上，人类也是某种基于反应的动物——跟雌火鸡一样；</span><br><span class="line"></span><br><span class="line">p9：文明的进步，就是人们在不假思索中可以做的事情更多</span><br><span class="line">所谓的专家，也就是在不断的训练中，形成了对于工作的问题的肌肉记忆</span><br><span class="line"></span><br><span class="line">p15-16：对比原理</span><br><span class="line">先看霹雳娇娃，会影响给自己对象的打分；</span><br><span class="line">先兜售贵的商品、其次是便宜商品——可能会让总收益最大</span><br><span class="line">先给一个不好的方案、然后给一个正常的方案，可能会有助于方案的接受</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二章：互惠——给予、索取、在索取</span><br><span class="line"></span><br><span class="line">p25：给对方寄贺卡，会受到很多回信</span><br><span class="line">在一个社交网络早期，主动加别人，会有一定的会加率</span><br><span class="line"></span><br><span class="line">p28：给对方带一瓶可乐，就可以获得更高的彩票销售</span><br><span class="line">不要忽视小恩小惠的作用；要习惯对别人施以援手——赠人玫瑰，手留余香</span><br><span class="line"></span><br><span class="line">p33：政府高层的相互投票和联合</span><br><span class="line">奥巴马和特朗普该多难啊！</span><br><span class="line"></span><br><span class="line">p35：安利臭虫</span><br><span class="line">所谓的试吃，也是这道理吧</span><br><span class="line"></span><br><span class="line">p38：人有送礼的义务、接受的义务、更有偿还的义务</span><br><span class="line">想起了老教父柯里昂</span><br><span class="line"></span><br><span class="line">p48：拒绝-后撤</span><br><span class="line">常见的销售技巧——漫天要价，坐地还钱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三章：承诺和一致性——脑子里的怪物</span><br><span class="line"></span><br><span class="line">p63：一开始就拒绝，比最后返回要容易——达芬奇</span><br><span class="line">至理名言，特别是对于推销cold call</span><br><span class="line"></span><br><span class="line">p67：所有人都一次次的骗自己，以便在做出选择之后，坚信自己做的没错</span><br><span class="line">you've got a dream, you've to protecet it</span><br><span class="line"></span><br><span class="line">p68：信仰、言行和行为前后一致不一致的人，会被看成脑筋混乱表里不一；言行高度一致多数跟个性坚强、智力出众；它是逻辑性、稳定性、诚实感的核心</span><br><span class="line">胡忠献的忠，岳飞的忠</span><br><span class="line">吴三桂所谓没有定力</span><br><span class="line"></span><br><span class="line">p70：关于冥思会和缴费</span><br><span class="line">超自然的方法，可能是唯一解药；</span><br><span class="line"></span><br><span class="line">p73：玩具销售商的策略</span><br><span class="line">为了保持淡季的销量</span><br><span class="line"></span><br><span class="line">p85：战俘营的做法</span><br><span class="line">以小积大</span><br><span class="line"></span><br><span class="line">p86：个人承诺防止撕毁合同</span><br><span class="line">自己说出的话，自己要遵守承诺</span><br><span class="line"></span><br><span class="line">p90：额外的努力，费尽努力得到的东西，人人往往格外珍视</span><br><span class="line">追姑娘丈母娘设置困难</span><br><span class="line">公司的严格面试，也是一种投名状</span><br><span class="line">其中的成员，会强烈的维护这种准入</span><br><span class="line">建立团队凝聚力和卓越感，入会活动要艰辛</span><br><span class="line"></span><br><span class="line">p100：内心的压力</span><br><span class="line">你得找一个有力的理由，让他大多数情况下都保持城市，可这个理由又不能强大到让孩子觉得，自己完全是为了它才诚实</span><br><span class="line">太强烈的惩罚，可能不会奏效</span><br><span class="line">要是说谎，我会失望的</span><br><span class="line">这个对于教育孩子很有意义，要让遵守规则成为孩子自身的习惯，而不是被强迫的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第四章：社会认同——脑子里的怪物</span><br><span class="line"></span><br><span class="line">p120：依照别人意见行事</span><br><span class="line"></span><br><span class="line">盖得排行，大众点评</span><br><span class="line">街头围观，网红店雇人排队</span><br><span class="line"></span><br><span class="line">p138:寻求帮助</span><br><span class="line">找到特定的人寻求帮助</span><br><span class="line">旁</span><br><span class="line"></span><br><span class="line">p150:自杀新闻</span><br><span class="line">会导致更高的自杀率</span><br><span class="line"></span><br><span class="line">第五章：喜好——友好的盗贼</span><br><span class="line"></span><br><span class="line">p175:销售外表</span><br><span class="line">广告模特和销售人员都要漂亮</span><br><span class="line">p179:喜好</span><br><span class="line"></span><br><span class="line">广告的作用。第一次陌生，看了广告之后就觉得是名牌了</span><br><span class="line"></span><br><span class="line">p181:所谓的融合策略</span><br><span class="line">融合过程中导致的恶意，难道不是留下更大的影响么</span><br><span class="line"></span><br><span class="line">p184:拼图学习法</span><br><span class="line">竞争与合作</span><br><span class="line"></span><br><span class="line">p199:体育运动</span><br><span class="line">乒乓球、排球、奥运会等对国民认同的形成的作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第六章：权威——教化下的敬重</span><br><span class="line"></span><br><span class="line">p223:头衔</span><br><span class="line">都喜欢挂一堆头衔</span><br><span class="line">第七章：稀缺——数量少说了算</span><br><span class="line"></span><br><span class="line">p243:稀缺</span><br><span class="line">销售管用伎俩，create urgent</span><br><span class="line"></span><br><span class="line">p247:逆反心理</span><br><span class="line">有屏障，挑衅；测试界限；罗密欧朱丽叶，如果没有限制，可能不多久就分掉了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p253:信息审查</span><br><span class="line">「禁书」，快要被删，这都有助于传播</span><br><span class="line">p260:参与竞争稀缺资源，有强大的刺激性</span><br><span class="line">所谓的竞雄？拍卖</span><br></pre></td></tr></table></figure><h1 id="🙋‍♀️总结感悟"><a href="#🙋‍♀️总结感悟" class="headerlink" title="🙋‍♀️总结感悟"></a>🙋‍♀️总结感悟</h1><p>顺从的力量，来自大量「正统」观念影响</p><p>从理论上了解影响力的来源：互惠、承诺和一致性、社会认同、喜好、权威、稀缺</p><p>验证和对照了一些日常的销售和运营策略</p><h1 id="👯‍♀️他山之石"><a href="#👯‍♀️他山之石" class="headerlink" title="👯‍♀️他山之石"></a>👯‍♀️他山之石</h1><p>🎥多媒体资料</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。&lt;/p&gt;
&lt;p&gt;通过阅读这本书，可以为&lt;code&gt;运营活动&lt;/code&gt;
      
    
    </summary>
    
      <category term="reading" scheme="https://0xkevinhe.xyz/categories/reading/"/>
    
    
      <category term="社会心理学" scheme="https://0xkevinhe.xyz/tags/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证介绍与项目实战</title>
    <link href="https://0xkevinhe.xyz/open-source-license.html"/>
    <id>https://0xkevinhe.xyz/open-source-license.html</id>
    <published>2020-04-28T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到：</p><ul><li>使用和修改的条件是什么？</li><li>商用和分发的条件是什么？</li><li>本项目开源后使用什么许可证？</li></ul><p>本文将简要介绍对许可证（license）的理解，着重介绍一个实战项目处理方式。</p><h1 id="许可证介绍"><a href="#许可证介绍" class="headerlink" title="许可证介绍"></a>许可证介绍</h1><p>许可证的内容，其实是博大精深。</p><p>首先许可证的种类特别的多，其次不同的许可的条款和细节也特别的多。</p><p>下面主要是介绍若干<code>主流且具有代表性</code>的许可证。</p><blockquote><p>主要参考了<a href="https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html">开源许可证教程-阮一峰的网络日志</a></p></blockquote><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>分发</p><p>将版权作品从一个人转移到另外一个人；例如提供给别人；如果是本公司使用，不算分发。</p></li><li><p>传染</p><p>一个项目用到了某个许可证的代码，在某些条件下（例如分发），这个项目本身也需要使用这种许可证</p></li><li><p>许可证版本</p><p>同一个许可证，有版本号之间的区别，例如 GPL 有 v1/v2/v3。</p></li></ul><h2 id="宽松的许可证"><a href="#宽松的许可证" class="headerlink" title="宽松的许可证"></a>宽松的许可证</h2><p>包含 MIT/ISC/BSD/Apache等，基本上这类许可证，是可以放心使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）BSD（二条款版）</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。</span><br><span class="line"></span><br><span class="line">（2） BSD（三条款版）</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</span><br><span class="line"></span><br><span class="line">（3）MIT</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</span><br><span class="line"></span><br><span class="line">（4）Apache 2</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</span><br></pre></td></tr></table></figure><h3 id="Copyleft-许可证"><a href="#Copyleft-许可证" class="headerlink" title="Copyleft 许可证"></a>Copyleft 许可证</h3><p>代码可以随意复制，有如下前提：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如果分发二进制格式，必须提供源码</span><br><span class="line">- 修改后的源码，必须与修改前保持许可证一致</span><br><span class="line">- 不得在原始许可证以外，附加其他限制</span><br></pre></td></tr></table></figure><p>核心在于，修改后的代码，不得闭源。</p><ul><li>AGPL</li></ul><p>最严格的 GPL，除非获得商业授权，否则无论以何种方式修改或者使用代码，都需要开源。</p><blockquote><p>云服务使用AGPL 的源码，不构成分发，也也需要开源</p></blockquote><ul><li>GPL</li></ul><p>如果分发软件，则使用和修改都必须开源，整个项目都必须采用 GPL许可。</p><ul><li>LGPL</li></ul><p>分发时，如果是使用动态类库的方式引用，可以不开源</p><ul><li>MPL</li></ul><p>分发时，只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p><blockquote><p> 无论是商业应用，还是开源项目，在采用 AGPL/GPL/LGPL/MPL都要特别的小心。</p></blockquote><h1 id="许可证检测"><a href="#许可证检测" class="headerlink" title="许可证检测"></a>许可证检测</h1><p>介绍两个工具，分别检测代码文件和依赖的 license。</p><h2 id="检测代码"><a href="#检测代码" class="headerlink" title="检测代码"></a>检测代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/addlicense</span><br></pre></td></tr></table></figure><p>可以递归检测当前目录下的所有代码文件，许可证声明的情况，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addlicense -check ./ |sort > lc.txt </span><br></pre></td></tr></table></figure><p>可以把未添加许可证的文件都输出到lc.txt 文件中，方便后续进行检查。</p><h2 id="检测依赖库"><a href="#检测依赖库" class="headerlink" title="检测依赖库"></a>检测依赖库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/go-licenses</span><br></pre></td></tr></table></figure><p>查看一个依赖库所使用的版权信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-licenses csv repo</span><br></pre></td></tr></table></figure><p>可以通过一个这个脚本项目进行批量测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat dep.txt |while read line</span><br><span class="line">do </span><br><span class="line">echo "start checking package $line"</span><br><span class="line">go-licenses csv $line</span><br><span class="line">echo ""</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="许可证添加"><a href="#许可证添加" class="headerlink" title="许可证添加"></a>许可证添加</h2><p>笔者主要使用 idea 的 IDE 进行程序开发，它有管理版权信息的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Preference->editor->Copyright</span><br></pre></td></tr></table></figure><p>可以添加不同的 Profiles，然后使用 IDE的功能进行自动添加和更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）设置默认 copyright</span><br><span class="line">preference->editor->Copyright</span><br><span class="line">设置 default project copyright，选中一种配置，这个可能会根据不同的文件需要切换</span><br><span class="line"></span><br><span class="line">2）选中代码文件或者文件夹</span><br><span class="line"></span><br><span class="line">3）菜单栏->Code->Update Copyright</span><br></pre></td></tr></table></figure><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>下文介绍对于一个实际项目进行许可证声明。</p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>该项目主语言是 golang，采用了自某 LGPL 的项目的一部分类库作为基础代码。</p><h2 id="版权主体"><a href="#版权主体" class="headerlink" title="版权主体"></a>版权主体</h2><p>也就是版权声明的第一行的关键信息，例如：</p><ul><li>go-ethereum</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2016 The go-ethereum Authors</span><br></pre></td></tr></table></figure><ul><li>go-algorand</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) 2019-2020 Algorand, Inc.</span><br></pre></td></tr></table></figure><p>可以选择是作者主体，或者公司主体。</p><h2 id="项目-license"><a href="#项目-license" class="headerlink" title="项目 license"></a>项目 license</h2><p>由于该项目的代码，部分使用了修改了 LGPL 项目代码作为基础工具。</p><p>根据 LGPL 的规定，本项目也需要使用 LGPL 作为 license。</p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>声明版权，一般两部分：</p><h4 id="1）项目级别的-LICENSE-文件"><a href="#1）项目级别的-LICENSE-文件" class="headerlink" title="1）项目级别的  LICENSE 文件"></a>1）项目级别的  LICENSE 文件</h4><p>由于大部分的许可证都是控制包级别的许可，所以这种方式也足够</p><h4 id="2）代码级别的-copyright-文件头"><a href="#2）代码级别的-copyright-文件头" class="headerlink" title="2）代码级别的 copyright 文件头"></a>2）代码级别的 copyright 文件头</h4><p>每一个原创的文件都设置了版权信息</p><h2 id="项目级别的-license"><a href="#项目级别的-license" class="headerlink" title="项目级别的 license"></a>项目级别的 license</h2><p>一般而言，是找到你的 license 的文本，将文件放置于项目根目录。</p><blockquote><p> 不同许可证可能有点不一样</p></blockquote><p>一般而言，在 github 建立公开项目的时候，会提示选择一个 license。</p><p>如果初始化忘记了，也可以web 界面上，新建一个名字是<code>LICENSE</code>的文件，来显式触发选择 license。</p><h2 id="代码级别的-copyright-文件头"><a href="#代码级别的-copyright-文件头" class="headerlink" title="代码级别的 copyright 文件头"></a>代码级别的 copyright 文件头</h2><p>使用第三方代码，主要分为，<code>fork 引用</code> 和 <code>library 依赖</code>。</p><p>fork 是指把代码直接放到了代码库中，修改或者不修改。</p><p>library 是库依赖，例如通过 go.mod 的方式进行依赖。</p><h3 id="fork-引用"><a href="#fork-引用" class="headerlink" title="fork 引用"></a>fork 引用</h3><p>代码分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1）项目原创文件</span><br><span class="line"></span><br><span class="line">2）项目修改第三方库的文件</span><br><span class="line"></span><br><span class="line">3）项目直接引用第三方库的文件</span><br><span class="line"></span><br><span class="line">4）fork 过来的开源库</span><br><span class="line">可能存在包内 license，单文件可能没有copyright</span><br><span class="line"></span><br><span class="line">5）忽略 license 文件的内容</span><br><span class="line"></span><br><span class="line">非 golang 文件</span><br><span class="line">gencode 生成的以 gen_开头的文件</span><br><span class="line">其他自动生成的文件</span><br></pre></td></tr></table></figure><p>有了如上的分类，你就可以使用 IDE 创建多个不同的 Copyright Profiles 来处理不同的文件了。</p><p>结合 addlicense 工具，相信这部分工作将可以顺利完成。</p><h4 id="library-依赖"><a href="#library-依赖" class="headerlink" title="library 依赖"></a>library 依赖</h4><p>使用上述的依赖检测工具，查看是否有不合适的许可证。</p><blockquote><p>如果一个依赖库，license 不是MIT/ISC/BSD/Apache 其中的一种，那就要小心了！</p></blockquote><h1 id="TBD-Topics"><a href="#TBD-Topics" class="headerlink" title="TBD-Topics"></a>TBD-Topics</h1><p>有一些话题需要进一步讨论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1）如果项目源码计划商用，如何处理？</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简要介绍了license 的原理，着重介绍了项目实战，希望对读者有启发，欢迎讨论！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html">https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html</a></p><p><a href="https://www.gnu.org/licenses/gpl-faq.html">https://www.gnu.org/licenses/gpl-faq.html</a></p><p><a href="https://choosealicense.com/">https://choosealicense.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用和修改的条件是什么？&lt;/li&gt;
&lt;li&gt;商用和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 作为服务器</title>
    <link href="https://0xkevinhe.xyz/osx-as-server.html"/>
    <id>https://0xkevinhe.xyz/osx-as-server.html</id>
    <published>2017-12-04T03:21:55.000Z</published>
    <updated>2023-09-27T07:01:22.161Z</updated>
    
    <content type="html"><![CDATA[<p>因为业务需要，我司有若干台服务器 Mac 作为服务器。下面总结一下注意事项，作为记录。</p><h1 id="取消系统休眠"><a href="#取消系统休眠" class="headerlink" title="取消系统休眠"></a>取消系统休眠</h1><p>曾经在这个问题上困扰很长时间。在升级了 <code>macOS High Sierra</code> 之后，发现之前能够正常运行的程序出现问题。</p><p>具体表现是：</p><ol><li>ssh 登出之后不久，线上就开始报警</li><li>登陆进去查看 log，发现程序又是正常的</li><li>socket 连接提示传输错误</li><li>程序并没有 exit</li></ol><p>一开始怀疑是后台程序的权限问题，于是更新了后台程序的 launchd 配置，确保了使用 root 用户运行，没有效果。</p><p>后来灵机一动，去具体分析程序的 log，发现只要用户登出，输出就会停止，看起来是程序被挂起了。</p><p>分析可能被挂起的原因，只可能是系统休眠了。</p><p>直接登陆 GUI 系统，在系统设置中将节能设置改成：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-12-4/97778894.jpg" alt="节能设置"></p><p>生效了！</p><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>作为服务器，大多是需要运行守护进程。这就需要用到 <code>launchd</code>，它能确保这是确保设备重启之后，守护能够自动运行。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Launchd">launchd</a> 是一个开源框架，用于控制守护进程、程序、或者脚本，在 Mac OS X Tiger 中引入。</p></blockquote><p>使用 launchd，主要需要注意下面几点：</p><ul><li>正确区分系统全局的守护和用户相关的守护进程</li></ul><table><thead><tr><th>类型</th><th>路径</th><th>运行用户</th></tr></thead><tbody><tr><td>全局的守护进程</td><td>/Library/LaunchDaemons</td><td>root 用户或者使用 UserName key 对应的用户</td></tr><tr><td>系统的守护进程</td><td>/System/Library/LaunchDaemons</td><td>root 用户或者使用</td></tr></tbody></table><p>一般而言，把 plist 文件放到 <code>/Library/LaunchDaemons</code> 即可。</p><ul><li>正确设置 plist 文件的权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  1 wheel  947 12  1 14:51 name_of_the_config.plist</span><br></pre></td></tr></table></figure><p>也即是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户：root</span><br><span class="line">组：wheel</span><br><span class="line">权限： 0644</span><br></pre></td></tr></table></figure><ul><li>被运行的程序，需要是处于前台运行，否则 launchd 会认为程序已经退出</li><li>如果需要全局性的守护进程，需要使用 sudo 运行</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.launchd.info/">http://www.launchd.info/</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html#//apple_ref/doc/man/5/launchd.plist">launchd.plist</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/launchctl.1.html#//apple_ref/doc/man/1/launchctl">launchctl</a></p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>很多时候，macOS 服务器并不是托管在机房，而是在某个比较方便管理的地方——例如办公室。</p><p>办公室的网络环境又千奇百怪，往往没有固定的外网 ip，往往是处于 NAT 的网络环境或者是防火墙内，如果服务出现了问题，总不能直接跑去办公室吧。</p><p>尝试过各种 VPN 方案，动静太大，不稳定，放弃。下面介绍一下 <a href="https://github.com/inconshreveable/ngrok">Ngrok</a>。</p><p>官网简介：</p><blockquote><p>Secure tunnels to localhost ”I want to expose a local server behind a NAT or firewall to the internet.”</p></blockquote><p>基本的构架图如下：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-12-4/55782772.jpg" alt="Ngrok"></p><p>这款软件是 C/S 结构，使用服务器作为中转，只需要设置好服务器和客户端，不需要在路由器做任何处理。<code>软件的2.x 不开源，github 上只有 1.x 版本</code>，已经足够。</p><p>使用方式，参考<a href="https://imququ.com/post/self-hosted-ngrokd.html"> imququ 的博客</a>。</p><p>基本流程是：</p><ol><li>clone 源码</li><li>生成证书，拷贝 <code>base.pem</code> 到 <code>assets/client/tls/ngrokroot.crt</code>  下</li><li>运行 <code>make release-server release-client</code></li><li><code>bin</code> 的 ngrokd 和 ngrok 分别是服务器端和客户端</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是对于 <code>macOS</code> 作为服务器的一些注意事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为业务需要，我司有若干台服务器 Mac 作为服务器。下面总结一下注意事项，作为记录。&lt;/p&gt;
&lt;h1 id=&quot;取消系统休眠&quot;&gt;&lt;a href=&quot;#取消系统休眠&quot; class=&quot;headerlink&quot; title=&quot;取消系统休眠&quot;&gt;&lt;/a&gt;取消系统休眠&lt;/h1&gt;&lt;p&gt;曾经在
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="macOS" scheme="https://0xkevinhe.xyz/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 配置中心</title>
    <link href="https://0xkevinhe.xyz/spring-cloud-config.html"/>
    <id>https://0xkevinhe.xyz/spring-cloud-config.html</id>
    <published>2017-10-13T15:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲话配置"><a href="#闲话配置" class="headerlink" title="闲话配置"></a>闲话配置</h1><p>老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就满足了需求。</p><blockquote><p>配置（Configuration）是不修改代码的情况下，对程序的运行调整的能力。</p></blockquote><p>简单来讲，配置可以分成两类：</p><ol><li>系统配置：包括线程池大小、数据库连接等，变化频率较低</li><li>业务配置：功能开关，功能参数等，变化较为频繁</li></ol><p>程序的配置一般而言，分为几个环境：</p><ol><li>开发环境</li><li>测试环境</li><li>生产环境</li></ol><p>这几个环境的配置是有差异的，所以配置管理功能应当能够根据当前环境读取对应的配置。</p><p>前面提到的不修改代码，只是最低要求，相当多的情况下，程序是不能停机的，这就提出了热更新的需求。</p><p>另外，配置的修改应该是有记录可追溯的。</p><h1 id="Spring-Boot-的配置管理"><a href="#Spring-Boot-的配置管理" class="headerlink" title="Spring Boot 的配置管理"></a>Spring Boot 的配置管理</h1><p>Spring 实现了非常友好的配置读取方式，</p><p>Spring Boot 程序默认使用 application.properties 进行配置。</p><p>例如一个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=0</span><br></pre></td></tr></table></figure><p>在程序中可以通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value("${flag})</span><br><span class="line">int flag;</span><br></pre></td></tr></table></figure><p>来读取。</p><p>也可以通过设置多个配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application.properties</span><br><span class="line">application-dev.properties</span><br><span class="line">application-test.properties</span><br><span class="line">application-prod.properties</span><br></pre></td></tr></table></figure><p>application-dev.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=1</span><br></pre></td></tr></table></figure><p>application-test.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=2</span><br></pre></td></tr></table></figure><p>application-prod.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=3</span><br></pre></td></tr></table></figure><p>和在 application.properties 中声明当前的活跃的 profile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure><p>来实现根据运行环境切换配置信息。</p><p>以上只是 Spring 强大的配置能力的冰山一角，有兴趣可以参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">外部配置文档</a>。</p><h2 id="这还不够"><a href="#这还不够" class="headerlink" title="这还不够"></a>这还不够</h2><p>其实以上描述的 Spring Boot 的配置能力已经很强了，但是有个很致命的问题——无法热更新。</p><p>如果非得实现热更新，那可以把配置做成 JSON 文件，再实现一个 endpoint，重新读取一次配置。</p><p>假设有一千个实例呢？</p><h1 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h1><p>项目 github：<a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a></p><p>简介：External configuration (server and client) for Spring Cloud</p><p>这个项目包含两部分：</p><ul><li>Server</li></ul><p>负责从 git/svn 等版本管理系统中读取配置，并以 http 的方式提供服务。</p><ul><li>Client</li></ul><p>根据客户端配置，从指定的 Server 中读取对应配置，并且与 Spring 本身的 PropertyResource 和 Environment 无缝结合。同时，提供了统一的方式进行配置热更新。</p><p>对于这个系统的基础配置和运行，可以参阅下面两个 url：</p><p><a href="https://spring.io/guides/gs/centralized-configuration/">https://spring.io/guides/gs/centralized-configuration/</a></p><p><a href="http://blog.didispace.com/spring-cloud-starter-dalston-3/">http://blog.didispace.com/spring-cloud-starter-dalston-3/</a></p><h2 id="实操进阶"><a href="#实操进阶" class="headerlink" title="实操进阶"></a>实操进阶</h2><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>Spring Cloud Config 实现了非常优雅的热更新。</p><ul><li>客户端的配置 Bean 添加 @RefreshScope</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConsumeConfig {</span><br><span class="line"></span><br><span class="line">    @Value("${consume.desc}")</span><br><span class="line">    private String consumeDesc;</span><br><span class="line">    </span><br><span class="line">    @Value("#{'${api.server.round.card}'.split(',')}")</span><br><span class="line">    private List<String> cardList;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在配置这个注解之后，调用客户端的 /refresh endpoint，这个 Bean 就会刷新，同时个 Bean 的依赖方下次方法调用时也会更新 Bean 引用。</p><p>有些时候，你需要监听这个更新事件，把拿到的最新配置，重新初始化一些部件。那你可以添加：<br>    <code>@EventListener(EnvironmentChangeEvent.class)</code> 这个 annotation。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumeService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConsumeConfig consumeConfig;</span><br><span class="line"></span><br><span class="line">    @EventListener(EnvironmentChangeEvent.class)</span><br><span class="line">    void onEnvChange() {</span><br><span class="line">        //do re-init stuff</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><p>Config Server 任何人都可以通过 http 访问配置，这个不大好，建议加上认证，最简单是使用 Spring-Security 添加一个 basic authentication。</p><ul><li>服务器端配置</li></ul><p>build.gradle 添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies {</span><br><span class="line">    compile('org.springframework.boot:spring-boot-starter-security')</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>application.properties 添加密码（用户名默认是 user）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security.user.password=xxx</span><br></pre></td></tr></table></figure><p>重启服务器，再次通过 http 访问配置的时候需要验证。</p><ul><li>客户端配置</li></ul><p>服务器端做了验证，那客户端也需要添加相应的配置：</p><p>bootstrap.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: application</span><br><span class="line"> cloud:</span><br><span class="line">  config:</span><br><span class="line">   uri: http://yourhost.com</span><br><span class="line">   profile: dev</span><br><span class="line">   username: user</span><br><span class="line">   password: xxx</span><br></pre></td></tr></table></figure><h3 id="加载多组配置文件"><a href="#加载多组配置文件" class="headerlink" title="加载多组配置文件"></a>加载多组配置文件</h3><p>很多时候，为了避免 application.properties 过于臃肿，你可能需要把一些配置文件拆出来，例如专门负责邀请奖励的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invite.properties</span><br><span class="line">invite-dev.properties</span><br><span class="line">invite-test.properties</span><br><span class="line">invite-prod.properties</span><br></pre></td></tr></table></figure><p>同样，也区分了多个环境。</p><p>那在使用 Spring Cloud 的时候如何读取这个文件呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: application,invite</span><br></pre></td></tr></table></figure><p>注意上面的 application.name 是以逗号分隔的两组配置名称。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="EventListener-与-SpEL"><a href="#EventListener-与-SpEL" class="headerlink" title="@EventListener 与 SpEL"></a>@EventListener 与 SpEL</h2><p>我在实际使用中发现，在事件监听函数中，使用更新后的配置的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value("${consume.desc}")</span><br><span class="line">private String consumeDesc;</span><br><span class="line"></span><br><span class="line">@Value("#{'${api.server.round.card}'.split(',')}")</span><br><span class="line">private List<String> cardList;</span><br></pre></td></tr></table></figure><p>第一个配置是使用 @Value 绑定一个字符串类型，第二个配置是使用 @Value 中的 SpEL 去将配置中的字符串，切割成 List。</p><p>我发现第二个，无法切割成功。试验了多次，还没有找到答案。我已经在 Spring Cloud Config 的 github 上提交了 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/821">issue</a>。</p><p>如果有了解这个的，请不吝赐教。</p><blockquote><p>update 2017-10-26</p></blockquote><ul><li>我在 github 上提交了 issue： <a href="https://github.com/spring-cloud/spring-cloud-config/issues/821">https://github.com/spring-cloud/spring-cloud-config/issues/821</a> 得到回复：<code>We have only ever documented that placeholders ${} work, not SpEL.</code></li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>在不做二次开发的情况下，这个配置中心的数据是对所有的 client 开放的。某些情况下，这种设定并不合适。</p><h2 id="JSON-文件的读取和解析"><a href="#JSON-文件的读取和解析" class="headerlink" title="JSON 文件的读取和解析"></a>JSON 文件的读取和解析</h2><p>Spring Cloud Config 本身是可以通过 http 来提供 JSON 文件的访问的，但是Spring Boot 原生并不支持 JSON 配置的读取和解析。</p><h1 id="相关选择"><a href="#相关选择" class="headerlink" title="相关选择"></a>相关选择</h1><p>其实配置管理工具，选择还是不少的，下面列举一下。</p><ul><li>owner <a href="http://owner.aeonbits.org/">http://owner.aeonbits.org/</a></li></ul><p>配置文件管理，可以热更新，跟 Spring 没有绑定。</p><ul><li>cfg4j <a href="http://www.cfg4j.org/">http://www.cfg4j.org/</a></li></ul><p>专注管理配置文件，也可以实现热更，跟 Spring 没有绑定。</p><ul><li>applolo <a href="https://github.com/ctripcorp/apollo">https://github.com/ctripcorp/apollo</a></li></ul><p>携程开源的，功能很全</p><ul><li>disconf <a href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a></li></ul><p>百度的一位工程师的开源项目，功能也很全</p><ul><li>diamond <a href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a></li></ul><p>来自阿里的开源，有些日子了</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://blog.didispace.com/spring-cloud-starter-dalston-3/">http://blog.didispace.com/spring-cloud-starter-dalston-3/</a></p><p><a href="http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html">http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html</a></p><p><a href="http://jm.taobao.org/2016/09/28/an-article-about-config-center/">http://jm.taobao.org/2016/09/28/an-article-about-config-center/</a></p><p><a href="https://blog.coding.net/blog/spring-cloud-config">https://blog.coding.net/blog/spring-cloud-config</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闲话配置&quot;&gt;&lt;a href=&quot;#闲话配置&quot; class=&quot;headerlink&quot; title=&quot;闲话配置&quot;&gt;&lt;/a&gt;闲话配置&lt;/h1&gt;&lt;p&gt;老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Spring" scheme="https://0xkevinhe.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>小工具-sips-图片批量转大小</title>
    <link href="https://0xkevinhe.xyz/utility-sips.html"/>
    <id>https://0xkevinhe.xyz/utility-sips.html</id>
    <published>2017-05-16T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="家有设计师"><a href="#家有设计师" class="headerlink" title="家有设计师"></a>家有设计师</h1><p>我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。</p><p>看了她导了好几次，实在不能忍。得发挥程序员的能动性，做个小工具。</p><h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p><a href="http://www.imagemagick.org/script/index.php">imagemagick</a> 是一个很好的工具，支持多个平台，功能丰富强大。考虑了一下，如果这个小工具还需要用户安装依赖的话，显然提高了使用门槛。</p><p>设计师们大多在 MacOS 下工作，最好是运用这个平台下现成的工具包。搜索了一下，发现今天的主角：<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/sips.1.html">sips</a>。</p><p>sips 具有很友好的使用接口，可以实现大小转换、旋转、翻转等。这里我只需要大小转换功能，主要是如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sips -Z 100 input.png --out output.png</span><br></pre></td></tr></table></figure><p>上面的例子可以将 <code>input.png</code> 图片最大边调整成100像素，等比缩放。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>整个工具包含如下几个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── convert.sh//转换程序</span><br><span class="line">├── icon.png//输入文件</span><br><span class="line">└── sizes.txt//目标尺寸</span><br></pre></td></tr></table></figure><p>使用步骤如下：</p><ol><li>替换 icon.png 文件为需要转换的文件</li><li>修改 sizes.txt 文件，编辑目标尺寸，每一行为一个尺寸</li><li>控制台运行 <code>./convert.sh</code> 即可</li></ol><p>为了很方便的让设计师同学使用这个工具，我在她的电脑上安装了一个 <a href="https://github.com/jbtule/cdto">cdto</a> 工具，可以在当前 finder 目录下打开 控制台。还把这个工具拖到了 finder 的左侧快捷方式。PS: 用户接口要友好。。。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码和配置文件都放在 <a href="https://github.com/kevinho/image-resizer">github</a> 上。</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>目前只支持 png</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;家有设计师&quot;&gt;&lt;a href=&quot;#家有设计师&quot; class=&quot;headerlink&quot; title=&quot;家有设计师&quot;&gt;&lt;/a&gt;家有设计师&lt;/h1&gt;&lt;p&gt;我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。&lt;/p&gt;
&lt;p&gt;看了她导了好几次，实在不能
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="产品" scheme="https://0xkevinhe.xyz/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验" scheme="https://0xkevinhe.xyz/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊 Alexa Echo Dot——入门</title>
    <link href="https://0xkevinhe.xyz/play-alexa-1.html"/>
    <id>https://0xkevinhe.xyz/play-alexa-1.html</id>
    <published>2017-03-21T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h1><p>大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。</p><p>亚马逊的 <a href="https://en.wikipedia.org/wiki/Amazon_Echo">Alexa Echo</a> 无疑是这个浪潮中的当红明星。</p><p>它是一个蓝牙音箱，是一个智能语音助手，是一个智能家居管理中心，它还提供了开放平台，允许第三方添加 <code>Skills</code> 来扩充功能。</p><p>本篇介绍一些购买和基本使用经验。</p><h1 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h1><p>在经过几代的发展之后，目前这个产品主要包含 <code>Echo</code> 和 <code>Echo Dot</code>。主要的区别是扬声器的规格。</p><p>如下图：<br><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-3-21/77023898-file_1490061698677_e03e.jpg" alt="Amazon-Echo"></p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-3-21/7885364-file_1490061698538_1047c.jpg" alt="Amazon-Echo-Dot"></p><p>Echo Dot 价格要亲民一些，500人民币左右，某宝可购买。</p><p>下单后很快到货，就是这么一个小盒子：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-3-21/17973801-file_1490061841802_10892.jpg" alt="Echo-Dot-实物"></p><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>顶部有四个按钮，功能分别是，分别是：静音、操控、音量加减。</p><p>背面有两个插槽，分别是 3.5 mm 声频输出口、Micro-USB 电源插口。</p><p>Echo Dot 需要一个叫做 <code>Alexa App</code>的手机软件作为控制端，下面提供 Android 和 iOS 平台的下载地址。</p><p><a href="https://play.google.com/store/apps/details?id=com.amazon.dee.app">Android-App</a></p><p><a href="https://itunes.apple.com/us/app/amazon-echo/id944011620">iOS-App</a></p><blockquote><p>注意在 iOS 平台上，这个 App 只允许美国区的账户进行下载。你可以折腾一下，注册一个美国区的 Apple ID，可能需要绑定信用卡。你也可以花钱买时间，在万能的某宝上买一个美国区账号。我选择了后者。</p></blockquote><h1 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h1><p>Echo Dot 是需要连接到 WiFi 进行工作的，这就需要用 Alexa App 进行绑定和设置。</p><p>如果你曾经用过小米的空气净化器，你会发现设置的模式类似。</p><p>主要步骤为：EchoDot 进入设定模式、手机连上 Echo Dot 共享的 WiFi、操作 Echo Dot 连接家里的 WiFi。</p><p>1.长按 Echo Dot 顶部的操控键，会有提示进入设定模式(enter setup mode)；</p><p>2.在手机的 WiFi 设置页面，可以看到名字为 Amazon-XXX 的 WiFi，连接上去，会有提示：(connected)；</p><p>3.进入 Alexa App，在里面选择家里的 WiFi，输入密码，确定之后，Echo Dot 会尝试进行连接。</p><blockquote><p>连接中，主要发现两个问题，一是卡，二是根本连不上。因为 Alexa 的服务器在国外，速度受一定的影响，卡是正常的。然而国内的网络环境比较复杂，例如我就遇到过家里的<code>方正宽带</code>下的 WiFi，根本连不上的情况。后来我只能使用手机的联通4G 开热点才能勉强使用。公司的电信宽带也没有问题。后面网络续费的时候，看来要换成电信或者联通了。</p></blockquote><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>Echo Dot 连接上网络之后，你就可以跟它对话了。默认唤醒口令是 <code>Alexa</code>。唤醒之后灯会亮。</p><p>例如就可以试一下，<code>Alexa, what's the weather</code>。它可能会告诉你美国西雅图现在的天气，地址可以在 Alexa App 中设置。（ps：我还没有找到设置成北京的方式）</p><h1 id="一些后续"><a href="#一些后续" class="headerlink" title="一些后续"></a>一些后续</h1><p>Alexa Echo 提供了开放平台，开发者可以将服务打包成 <code>Skills</code> 对系统进行扩展，这个就有点像苹果的 iOS 生态了。厂商只提供基础的服务和功能，开发者百花齐放。用户可以在 Alexa App 中添加 Skills，例如你可以添加一个读 CNN 新闻的功能。这一块还有待探索。</p><p>网络问题很严重，反应速度比较慢。后面如果想要愉快玩耍，还是得找一个比较好的联网方案。某一天亚马逊可以把服务器放一些到国内，就更好了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Alexa Echo Dot 入门初步介绍了购买、设置、使用。下面继续探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;智能家居&quot;&gt;&lt;a href=&quot;#智能家居&quot; class=&quot;headerlink&quot; title=&quot;智能家居&quot;&gt;&lt;/a&gt;智能家居&lt;/h1&gt;&lt;p&gt;大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。&lt;/p
      
    
    </summary>
    
      <category term="product" scheme="https://0xkevinhe.xyz/categories/product/"/>
    
    
      <category term="产品" scheme="https://0xkevinhe.xyz/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验" scheme="https://0xkevinhe.xyz/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>读一首诗——纪伯伦《孩子》</title>
    <link href="https://0xkevinhe.xyz/on-children.html"/>
    <id>https://0xkevinhe.xyz/on-children.html</id>
    <published>2016-10-07T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.159Z</updated>
    
    <content type="html"><![CDATA[<p>今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（Kahlil Gibran）的《孩子》，很有感触。将冰心的译文和原文奉上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">孩　　子</span><br><span class="line"> </span><br><span class="line">你们的孩子，都不是你们的孩子。</span><br><span class="line">乃是生命为自己所渴望的儿女。</span><br><span class="line">他们是凭借你们而来，却不是从你们而来，</span><br><span class="line">他们虽和你们同在，却不属于你们。</span><br><span class="line"></span><br><span class="line">你们可以给他们以爱，却不可给他们以思想。</span><br><span class="line">因为他们有自己的思想。</span><br><span class="line">你们可以荫庇他们的身体，却不能荫庇他们的灵魂。</span><br><span class="line">因为他们的灵魂，是住在明日的宅中，那是你们在梦中也不能想见的。</span><br><span class="line">你们可以努力去模仿他们，却不能使他们来象你们。</span><br><span class="line">因为生命是不倒行的，也不与昨日一同停留。</span><br><span class="line">你们是弓，你们的孩子是从弦上发出的生命的箭矢。</span><br><span class="line">那射者在无穷之中看定了目标，也用神力将你们引满，使他的箭矢迅速而遥远地射了出去。</span><br><span class="line">让你们在射者手中的弯曲成为喜乐罢；</span><br><span class="line">因为他爱那飞出的箭，也爱了那静止的弓。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">On Children</span><br><span class="line"></span><br><span class="line">Your children are not your children.</span><br><span class="line">They are the sons and daughters of Life's longing for itself.</span><br><span class="line">They come through you but not from you,</span><br><span class="line">And though they are with you yet they belong not to you.</span><br><span class="line"></span><br><span class="line">You may give them your love but not your thoughts, </span><br><span class="line">For they have their own thoughts.</span><br><span class="line">You may house their bodies but not their souls,</span><br><span class="line">For their souls dwell in the house of tomorrow, </span><br><span class="line">which you cannot visit, not even in your dreams.</span><br><span class="line">You may strive to be like them, </span><br><span class="line">but seek not to make them like you.</span><br><span class="line">For life goes not backward nor tarries with yesterday.</span><br><span class="line"></span><br><span class="line">You are the bows from which your children</span><br><span class="line">as living arrows are sent forth.</span><br><span class="line">The archer sees the mark upon the path of the infinite, </span><br><span class="line">and He bends you with His might </span><br><span class="line">that His arrows may go swift and far.</span><br><span class="line">Let your bending in the archer's hand be for gladness;</span><br><span class="line">For even as He loves the arrow that flies, </span><br><span class="line">so He loves also the bow that is stable.</span><br></pre></td></tr></table></figure><p>这首诗，来自纪伯伦的名作《先知》。</p><p>相信每一个人，在不同的阶段，读到这首诗的感受，是不一样的。</p><p>年少的时候，觉得父母老师管束自己，想要自由，可能会以此诗句来抗争——看，纪伯伦说了……。</p><p>长大了，离开父母上学，父母还是希望给更多的意见，你却总觉得父母的意见不合时宜。</p><p>工作了，经济自由了，在享受自由的那一瞬间，却开始想父母了。你慢慢的发现，自己身上的思想与习惯，很多都是源自来自父母。</p><p>若干年后，父母在你该找谁结婚这事儿上，干预未果，你想，抗争终于成功了。</p><p>不久，你也终于为人父母，才感叹，当父母真不容易。既当弓，又为箭。</p><p>再过若干年，自己的孩子也到了叛逆期，你还是希望像当年自己的父母一样，把自己曾经犯过的错，提前告诉孩子。</p><p>你却发现，每个人该犯的错误，该趟的坑，一个都少不了。你，却只能在旁边看着，就像当年你的父母一样。</p><p>孩子终于活出了自己的世界，你发现，原来每一个人都有自己的命运，只要努力，还是有机会。</p><p>每个人的每个阶段，都有自己的局限和使命。努力，活在当下就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（Kahlil Gibran）的《孩子》，很有感触。将冰心的译文和原文奉上。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SDK 开发最佳实践之一：为你的 SDK 增加 No-Op 版本</title>
    <link href="https://0xkevinhe.xyz/sdk-noop.html"/>
    <id>https://0xkevinhe.xyz/sdk-noop.html</id>
    <published>2016-09-29T03:20:30.000Z</published>
    <updated>2023-09-27T07:01:22.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔者在开发和维护 Bugtags SDK 的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK 开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags 这样快速成长的 SDK。</p></blockquote><h1 id="SDK-的使用场景"><a href="#SDK-的使用场景" class="headerlink" title="SDK 的使用场景"></a>SDK 的使用场景</h1><p>站在用户的角度来看，引入一个 SDK 可能会带来几方面的问题：</p><ul><li>包增大</li><li>可能不稳定</li><li>安全性问题</li></ul><p>对于一些 SDK，产品形态是允许在测试阶段开启，上线移除的，例如性能调试工具，测试工具等。</p><h1 id="区分版本方案"><a href="#区分版本方案" class="headerlink" title="区分版本方案"></a>区分版本方案</h1><p>最简单的，就是手动注释代码，应用中如果只使用了这个 SDK 的一个 API，那还好，如果用到了多个，分布在不同的文件中，<br>这事儿就麻烦了。很不优雅。</p><h1 id="最优雅的方案"><a href="#最优雅的方案" class="headerlink" title="最优雅的方案"></a>最优雅的方案</h1><p>思考一下这个需求</p><ul><li>应用分为 debug/release 版本</li><li>无痛切换，最好能够实现自动化</li></ul><p>大部分的编译系统，例如 Gradle/Maven 都可以区分版本，引入不同的包。利用这个特性，我们可以实现一个 No-Op SDK。</p><p>这个 SDK 具有如下特点：</p><ul><li>具有正式 SDK 的所有可以被外部引用的类</li><li>具有正式 SDK 的所有对外 API</li><li>足够的精简</li><li>提示正在使用 No-Op SDK</li></ul><h1 id="最后的结果"><a href="#最后的结果" class="headerlink" title="最后的结果"></a>最后的结果</h1><p>以 bugtags 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile 'com.bugtags.library:bugtags-lib:2.0.0'</span><br><span class="line">releaseCompile 'com.bugtags.library:bugtags-noop:2.0.0'</span><br></pre></td></tr></table></figure><p>以 leakcanary 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5'</span><br><span class="line">releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>如果你是一个 SDK 的使用者，即便官方没有提供 No-Op 版本，你完全可以自己写一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;笔者在开发和维护 Bugtags SDK 的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK 开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags 这样快速成长的 SDK。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="SDK" scheme="https://0xkevinhe.xyz/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 构建系统·初探</title>
    <link href="https://0xkevinhe.xyz/gradle-build-system-overview.html"/>
    <id>https://0xkevinhe.xyz/gradle-build-system-overview.html</id>
    <published>2016-08-13T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.156Z</updated>
    
    <content type="html"><![CDATA[<p>8月7号，应<a href="http://www.chinagdg.com/thread-3462-1-1.html">北京 GDG</a> 邀请，我做了一个题为《Android Gradle 构建系统·初探》的分享。</p><p>主要内容是构建系统背景知识，源码库，代码亮点，写插件。</p><p>很明显这是一个很大的话题，有超过 2.5GB 的核心代码和超过50个子项目。</p><p>第一步，我进行了宏观的介绍。下一步，我会继续深入子项目，尝试发现更多有意思的点。</p><p>对这个话题感兴趣的，请加入技术交流 qq 群：583688711。</p><p>Slides 在下面，分别是 PDF 版本和图片版本。</p><p><a href="https://raw.githubusercontent.com/changbinhe/images/master/static/Android%20Gradle%20Build%20System-Overview-wide-screen.pdf">PDF here</a>.</p><p>图片：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.001.jpeg" alt="Android-Gradle-Build-System-Overview.001.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.002.jpeg" alt="Android-Gradle-Build-System-Overview.002.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.003.jpeg" alt="Android-Gradle-Build-System-Overview.003.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.004.jpeg" alt="Android-Gradle-Build-System-Overview.004.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.005.jpeg" alt="Android-Gradle-Build-System-Overview.005.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.006.jpeg" alt="Android-Gradle-Build-System-Overview.006.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.007.jpeg" alt="Android-Gradle-Build-System-Overview.007.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.008.jpeg" alt="Android-Gradle-Build-System-Overview.008.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.009.jpeg" alt="Android-Gradle-Build-System-Overview.009.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.010.jpeg" alt="Android-Gradle-Build-System-Overview.010.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.011.jpeg" alt="Android-Gradle-Build-System-Overview.011.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.012.jpeg" alt="Android-Gradle-Build-System-Overview.012.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.013.jpeg" alt="Android-Gradle-Build-System-Overview.013.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.014.jpeg" alt="Android-Gradle-Build-System-Overview.014.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.015.jpeg" alt="Android-Gradle-Build-System-Overview.015.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.016.jpeg" alt="Android-Gradle-Build-System-Overview.016.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.017.jpeg" alt="Android-Gradle-Build-System-Overview.017.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.018.jpeg" alt="Android-Gradle-Build-System-Overview.018.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.019.jpeg" alt="Android-Gradle-Build-System-Overview.019.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.020.jpeg" alt="Android-Gradle-Build-System-Overview.020.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.021.jpeg" alt="Android-Gradle-Build-System-Overview.021.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.022.jpeg" alt="Android-Gradle-Build-System-Overview.022.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.023.jpeg" alt="Android-Gradle-Build-System-Overview.023.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.024.jpeg" alt="Android-Gradle-Build-System-Overview.024.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.025.jpeg" alt="Android-Gradle-Build-System-Overview.025.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.026.jpeg" alt="Android-Gradle-Build-System-Overview.026.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.027.jpeg" alt="Android-Gradle-Build-System-Overview.027.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.028.jpeg" alt="Android-Gradle-Build-System-Overview.028.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.029.jpeg" alt="Android-Gradle-Build-System-Overview.029.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.030.jpeg" alt="Android-Gradle-Build-System-Overview.030.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.031.jpeg" alt="Android-Gradle-Build-System-Overview.031.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.032.jpeg" alt="Android-Gradle-Build-System-Overview.032.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.033.jpeg" alt="Android-Gradle-Build-System-Overview.033.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.034.jpeg" alt="Android-Gradle-Build-System-Overview.034.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.035.jpeg" alt="Android-Gradle-Build-System-Overview.035.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.036.jpeg" alt="Android-Gradle-Build-System-Overview.036.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.037.jpeg" alt="Android-Gradle-Build-System-Overview.037.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.038.jpeg" alt="Android-Gradle-Build-System-Overview.038.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.039.jpeg" alt="Android-Gradle-Build-System-Overview.039.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.040.jpeg" alt="Android-Gradle-Build-System-Overview.040.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.041.jpeg" alt="Android-Gradle-Build-System-Overview.041.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.042.jpeg" alt="Android-Gradle-Build-System-Overview.042.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.043.jpeg" alt="Android-Gradle-Build-System-Overview.043.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.044.jpeg" alt="Android-Gradle-Build-System-Overview.044.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.045.jpeg" alt="Android-Gradle-Build-System-Overview.045.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.046.jpeg" alt="Android-Gradle-Build-System-Overview.046.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.047.jpeg" alt="Android-Gradle-Build-System-Overview.047.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.048.jpeg" alt="Android-Gradle-Build-System-Overview.048.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.049.jpeg" alt="Android-Gradle-Build-System-Overview.049.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.050.jpeg" alt="Android-Gradle-Build-System-Overview.050.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.051.jpeg" alt="Android-Gradle-Build-System-Overview.051.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.052.jpeg" alt="Android-Gradle-Build-System-Overview.052.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.053.jpeg" alt="Android-Gradle-Build-System-Overview.053.jpeg"><br><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.054.jpeg" alt="Android-Gradle-Build-System-Overview.054.jpeg"></p><blockquote><p>有问题？在文章下留言或者加 qq 群：583688711，希望能帮到你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;8月7号，应&lt;a href=&quot;http://www.chinagdg.com/thread-3462-1-1.html&quot;&gt;北京 GDG&lt;/a&gt; 邀请，我做了一个题为《Android Gradle 构建系统·初探》的分享。&lt;/p&gt;
&lt;p&gt;主要内容是构建系统背景知识，源码库，代
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="Gradle" scheme="https://0xkevinhe.xyz/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 技巧之二： 最爱命令行</title>
    <link href="https://0xkevinhe.xyz/gradle-indepth-cmd.html"/>
    <id>https://0xkevinhe.xyz/gradle-indepth-cmd.html</id>
    <published>2016-06-04T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.158Z</updated>
    
    <content type="html"><![CDATA[<p>如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>很多做 Android 开发不久的同学，习惯于使用图形界面，对命令行操作很陌生甚至恐惧。遇到 AS 运行错误，束手无策。</p><p>AS 为了确保易用性，也在 UI 界面上屏蔽了很多命令行运行的细节，导致很多人觉得 AS 难用。</p><p>这种情况，我在解决用户集成使用 Bugtags SDK 的问题的时候，经常能遇到。其实 GUI 界面的操作，绝大部分情况下，也是基于命令工具的。如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。</p><h1 id="典型错误"><a href="#典型错误" class="headerlink" title="典型错误"></a>典型错误</h1><p>AS 刚推出的时候，stackoverflow 上询问最多的问题，便是进入项目的时候，一直处于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gradle: resolve dependancies '_debugCompile'</span><br></pre></td></tr></table></figure><p>状态，一直无法前进，到底 IDE 在做什么呢？看不出来。</p><h1 id="一句命令行"><a href="#一句命令行" class="headerlink" title="一句命令行"></a>一句命令行</h1><p>当用户遇到问题时，我最常提醒用户使用的是在项目根目录下，运行如下命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac:</span><br><span class="line">./gradlew clean build --info > bugtags.log</span><br><span class="line"></span><br><span class="line">windows:</span><br><span class="line">gradlew.bat clean build --info > bugtags.log</span><br></pre></td></tr></table></figure><p>这个命令行的意思，是运行 clean 和 build 两个 gradle task，并且打开 info 参数使得输出更多的信息，最终把所有输出的信息，输出到项目根目录下的 bugtags.log 文件。用户把这个文件发给我，我根据这个输出文件，通常就能分析出问题所在。</p><p>假设命令行去除重定向输指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean build --info</span><br></pre></td></tr></table></figure><p>信息将会输出在控制台，刚才提到的那个典型错误，可能是这样的：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-5/15681897.jpg" alt="cmd-output"></p><p>其实是在下载一个比较大的文件，不用惊慌，你要做的就是 just wait! 至于是在下载什么。我想在下一篇详细描述。</p><p>如果你对基本的命令行知识有所了解，前面就已经足够了，如果你想了解更多，请继续。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="在哪运行"><a href="#在哪运行" class="headerlink" title="在哪运行"></a>在哪运行</h2><p>当我给出这个命令的时候，最常见的问题，就是在哪运行。答案是控制台（Terminal）。</p><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><p>在 mac 下，有 terminal（bash/zsh 等），在 windows 下，则是 powershell 或者 cmd。</p><p>关键一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>AS 在使用 Gradle 的时候，为了灵活，或者为了应对 Gradle 系统的快速迭代，推荐使用在项目根目录中放置 Gradle 的 wrapper：gradlew 来实现对不同版本的使用。</p></blockquote><p>因此，在控制台运行命令，主要是跟 <code>gradlew</code> 打交道。这个 wrapper，在 mac 下是一个具有执行权限的文件：<code>gradlew</code>，在 windows 下，是一个批处理文件：<code>gradlew.bat</code>。</p><p>通常，mac 下在当前目录下运行可执行文件是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew xxx</span><br></pre></td></tr></table></figure><p>windows 下在当前目录下运行批处理文件是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew.bat xxx</span><br></pre></td></tr></table></figure><h3 id="Terminal-插件"><a href="#Terminal-插件" class="headerlink" title="Terminal 插件"></a>Terminal 插件</h3><p>AS（Intellij IDEA）已经做了一个很实用的插件：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-5/3873932.jpg" alt="as-terminal"></p><p>点击 Terminal，AS 会帮你完成下面的操作：</p><ul><li>模拟打开 terminal</li><li>cd 到当前项目根目录下</li></ul><h3 id="快速定位文件夹"><a href="#快速定位文件夹" class="headerlink" title="快速定位文件夹"></a>快速定位文件夹</h3><p>IDE 还支持将项目中的某个文件夹拖放到 Terminal 窗口中实现快速定位到这个文件夹：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-5/94595004.jpg" alt="terminal-drag-location"></p><h2 id="使用-help"><a href="#使用-help" class="headerlink" title="使用 help"></a>使用 help</h2><p>要知道都有哪些 gradle 命令运行的参数，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew --help</span><br><span class="line"></span><br><span class="line">USAGE: gradlew [option...] [task...]</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来获取。下面列举几个重要的参数。</p><h2 id="build-某个指定-module"><a href="#build-某个指定-module" class="headerlink" title="build 某个指定 module"></a>build 某个指定 module</h2><p>AS 推荐的结构是 <code>multiple project</code> 结构，即一个 project 下，管理多个 module，如果每次都要 build 全部的 project 的话，有点浪费时间，则可以使用 <code>-p module</code> 参数，其中 module 是你要 build 的 module：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app clean build</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="明确指定不执行某个-task"><a href="#明确指定不执行某个-task" class="headerlink" title="明确指定不执行某个 task"></a>明确指定不执行某个 task</h2><p>Gradle 的命令存在依赖，例如 build task，是依赖于一系列的其他的 task，如果想要指定不执行某个 task，则可以使用 <code>-x task</code> 参数，其中 task 是要忽略的那个，这个参数可以传递多次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew build -x test -x lint</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Gradle 的命令行还有很多其他技巧，上面只是列举到了本人日常用到最多的几个。有兴趣可以留言深入讨论。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/stpeace/article/details/9021641">mac-terminal</a></p><p><a href="http://blog.csdn.net/stpeace/article/details/9021641">windows-terminal</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。&lt;/p&gt;
&lt;h1 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h1&gt;&lt;p&gt;很多做 Android 开发不久的同学，习惯于使用图形界面
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="Gradle 技巧" scheme="https://0xkevinhe.xyz/tags/Gradle-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 技巧之一： Build Variant 相关</title>
    <link href="https://0xkevinhe.xyz/gradle-indepth-build-variant.html"/>
    <id>https://0xkevinhe.xyz/gradle-indepth-build-variant.html</id>
    <published>2016-06-03T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Build-Variant"><a href="#Build-Variant" class="headerlink" title="Build Variant"></a>Build Variant</h1><p>android gradle 插件，允许对最终的包以多个维度进行组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuildVariant = ProductFlavor x BuildType</span><br></pre></td></tr></table></figure><h2 id="两个维度"><a href="#两个维度" class="headerlink" title="两个维度"></a>两个维度</h2><p>最常见的就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">productFlavors {</span><br><span class="line">    pro {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fre {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">lintOptions {</span><br><span class="line">    abortOnError false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buildTypes {</span><br><span class="line">    debug {</span><br><span class="line">    }</span><br><span class="line">    release {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>其中，buildTypes 一般都会有 debug 或者release，标示编译的类型，通常在混淆代码、可调式、资源压缩上做一些区分。<br>productFlavor 则为了满足“同一个project，根据一个很小的区分，来打不同的包”这个需求。</p><p>这两个维度的组合，会产生如下包：</p><ul><li>proDebug</li><li>proRelease</li><li>freDebug</li><li>proRelease</li></ul><h2 id="更多的维度"><a href="#更多的维度" class="headerlink" title="更多的维度"></a>更多的维度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions 'abi', 'version'</span><br><span class="line"></span><br><span class="line">productFlavors {</span><br><span class="line">    pro {</span><br><span class="line">        dimension 'version'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fre {</span><br><span class="line">        dimension 'version'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    arm {</span><br><span class="line">        dimension 'abi'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mips {</span><br><span class="line">        dimension 'abi'</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buildTypes {</span><br><span class="line">    debug {</span><br><span class="line">    }</span><br><span class="line">    release {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>productFlavor 本身定义了2个维度，记上 buildType，则有三个维度，会产生如下的包：</p><ul><li>armProDebug</li><li>armProRelease</li><li>armFreDebug</li><li>armFreRelease</li><li>mipsProDebug</li><li>mipsProRelease</li><li>mipsFreDebug</li><li>mipsFreRelease</li></ul><p>其中每个维度组合，都可以设置本身的 dependency、test source。下面做一个举例。</p><h1 id="Flavor-与-Dependency"><a href="#Flavor-与-Dependency" class="headerlink" title="Flavor 与 Dependency"></a>Flavor 与 Dependency</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>module 中有若干个 flavors，例如：fre 和 pro，分别依赖不同的库，这些库有的是本地 jar 库，有的是远程库。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-3/75851013.jpg?imageView2/2/w/640/h/640" alt="flavor-dependency"></p><h1 id="遍历-Build-Variant"><a href="#遍历-Build-Variant" class="headerlink" title="遍历 Build Variant"></a>遍历 Build Variant</h1><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>Bugtags 的 android sdk，有一个自动上传符号表功能， 在最初，是这样配置的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.bugtags.library.plugin'</span><br><span class="line">bugtags {</span><br><span class="line">    appKey "APP_KEY"</span><br><span class="line">    appSecret  "APP_SECRET"</span><br><span class="line">    mappingUploadEnabled false</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>后来，我们增加了一个 beta-live 的机制，用来区分测试和上线的 APP，这样，同一个 APP，就有两套 APP_KEY 和 APP_SECRET 了，很明显上方的配置方式就不在适用。</p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><p>android gradle 插件提供了 android.applicationVariants 索引来遍历所有的 build variant<br>后来，我们采取了一个方案，遍历 Build Variant，设置 extension 信息来兼容这种需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate {</span><br><span class="line">    android.applicationVariants.each { variant -></span><br><span class="line">        def bugtagsAppKey = null;</span><br><span class="line">        def bugtagsAppSecret = null;</span><br><span class="line"></span><br><span class="line">        if (variant.name.contains("debug")) {</span><br><span class="line">            bugtagsAppKey = 'APP_KEY_BETA'</span><br><span class="line">            bugtagsAppSecret = 'APP_SECRET_BETA'</span><br><span class="line">        } else if (variant.name.contains("release")) {</span><br><span class="line">            bugtagsAppKey = 'APP_KEY_LIVE'</span><br><span class="line">            bugtagsAppSecret = 'APP_SECRET_LIVE'</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        variant.ext.bugtagsAppKey = bugtagsAppKey</span><br><span class="line">        variant.ext.bugtagsAppSecret = bugtagsAppSecret</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: 'com.bugtags.library.plugin'</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要是介绍了 build variant 的概念，还介绍了两个日常应用案例。希望对大家有帮助。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://tools.android.com/tech-docs/new-build-system">android-build-tool</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Build-Variant&quot;&gt;&lt;a href=&quot;#Build-Variant&quot; class=&quot;headerlink&quot; title=&quot;Build Variant&quot;&gt;&lt;/a&gt;Build Variant&lt;/h1&gt;&lt;p&gt;android gradle 插件，允许对最终的包以
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="Gradle 技巧" scheme="https://0xkevinhe.xyz/tags/Gradle-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>拥抱 Android Studio 之五：Gradle 插件开发</title>
    <link href="https://0xkevinhe.xyz/embrace-android-studio-gradle-plugin.html"/>
    <id>https://0xkevinhe.xyz/embrace-android-studio-gradle-plugin.html</id>
    <published>2016-03-28T03:20:30.000Z</published>
    <updated>2023-09-27T07:01:22.150Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html">官方文档</a>给出了比较详细的实现步骤，本文的脉络会跟官方文档差不了太多，额外增补实际例子和一些实践经验。文中的代码已经托管到了 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo">github 项目</a>中。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>默认的 Android 打包插件会把 apk 命名成 <code>module-productFlavor-buildType.apk</code>，例如 <code>app-official-debug.apk</code>，并且会把包文件发布到固定的位置： <code>module/build/outputs/apk</code> 有的时候，这个命名风格并不是你所要的，你也想讲 apk 输出到别的目录。咱们通过 gradle 插件来实现自定义。这个插件的需求是：</p><ul><li>输入一个名为 nameMap 的 Closure，用来修改 apk 名字</li><li>输入一个名为 destDir 的 String，用于输出位置</li></ul><h1 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h1><h2 id="插件之于-Gradle"><a href="#插件之于-Gradle" class="headerlink" title="插件之于 Gradle"></a>插件之于 Gradle</h2><p>根据官方文档定义，插件打包了可重用的构建逻辑，可以适用于不同的项目和构建过程。</p><p>Gradle 提供了很多官方插件，用于支持 Java、Groovy 等工程的构建和打包。同时也提供了自定义插件的机制，让每个人都可以通过插件来实现特定的构建逻辑，并可以把这些逻辑打包起来，分享给其他人。</p><p>插件的源码可以使用 Groovy、Scala、Java 三种语言，笔者不会 Scala，所以平时只是使用 Groovy 和 Java。前者用于实现与 Gradle 构建生命周期（如 task 的依赖）有关的逻辑，后者用于核心逻辑，表现为 Groovy 调用 Java 的代码。</p><p>另外，还有很多项目使用 Eclipse 或者 Maven 进行开发构建，用 Java 实现核心业务代码，将有利于实现快速迁移。</p><h2 id="插件打包方式"><a href="#插件打包方式" class="headerlink" title="插件打包方式"></a>插件打包方式</h2><p>Gradle 的插件有三种打包方式，主要是按照复杂程度和可见性来划分：</p><h3 id="Build-script"><a href="#Build-script" class="headerlink" title="Build script"></a>Build script</h3><p>把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见，笔者常用来做原型调试，本文将简要介绍此类。</p><h3 id="buildSrc-项目"><a href="#buildSrc-项目" class="headerlink" title="buildSrc 项目"></a>buildSrc 项目</h3><p>将插件源代码放在 <code>rootProjectDir/buildSrc/src/main/groovy</code> 中，只对该项目中可见，适用于逻辑较为复杂，但又不需要外部可见的插件，本文不介绍，有兴趣可以参考<a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html#sec:build_sources">此处</a>。</p><h3 id="独立项目"><a href="#独立项目" class="headerlink" title="独立项目"></a>独立项目</h3><p>一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。</p><h1 id="Build-script-插件"><a href="#Build-script-插件" class="headerlink" title="Build script 插件"></a>Build script 插件</h1><p>首先来直接在 build.gradle 中写一个 plugin：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistPlugin implements Plugin<Project> {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line">        project.task('apkdist') << {</span><br><span class="line">            println 'hello, world!'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: ApkDistPlugin</span><br></pre></td></tr></table></figure><p>命令行运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app/ apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure><p>这个插件创建了一个名为 <code>apkdist</code> 的 task，并在 task 中打印。</p><p>插件是一个类，继承自 <code>org.gradle.api.Plugin</code> 接口，重写 <code>void apply(Project project)</code> 方法，这个方法将会传入使用这个插件的 project 的实例，这是一个重要的 context。</p><h2 id="接受外部参数"><a href="#接受外部参数" class="headerlink" title="接受外部参数"></a>接受外部参数</h2><p>通常情况下，插件使用方需要传入一些配置参数，如 bugtags 的 SDK 的插件需要接受两个参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bugtags {</span><br><span class="line">    appKey "APP_KEY"  //这里是你的 appKey</span><br><span class="line">    appSecret "APP_SECRET"    //这里是你的 appSecret，管理员在设置页可以查看</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>同样，ApkDistPlugin 这个 plugin 也希望接受两个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apkdistconf {</span><br><span class="line">    nameMap { name -></span><br><span class="line">        println 'hello,' + name</span><br><span class="line">        return name</span><br><span class="line">    }</span><br><span class="line">    destDir 'your-distribution-dir'</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>参数的内容后面继续完善。那这两个参数怎么传到插件内呢？</p><p><code>org.gradle.api.Project</code> 有一个 <code>ExtensionContainer getExtensions()</code> 方法，可以用来实现这个传递。</p><h3 id="声明参数类"><a href="#声明参数类" class="headerlink" title="声明参数类"></a>声明参数类</h3><p>声明一个 Groovy 类，有两个默认值为 null 的成员变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistExtension {</span><br><span class="line">    Closure nameMap = null;</span><br><span class="line">    String destDir = null;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="接受参数"><a href="#接受参数" class="headerlink" title="接受参数"></a>接受参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.extensions.create('apkdistconf', ApkDistExtension);</span><br></pre></td></tr></table></figure><p>要注意，<code>create</code> 方法的第一个参数就是你在 build.gradle 文件中的进行参数配置的 dsl 的名字，必须一致；第二个参数，就是参数类的名字。</p><h3 id="获取和使用参数"><a href="#获取和使用参数" class="headerlink" title="获取和使用参数"></a>获取和使用参数</h3><p>在 create 了 extension 之后，如果传入了参数，则会携带在 project 实例中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def closure = project['apkdistconf'].nameMap;</span><br><span class="line">closure('wow!');</span><br><span class="line"></span><br><span class="line">println project['apkdistconf'].destDir</span><br></pre></td></tr></table></figure><h3 id="进化版本一：参数"><a href="#进化版本一：参数" class="headerlink" title="进化版本一：参数"></a>进化版本一：参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistExtension {</span><br><span class="line">    Closure nameMap = null;</span><br><span class="line">    String destDir = null;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ApkDistPlugin implements Plugin<Project> {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line"></span><br><span class="line">        project.extensions.create('apkdistconf', ApkDistExtension);</span><br><span class="line"></span><br><span class="line">        project.task('apkdist') << {</span><br><span class="line">            println 'hello, world!'</span><br><span class="line"></span><br><span class="line">            def closure = project['apkdistconf'].nameMap;</span><br><span class="line">            closure('wow!');</span><br><span class="line"></span><br><span class="line">            println project['apkdistconf'].destDir</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: ApkDistPlugin</span><br><span class="line"></span><br><span class="line">apkdistconf {</span><br><span class="line">    nameMap { name -></span><br><span class="line">        println 'hello, ' + name</span><br><span class="line">        return name</span><br><span class="line">    }</span><br><span class="line">    destDir 'your-distribution-directory'</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app/ apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br><span class="line">hello, wow!</span><br><span class="line">your-distribution-directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="独立项目插件"><a href="#独立项目插件" class="headerlink" title="独立项目插件"></a>独立项目插件</h1><p>代码写到现在，已经不适合再放在一个 build.gradle 文件里面了，那也不是我们的目的。建立一个独立项目，把代码搬到对应的地方。</p><p>理论上，IntelliJ IDEA 开发插件要比 Android Studio 要方便一点点，因为有对应 Groovy module 的模板。但其实如果我们了解 IDEA 的项目文件结构，就不会受到这个局限，无非就是一个 build.gradle 构建文件加 src 源码文件夹。</p><p>最终项目的文件夹结构是这样：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-3-4/6224454.jpg" alt="Java-Library"></p><p>下面我们来一步步讲解。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在 Android Studio 中新建 <code>Java Library</code> module <code>“plugin”</code>。</p><h2 id="修改-build-gradle-文件"><a href="#修改-build-gradle-文件" class="headerlink" title="修改 build.gradle 文件"></a>修改 build.gradle 文件</h2><p>添加 Groovy 插件和对应的两个依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//removed java plugin </span><br><span class="line">apply plugin: 'groovy'</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line">    compile gradleApi()//gradle sdk</span><br><span class="line">    compile localGroovy()//groovy sdk</span><br><span class="line">    compile fileTree(dir: 'libs', include: ['*.jar'])</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="修改项目文件夹"><a href="#修改项目文件夹" class="headerlink" title="修改项目文件夹"></a>修改项目文件夹</h2><p>src/main 项目文件下：</p><ul><li>移除 java 文件夹，因为在这个项目中用不到 java 代码</li><li>添加 groovy 文件夹，主要的代码文件放在这里</li><li>添加 resources 文件夹，存放用于标识 gradle 插件的 meta-data</li></ul><h2 id="建立对应文件"><a href="#建立对应文件" class="headerlink" title="建立对应文件"></a>建立对应文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── libs</span><br><span class="line">├── plugin.iml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── groovy</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── asgradle</span><br><span class="line">        │           └── plugin</span><br><span class="line">        │               ├── ApkDistExtension.groovy</span><br><span class="line">        │               └── ApkDistPlugin.groovy</span><br><span class="line">        └── resources</span><br><span class="line">            └── META-INF</span><br><span class="line">                └── gradle-plugins</span><br><span class="line">                    └── com.asgradle.apkdist.properties</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>groovy 文件夹中的类，一定要修改成 <code>.groovy</code> 后缀，IDE 才会正常识别。</li><li>resources/META-INF/gradle-plugins 这个文件夹结构是强制要求的，否则不能识别成插件。</li></ul><h2 id="com-asgradle-apkdist-properties-文件"><a href="#com-asgradle-apkdist-properties-文件" class="headerlink" title="com.asgradle.apkdist.properties 文件"></a>com.asgradle.apkdist.properties 文件</h2><p>如果写过 Java 的同学会知道，这是一个 Java 的 properties 文件，是 <code>key=value</code> 的格式。这个文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.asgradle.plugin.ApkDistPlugin</span><br></pre></td></tr></table></figure><p>按其语义推断，是指定这个插件的入口类。</p><ul><li><p>英文敏感的同学可能会问了，为什么这个文件的承载文件夹是叫做 <code>gradle-plugins</code>，使用复数？没错，这里可以指定多个 properties 文件，定义多个插件，扩展性一流，可以参考 <a href="https://github.com/linkedin/gradle-plugins/tree/master/buildSrc/src/main/resources/META-INF/gradle-plugins">linkedin</a> 的插件的组织方式。</p></li><li><p>使用这个插件的时候，将会是这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:'com.asgradle.apkdist'</span><br></pre></td></tr></table></figure></li></ul><p>因此，<code>com.asgradle.apkdist</code> 这个字符串在这里，又称为这个插件的 id，不允许跟别的插件重复，取你拥有的域名的反向就不会错。</p><h2 id="将-plugin-module-传到本地-maven-仓库"><a href="#将-plugin-module-传到本地-maven-仓库" class="headerlink" title="将 plugin module 传到本地 maven 仓库"></a>将 plugin module 传到本地 maven 仓库</h2><p>参考上一篇：<a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建</a>，和对应的 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/tree/master/S4-MavenDeploy">demo 项目</a>，将包传到本地仓库中进行测试。</p><h3 id="添加-gradle-properties"><a href="#添加-gradle-properties" class="headerlink" title="添加 gradle.properties"></a>添加 gradle.properties</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PROJ_NAME=gradleplugin</span><br><span class="line">PROJ_ARTIFACTID=gradleplugin</span><br><span class="line">PROJ_POM_NAME=Local Repository</span><br><span class="line"></span><br><span class="line">LOCAL_REPO_URL=file:///Users/changbinhe/Documents/Android/repo/</span><br><span class="line"></span><br><span class="line">PROJ_GROUP=com.as-gradle.demo</span><br><span class="line"></span><br><span class="line">PROJ_VERSION=1.0.0</span><br><span class="line">PROJ_VERSION_CODE=1</span><br><span class="line"></span><br><span class="line">PROJ_WEBSITEURL=http://kvh.io</span><br><span class="line">PROJ_ISSUETRACKERURL=https://github.com/kevinho/Embrace-Android-Studio-Demo/issues</span><br><span class="line">PROJ_VCSURL=https://github.com/kevinho/Embrace-Android-Studio-Demo.git</span><br><span class="line">PROJ_DESCRIPTION=demo apps for embracing android studio</span><br><span class="line"></span><br><span class="line">PROJ_LICENCE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">PROJ_LICENCE_DEST=repo</span><br><span class="line"></span><br><span class="line">DEVELOPER_ID=your-dev-id</span><br><span class="line">DEVELOPER_NAME=your-dev-name</span><br><span class="line">DEVELOPER_EMAIL=your-email@your-mailbox.com</span><br></pre></td></tr></table></figure><h3 id="在-build-gradle-添加上传功能"><a href="#在-build-gradle-添加上传功能" class="headerlink" title="在 build.gradle 添加上传功能"></a>在 build.gradle 添加上传功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'maven'</span><br><span class="line"></span><br><span class="line">uploadArchives {</span><br><span class="line">    repositories.mavenDeployer {</span><br><span class="line">        repository(url: LOCAL_REPO_URL)</span><br><span class="line">        pom.groupId = PROJ_GROUP</span><br><span class="line">        pom.artifactId = PROJ_ARTIFACTID</span><br><span class="line">        pom.version = PROJ_VERSION</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传可以通过运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p plugin/ clean build uploadArchives</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在-app-module-中使用插件"><a href="#在-app-module-中使用插件" class="headerlink" title="在 app module 中使用插件"></a>在 app module 中使用插件</h2><h3 id="在项目的-buildscript-添加插件作为-classpath"><a href="#在项目的-buildscript-添加插件作为-classpath" class="headerlink" title="在项目的 buildscript 添加插件作为 classpath"></a>在项目的 buildscript 添加插件作为 classpath</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript {</span><br><span class="line">    repositories {</span><br><span class="line">        maven{</span><br><span class="line">            url 'file:///Users/your-user-name/Documents/Android/repo/'</span><br><span class="line">        }</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">    dependencies {</span><br><span class="line">        classpath 'com.android.tools.build:gradle:2.1.0-alpha3'        </span><br><span class="line">        classpath 'com.as-gradle.demo:gradleplugin:1.0.0'</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="在-app-module-中使用插件："><a href="#在-app-module-中使用插件：" class="headerlink" title="在 app module 中使用插件："></a>在 app module 中使用插件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.asgradle.apkdist'</span><br></pre></td></tr></table></figure><p>命令行运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br><span class="line">hello, wow!</span><br><span class="line">your-distribution-directory</span><br></pre></td></tr></table></figure><h3 id="可能会遇到问题"><a href="#可能会遇到问题" class="headerlink" title="可能会遇到问题"></a>可能会遇到问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:(46, 0) Cause: com/asgradle/plugin/ApkDistPlugin : Unsupported major.minor version 52.0</span><br><span class="line"><a href="openFile:/Users/your-user-name/Documents/git/opensource/embrace-android-studio-demo/s5-GradlePlugin/app/build.gradle">Open File</a></span><br></pre></td></tr></table></figure><p>应该是本机的 JDK 版本是1.8，默认将 plugin module 的 groovy 源码编译成了1.8版本的 class 文件，放在 Android 项目中，无法兼容。需要对 plugin module 的 build.gradle 文件添加两个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceCompatibility = 1.6</span><br><span class="line">targetCompatibility = 1.6</span><br></pre></td></tr></table></figure><h1 id="真正的实现插件需求"><a href="#真正的实现插件需求" class="headerlink" title="真正的实现插件需求"></a>真正的实现插件需求</h1><p>读者可能会观察到，到目前为止，插件只是跑通了流程，并没有实现本文提出的两个需求，</p><p>那接下来就具体实现一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistPlugin implements Plugin<Project> {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line"></span><br><span class="line">        project.extensions.create('apkdistconf', ApkDistExtension);</span><br><span class="line"></span><br><span class="line">        project.afterEvaluate {</span><br><span class="line"></span><br><span class="line">//只可以在 android application 或者 android lib 项目中使用</span><br><span class="line">            if (!project.android) {</span><br><span class="line">                throw new IllegalStateException('Must apply \'com.android.application\' or \'com.android.library\' first!')</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">//配置不能为空</span><br><span class="line">            if (project.apkdistconf.nameMap == null || project.apkdistconf.destDir == null) {</span><br><span class="line">                project.logger.info('Apkdist conf should be set!')</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Closure nameMap = project['apkdistconf'].nameMap</span><br><span class="line">            String destDir = project['apkdistconf'].destDir</span><br><span class="line"></span><br><span class="line">//枚举每一个 build variant</span><br><span class="line">            project.android.applicationVariants.all { variant -></span><br><span class="line">                variant.outputs.each { output -></span><br><span class="line">                    File file = output.outputFile</span><br><span class="line">                    output.outputFile = new File(destDir, nameMap(file.getName()))</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>必须指出，本文插件实现的需求，其实可以直接在 app module 的 build.gradle 中写脚本就可以实现。这里做成插件，只是为了做示范。</p><p>上传到 bintray 的过程，就不再赘述了，可以参考<a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建</a>。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>至此，这系列开篇的时候挖下的坑，终于填完了。很多人借助这系列的讲解，真正理解了 Android Studio 和它背后的 Gradle、Groovy，笔者十分高兴。笔者也得到了很多读者的鼓励和支持，心中十分感激。</p><p>写博客真的是一个很讲究执行力和耐力的事情，但既然挖下了坑，就得填上，对吧？</p><p>这半年来，个人在 Android 和 Java 平台上也做了更多的事情，也有了更多的体会。</p><p>AS 系列，打算扩充几个主题：</p><ul><li>Proguard 混淆</li><li>Java & Android Testing</li><li>Maven 私有仓库深入</li><li>持续集成</li><li>……待发掘</li></ul><p>记得有人说，只懂 Android 不懂 Java，是很可怕的。在这半年以来，笔者在工作中使用 Java 实现了一些后端服务，也认真学习了 JVM 字节码相关的知识并把它使用到了工作中。在这个过程中，真的很为 Java 平台的活力、丰富的库资源、几乎无止境的可能性所折服。接下来，会写一些跟有关的学习体会，例如：</p><ul><li>Java 多线程与锁</li><li>JVM 部分原理</li><li>字节码操作</li><li>Java 8部分特性</li><li>……待学习</li></ul><p>随着笔者工作的进展，我也有机会学习使用了别的语言，例如 Node.js，并实现了一些后端服务。这个语言的活力很强，一些比 Java 现代的地方，很吸引人。有精力会写一写。</p><p>因为业务所需，笔者所经历的系统，正在处于像面向服务的演化过程中，我们期望建立统一的通讯平台和规范，抽象系统的资源，拆分业务，容器化。这是一个很有趣的过程，也是对我们的挑战。笔者也希望有机会与读者分享。</p><p>一不小心又挖下了好多明坑和无数暗坑，只是为了激励自己不断往前。在探索事物本质的旅途中，必然十分艰险，又十分有趣，沿途一定风光绚丽，让我们共勉。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html">官方文档</a></p><h1 id="系列导读"><a href="#系列导读" class="headerlink" title="系列导读"></a>系列导读</h1><p>本文是笔者《拥抱 Android Studio》系列第四篇，其他篇请点击：</p><p><a href="http://kvh.io/2015/12/01/embrace-android-studio-migration/">拥抱 Android Studio 之一：从 ADT 到 Android Studio</a></p><p><a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">拥抱 Android Studio 之二：Android Studio 与 Gradle 深入</a></p><p><a href="http://kvh.io/2016/01/04/embrace-android-studio-groovy-gradle/">拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础</a></p><p><a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建</a></p><p><a href="http://kvh.io/2016/03/28/embrace-android-studio-gradle-plugin/">拥抱 Android Studio 之五：Gradle 插件使用与开发</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。<br>想要及时收到最新博客文章，请关注：</p></blockquote><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>笔者 <a href="http://kvh.io/">kvh</a> 在开发和运营 <a href="https://bugtags.com/">bugtags.com</a>，这是一款移动时代首选的 bug 管理系统，能够极大的提升 app 开发者的测试效率，欢迎使用、转发推荐。</p><p>笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。</p><p>我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-1-29/87155741.jpg" alt="bugtags"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.gradle.org/current/userguide/custom_plugins.html&quot;&gt;官方文档&lt;/a&gt;给出了比较详细的实现步骤，本文的脉络会跟官方文档差不了太多，额外增补实际例子和一些实践经验。文中的代码已经托管到了
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="EmbraceAndroidStudio" scheme="https://0xkevinhe.xyz/tags/EmbraceAndroidStudio/"/>
    
      <category term="拥抱 Android Studio" scheme="https://0xkevinhe.xyz/tags/%E6%8B%A5%E6%8A%B1-Android-Studio/"/>
    
  </entry>
  
</feed>
