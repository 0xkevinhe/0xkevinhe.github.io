<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Changbin He&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kvh.io/"/>
  <updated>2021-06-13T17:39:04.319Z</updated>
  <id>https://kvh.io/</id>
  
  <author>
    <name>kvh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zksync 存储：sparse-merkle-tree 存储</title>
    <link href="https://kvh.io/sparse-merkle-tree.html"/>
    <id>https://kvh.io/sparse-merkle-tree.html</id>
    <published>2021-02-09T12:02:00.000Z</published>
    <updated>2021-06-13T17:39:04.319Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="简介">简介</h1><p>本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。</p><h1 id="merkle-tree">merkle tree</h1><p><a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">merkle tree</a> 常用于区块链存储数据和快速校验数据。其构造特点是叶节点使用数据的 hash 进行标记，中间节点使用所有子节点的 hash进行标记。</p><figure><img src="./sparse-merkle-tree/merkle-tree.png" alt="merkle-tree"><figcaption aria-hidden="true">merkle-tree</figcaption></figure><p>对于 merke tree 的操作，包含：插入节点、获取树根、计算 merkle 证明、检验 merkle 证明。</p><p>计算 merkle 证明包含：</p><p>1）计算存在证明</p><p>2）计算不存在证明</p><p>在原始的 merkle tree 上，很容易生成存在性证明，但是难以生成不存在证明。</p><h1 id="sparse-merkle-tree">sparse merkle tree</h1><p>为了解决这个问题，同时零知识证明也要求账号在树上的位置具有确定性，因此引入 sparse merkle tree，有如下特点：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵满二叉树</span><br><span class="line">数据是索引的，每个数据会放到对应的索引的叶子上</span><br><span class="line">存在性证明，merkle path</span><br><span class="line">不存在性证明，需要证明是 null</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure><h1 id="优化">优化</h1><p>1）预计算空值哈希</p><p>由于大部分情况下，树并不会真的满，而是非常的稀疏。可以预计算H(null)、H(H(null)|H(null))、H(H(H(null)|H(null))|H(H(null)|H(null)))等层级上上的值，达到加速的效果。</p><p>2）并行计算左右子树哈希</p><p>H(H(left)|H(right)) 这类操作要求 快速计算左右子树的哈希值，并行计算可以计算。</p><h1 id="实现">实现</h1><p>rust： https://github.com/matter-labs/zksync/blob/master/core/lib/crypto/src/merkle_tree/parallel_smt.rs</p><p>js： https://github.com/iden3/iden3js/blob/master/src/sparse-merkle-tree/sparse-merkle-tree.js</p><p>golang： https://github.com/iden3/go-iden3-core/blob/master/merkletree/merkletree.go</p><h1 id="文献参考">文献参考</h1><p>https://medium.com/<span class="citation" data-cites="kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837">@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837</span> https://blog.iden3.io/sparse-merkle-trees-visual-introduction.html</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。&lt;/p&gt;
&lt;h1 id=&quot;merkle-tree&quot;&gt;merkle tree&lt;/h1&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="zkp" scheme="https://kvh.io/tags/zkp/"/>
    
  </entry>
  
  <entry>
    <title>关于智能钱包</title>
    <link href="https://kvh.io/smart-wallet.html"/>
    <id>https://kvh.io/smart-wallet.html</id>
    <published>2021-01-13T01:58:57.000Z</published>
    <updated>2021-01-13T02:33:24.629Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>Vitalik 在 1-11 在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。</p><p>原文不赘述，下文将主要记录要点和思考。</p><h1 id="原文">原文</h1><p><a href="https://vitalik.ca/general/2021/01/11/recovery.html" target="_blank" rel="noopener">英文</a></p><p><a href="https://www.chainnews.com/articles/195564221840.htm" target="_blank" rel="noopener">中文</a></p><h1 id="要点">要点</h1><h2 id="guardian-的选择">guardian 的选择</h2><p>抵抗 guardian 联合作恶：</p><p>1）不公开</p><ul><li>对 list 进行哈希</li></ul><blockquote><p>fulllist，如何获得？</p></blockquote><ul><li>guardian 确定性的生成一个用于恢复的地址；只在需要恢复的时候用到一次；</li></ul><p>2）来自不同的 social circle</p><h2 id="对于加密价值的讨论">对于加密价值的讨论</h2><p>有一种论调认为，社交恢复，是恢复到了相信人，是对区块链和加密的背叛。</p><p>Vitalik 认为，加密不是移除所有的信任，其目的是提供更多的选择，来决定去相信谁；允许可控的信任：容许某些人代替做某些事，而没有能力做所有事。</p><h2 id="对抗小偷">对抗小偷</h2><p>sign key 可能丢失，可以增加一个保险柜功能，把 token 进入其中；在保险柜中的 token，交易可消。在发起交易和交易生效中间，增加了一个可撤回的缓冲期；还可以通过增加 vault 的可编程性支持更多的功能。</p><h2 id="argent-和路印等现行社交钱包的两大挑战">Argent 和路印等现行社交钱包的两大挑战</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）对中继的依赖</span><br><span class="line">2）交易费高</span><br></pre></td></tr></tbody></table></figure><p>目前的流行做法，是中继官方的签名的在链下进行，收集之后打包发送到服务器；</p><blockquote><p>对于这里的「收集」的概念有一定疑问； 假设一个用户有 7 个guardian，路印是收集齐了4 个guardian的签名，才发送到链上？</p></blockquote><h2 id="两大挑战的解决方案">两大挑战的解决方案：</h2><ul><li>当前改造方式</li></ul><p><a href="https://docs.opengsn.org/learn.html" target="_blank" rel="noopener">generalized decentralized relayer network</a></p><blockquote><p>以太坊加油站（与 heco 的元交易有异曲同工之处）</p></blockquote><p><a href="https://our.status.im/account-abstraction-eip-2938/" target="_blank" rel="noopener">allow transactions to begin from contracts</a></p><blockquote><p>修改以太坊协议，允许合约主动发起交易。</p></blockquote><ul><li>彻底改造方式：迁移到 layer2</li></ul><blockquote><p>为什么能解决问题？资金首先来自 1 层？在二层里面实现智能钱包逻辑？</p></blockquote><h1 id="思考">思考</h1><ol type="1"><li><p>如果是一个定制的链的场景，可以采用更激进的方式来改造链，是否可以定制一个对用户友好的钱包系统？</p></li><li><p>思考免费钱包或者网络可能性，可以使用<a href="https://docs.hecochain.com/#/en-us/dev/meta_tx" target="_blank" rel="noopener">原生元交易</a>，对交易费进行补贴。</p></li></ol><h1 id="总结">总结</h1><p>钱包本身存在易用性和安全性的矛盾。公私钥、备份助记词这种操作，对于习惯了只记录一个 pin 的 web2.0 用户而言不友好，这可能也是阻碍区块链向更大量的用户普及的一部分原因。</p><p>支持社交恢复的智能钱包，免去了用户记录助记词的困难，将安全性托付于社交关系，易用性上有了提升，但是也存在一些问题。Vitalik 难得之处在于，不止提出问题，还提供了解决方案的思考。</p><p>当前以太坊社区，开始逐步理解和使用 layer2，将 layer2 和智能钱包结合，将有利于以太坊网络向更大体量的用户推广。</p><p>欢迎留言或者联系博主对相关问题讨论！</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Vitalik 在 1-11 在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。&lt;/p&gt;
&lt;p&gt;原文不赘述，下文将主要记录要点和思
      
    
    </summary>
    
      <category term="blockchain" scheme="https://kvh.io/categories/blockchain/"/>
    
    
      <category term="wallet" scheme="https://kvh.io/tags/wallet/"/>
    
  </entry>
  
  <entry>
    <title>0x协议-介绍</title>
    <link href="https://kvh.io/0x-intro.html"/>
    <id>https://kvh.io/0x-intro.html</id>
    <published>2021-01-01T02:49:05.000Z</published>
    <updated>2021-01-13T01:42:18.816Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="核心">核心</h1><p>链下撮合（订单簿在链下）、链上结算（资金划转）</p><h1 id="角色">角色</h1><p>maker 挂单者</p><p>taker 吃单者</p><h1 id="实现">实现</h1><ul><li>maker 创建订单信息，签名 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">makerAddress</span><br><span class="line">takerAddress</span><br><span class="line">makerAssetData</span><br><span class="line">takerAssetData</span><br><span class="line">makerAssetAmount</span><br><span class="line">takerAssetAmount</span><br><span class="line">expirationTimeSeconds</span><br><span class="line">fee</span><br><span class="line">...</span><br><span class="line">签名</span><br><span class="line">哈希</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>注意：</p></blockquote><p>takerAddress 是空——直到taker接单</p><ul><li><p>relayer 链下撮合 taker 接受 maker 的订单，签名，提交到智能合约</p></li><li><p>链上结算 合约实现资金划转</p></li></ul><h1 id="问题">问题</h1><p>1）maker 如何取消交易</p><p>订单过期</p><p>2）交易效率</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">预先检查</span><br><span class="line">链上成交</span><br></pre></td></tr></tbody></table></figure><h1 id="与-uniswap-对比">与 uniswap 对比</h1><p>1）uni 有流动性提供者，一个 pair 的两个 token 都需要提供</p><p>2）uni 的价格是链上发现的</p><p>3）0x 只是交易意愿撮合，用户的资产不需要抵押</p><h1 id="总结">总结</h1><p>0x 协议核心是定义了一个「链下撮合，链下成交」的结构，但正式由于分离了链上和链下，其成交效率有一定折扣。</p><p>其后继者 uniswap 是一个整体闭环。</p><h1 id="参考">参考</h1><p><a href="https://0x.org/docs/core-concepts" target="_blank" rel="noopener">0x-protocol</a></p><p><a href="https://www.jinse.com/blockchain/247474.html" target="_blank" rel="noopener">0x-intro-jnse</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;核心&quot;&gt;核心&lt;/h1&gt;
&lt;p&gt;链下撮合（订单簿在链下）、链上结算（资金划转）&lt;/p&gt;
&lt;h1 id=&quot;角色&quot;&gt;角色&lt;/h1&gt;
&lt;p&gt;maker 挂单者&lt;/p&gt;
&lt;p&gt;taker 吃单者&lt;/p&gt;
&lt;h1 id=&quot;实现
      
    
    </summary>
    
      <category term="blockchain" scheme="https://kvh.io/categories/blockchain/"/>
    
    
      <category term="defi" scheme="https://kvh.io/tags/defi/"/>
    
  </entry>
  
  <entry>
    <title>《你就是孩子最好的玩具》读书笔记</title>
    <link href="https://kvh.io/reading-emotion-coaching.html"/>
    <id>https://kvh.io/reading-emotion-coaching.html</id>
    <published>2020-10-05T10:05:12.000Z</published>
    <updated>2021-01-13T01:42:18.826Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言">前言</h1><p>随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。</p><p>人生来就是一张白纸，父母是第一位老师，家庭教育对于塑造一个人的品格，有关键作用。</p><p>在教育这个事情上，说实话，也是战战兢兢，一不留神，就可能把原先的不那么正确的观念带给了孩子。</p><p>这个时候，不能盲目，不能下意识，只能多阅读、多思考、多观察、多实践，或许能减少一些内心的焦虑。</p><p>这是一本儿童教育的书，核心观点是对孩子进行情感引导式教育。作者摒弃了控制式、放任式、奖励式、惩罚式的教育。等等，这都是不对的？感觉颠覆了三观。细读下来，发现奖励和惩罚还是会在，不过占主导的是发挥同理心，进行情感引导和沟通。</p><p>这本书又是一本手册类的书，列举儿童 0-7 岁能出现的大部分让家长抓狂的情形再现、原因分析和解决方案，是值得多次翻阅和查找的一本书。</p><h1 id="信息卡片">🏷信息卡片</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">名称：《你就是孩子最好的玩具》</span><br><span class="line">作者:&nbsp;金伯莉·布雷恩</span><br><span class="line">译者:&nbsp;夏欣茁</span><br><span class="line">出版年:&nbsp;2011-8</span><br><span class="line">页数:&nbsp;191</span><br><span class="line">定价:&nbsp;29.80元</span><br><span class="line">ISBN:&nbsp;9787550102996</span><br><span class="line">豆瓣评分：&nbsp; &nbsp; &nbsp;&nbsp; 8.2</span><br><span class="line">起止时间：&nbsp; &nbsp; &nbsp;&nbsp; 2020.10.05--2020.10.05</span><br><span class="line">阅读次数：&nbsp; &nbsp; &nbsp;&nbsp; 1</span><br><span class="line">推荐指数：&nbsp; &nbsp; &nbsp; 🌟🌟🌟🌟</span><br><span class="line">获奖情况：</span><br></pre></td></tr></tbody></table></figure><h1 id="写作背景">🌱写作背景</h1><p>作者是儿童教育专家，最早提出「情感引导式教育」概念，同时也是 2 个男孩的母亲。</p><h1 id="原著呈现">📒原著呈现</h1><p>p9 你是希望孩子处于对你的恐惧而听从你的建议，还是处于对你的爱戴和尊重而听从你的建议呢？ p149 我们唯有甘心忍耐，才可能从刻意逃避转为欣然面对</p><h1 id="书摘批注">🖇书摘&amp;批注</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">p3 情感引导是什么：想孩子传授情感规则，让他们知道如何辨认情感并且以恰当的方式来表达。</span><br><span class="line">懂得辨认和他人的情感，是形成和谐的人际关系的关键。</span><br><span class="line"></span><br><span class="line">p6 常见误区：</span><br><span class="line">1）控制和放任型</span><br><span class="line">2）轻视、低估和否定孩子的感受 </span><br><span class="line">3）采用外部激励和奖赏的手段 </span><br><span class="line">4）以消极后果作为惩罚</span><br><span class="line">小朋友没有去权利生气？不是的，小朋友要学会知道自己是否在生气，为什么生气，如何处理情绪。</span><br><span class="line"></span><br><span class="line">p33 同情的力量</span><br><span class="line">所谓同理心——站在别人角度看问题；对待小朋友，也需要如此。</span><br><span class="line"></span><br><span class="line">p38 情感引导的关键步骤：</span><br><span class="line">1）播下种子——提前预告</span><br><span class="line">2）观察和判断——了解孩子的情况</span><br><span class="line">3）聆听——倾听孩子的感受</span><br><span class="line">4）体察和同情</span><br><span class="line">期前预告接下来要发生的事情，以一种协商的姿态告知孩子，争取他的配合。</span><br><span class="line"></span><br><span class="line">p56 安抚毯、毛绒玩具</span><br><span class="line">作者提到她的孩子对于安抚毯有强烈的依赖。</span><br><span class="line"></span><br><span class="line">p62 不眠之夜</span><br><span class="line">在某些转折点之前，可能会折腾一阵子——例如突然开始说话之前</span><br><span class="line"></span><br><span class="line">p63 带婴儿外出</span><br><span class="line">做好心理建设最重要——孩子不大可能能长时间配合</span><br><span class="line"></span><br><span class="line">p79 为什么打屁股没用</span><br><span class="line">打屁股会影响孩子的学习能力，教唆使用暴力，体罚会造成伤害，打击自信心</span><br><span class="line">因为暴力而屈服，并不是真的理解，也没有主观产生能动性</span><br><span class="line"></span><br><span class="line">p92 奖励无法奏效</span><br><span class="line">核心是孩子应该是靠情感来激励，而不是物质；幸福感只能来源自身；</span><br><span class="line">久而久之，孩子会对奖励有过高的期望或者依赖。</span><br><span class="line">准确的夸赞孩子，而不是使用某种激励手段。</span><br><span class="line"></span><br><span class="line">p96 孩子耍脾气怎么办</span><br><span class="line">不要针锋相对</span><br><span class="line">提前计划，表达对孩子的理解和同情，保持冷静，不去理睬</span><br><span class="line"></span><br><span class="line">p149 无条件的爱</span><br><span class="line">了解自己，了解孩子</span><br></pre></td></tr></tbody></table></figure><h1 id="总结感悟">🙋‍♀️总结感悟</h1><ol type="1"><li><p>核心观点是父母与孩子建立良好的沟通和互动关系，理解、疏导孩各类「不良」行为。进而形成亲子之间的感情纽带，教会孩子正确理解和处理自己的情感，成长为一个具有良好社交能力的人。</p></li><li><p>孩子发展是分阶段的，不同孩子的发展又不是完全同步的，因此父母要尊重规律，抛弃不切实际的计划和目标——例如要求 2 岁的孩子能安静坐着看电影。</p></li><li><p>作者认为新生儿阶段，应该给与足够的照料，这也是跟李玫瑾的观点类似。</p></li><li><p>2 岁以前，转移注意力的做法是可取的。</p></li><li><p>夸赞的方式：询问孩子自身的感受（你觉得怎么样？），站在主观的角度来观察（我喜欢你穿的衣服），而不是下一个看似客观的定义（你真会穿衣服）。</p></li><li><p>这本书实用性比较强，用了大量的案例来支撑观点。3-4-5 章更是针对各类儿童的问题，都给出了分析和对策。</p></li><li><p>教会孩子与大人进行协作。</p></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。&lt;/p&gt;
&lt;p&gt;人生来就是一张白纸，父母是第一位老师，家庭教育对于塑造一个人的品格，有关键作
      
    
    </summary>
    
      <category term="reading" scheme="https://kvh.io/categories/reading/"/>
    
    
      <category term="education" scheme="https://kvh.io/tags/education/"/>
    
  </entry>
  
  <entry>
    <title>币安链（BC）与币安智能链（BSC）简介</title>
    <link href="https://kvh.io/blockchain-bsc-intro.html"/>
    <id>https://kvh.io/blockchain-bsc-intro.html</id>
    <published>2020-09-19T03:46:03.000Z</published>
    <updated>2021-01-13T01:42:18.820Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。</p><h1 id="出发点">出发点</h1><p>总所周知，币安基于Cosmos-SDk 搭建了币安链（Binance Chain，下称 BC），并于 2019 年上线了主网。那为什么还要有另外一个智能链（Binance Smart Chain，下称 BSC）呢。白皮书解释和言外之意都描述下： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）实际应用要求有更强的可编程性（要有智能合约）</span><br><span class="line">2）保证现有的 dex 的高性能（基于 cosmos-sdk的链交易并发是有瓶颈的）</span><br><span class="line">3）开发者的学习曲线（以太坊的 DApp 生态最完善）</span><br></pre></td></tr></tbody></table></figure><p></p><p>有了以上的需求，采用下面的技术路线和架构几乎是水到渠成。</p><h1 id="设计目标">设计目标</h1><h2 id="设计目标-1">设计目标</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）BC 为主链，新链是一个独立区块链，对BC的依赖少</span><br><span class="line">2）兼容以太坊生态，保留跟随以太坊升级的可能性（改动越少，越好升级）</span><br></pre></td></tr></tbody></table></figure><h2 id="分工和职责">分工和职责</h2><p>为了旧链和新链的合理性，设计了下面的职责和结构。</p><p>BC核心职责： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）原有的 dex 功能</span><br><span class="line">2）平行链信息， staking 与治理</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>平行staking 放在 BC 上，也可能是考虑以后还会有别的新链出现~</p></blockquote><p>BSC 核心职责：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）运行区块链，输出 staking 和治理依据</span><br><span class="line">2）运行复杂的 DApp</span><br></pre></td></tr></tbody></table></figure><p>由于两个链是相对独立的，所以称为是<code>平行链</code>。</p><h1 id="bsc-共识协议">BSC 共识协议</h1><p>BSC 采用了 所谓的 PoSA（Proof of Staked Authority），你可以认为是以太坊代码中的 Clique 的一个小改动，综合了 PoA 和 DPoS 的思路。大致流程是：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）验证者或者代理人在 BC 上抵押</span><br><span class="line">2）BC 每24 小时重选合法验证者列表（21 个），通过跨链消息传递给 BSC</span><br><span class="line">3）BSC 根据验证者列表，选择节点轮流产块</span><br></pre></td></tr></tbody></table></figure><blockquote><p>PoA这个协议只能实现秒级的产块，但是无法实现秒级的确认（finality）。不确定做这个选择是为什么？可能是为了简单？个人认为有点偷懒了，采用基于 BFT 的快速确认的共识协议可能会更好。</p></blockquote><p>简单而言，实现了基于 PoS 治理，PoA 产块。</p><p>从区块浏览器观察来看，BC 的区块周期大约1秒 2 个区块（ sub-second），BSC 的区块周期是大约 3 秒。</p><p>因为 BC 使用的 tendermint 共识，所以交易确认时间也就是区块周期，BSC 使用了是 PoA 共识，如果等待 21 个节点中的 +1/2确认，需要大约 30s-1m。</p><h1 id="token">Token</h1><p>设计了在 BC 和 BSC 双向映射和转账的机制。</p><h2 id="token-定义">Token 定义</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BC：</span><br><span class="line">BEP2</span><br><span class="line">BNB</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BSC：</span><br><span class="line">BEP2E</span><br><span class="line">BNB</span><br></pre></td></tr></tbody></table></figure><p>BNB 是两个平行链的 native token，交易手续费、抵押、奖励等都使用 BNB。</p><p>BEP2 是 BC 上类似于 ERC20 的 Token。</p><p>BEP2E 是 BSC 上类似于 ERC20 的 Token，多了几个方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol()</span><br><span class="line">decimals()</span><br><span class="line">onwer() //比较重要，声明拥有者地址，后面只有这个地址可以发起绑定操作</span><br></pre></td></tr></tbody></table></figure><p>那核心问题就是Token映射和转账，即：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEP2 of BC &lt;--?--&gt;BEP2E of BSC</span><br></pre></td></tr></tbody></table></figure><h2 id="token-绑定">Token 绑定</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）确定 BC 上的BEP2和 BSC 上的 BEP2E 存在</span><br><span class="line">2）确定和锁定发行量</span><br><span class="line">  假如总发行量 S，</span><br><span class="line">  BC 初始流通 K</span><br><span class="line">  BSC 初始流通 S-K</span><br><span class="line">token 发行者应该在对应的链上把未流通的量 lock 到系统合约或者账户，使得两个链上的发行总量是 S。</span><br><span class="line">3）BEP2 token 的发行者在 BC 上发起绑定交易</span><br><span class="line">完成检查之后，绑定请求发送到 relayers</span><br><span class="line">4）BSC relayer 将跨链绑定信息转发给 TokenHub 合约</span><br><span class="line">5）BEP2E 的 owner 调用 TokenHub 合约的方法，后者确认 1.未被绑定 2.symbol 发行量和最小数量位 3。锁定正常</span><br><span class="line">6）BC 通过 Oracle 收到返回信息，将 contract address 和 decimal 信息写入 BC</span><br></pre></td></tr></tbody></table></figure><p>注意，以上流程，需要 BC 上的系统托管账户，和 BSC 上的系统合约作为基础设施。</p><h1 id="链互操作">链互操作</h1><h2 id="平行链结构">平行链结构</h2><p>官方这张图很不错。 <img src="https://img.kvh.io/blog/blockchain-bsc-intro/para-chain.png" alt="para-chain"></p><p>注意 BSC Relayer 和 Oracle Relayer，分别负责把信息转发到 BSC 和 BC。</p><p>下面先介绍这两个角色，再介绍具体的跨链操作方式。</p><blockquote><p>值得一提的是，币安在设计这两个角色的时候，已经考虑到了去中心化环境可能带来的问题和采取了一定的对策。</p><p>但是，这两个角色本身的合法性和提供的信息的验证问题，是不够清晰的。</p></blockquote><h2 id="bsc-replayer">BSC replayer</h2><p>BSC relayer 负责将信息从 BC传递到BSC。</p><p>需要存入一定量的 BNB 到BSC链上进行「注册」，BSC 只会接受注册的 relayers。</p><ul><li>激励机制</li></ul><p>1）用户操作，由用户买单</p><p>2）系统同步，由 BSC 系统买单</p><ul><li>为了避免 relayers 垄断的情况</li></ul><p>1）奖励是批量分配</p><p>2）在批量中，奖励不是线性分配</p><h2 id="oracle-relayers">Oracle Relayers</h2><p>负责将信息从 BSC 传递到BC，消息本身需要经过BC 验证者的共识。</p><p>在提交之前，Oracle 需要等待足够的 BSC 区块确认（PoA 确认需要 1 分钟）。</p><p>跨链奖励会成为区块奖励的一部分，分配给验证者。</p><blockquote><p>将来也会引入对 Oracle 的 slashing</p></blockquote><h2 id="bc-bsc">BC-&gt;BSC</h2><p>依赖BSC Replayers，消息将会进入到预编译的系统智能合约。</p><p>消息类型： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Token绑定</span><br><span class="line">转账</span><br><span class="line">错误处理</span><br><span class="line">验证者信息更新</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="bsc--bc">BSC -&gt;BC</h2><p>如果是通过交易产生的跨链事件，其流程是这样的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tx -&gt; EVM -&gt; event -&gt; oracle</span><br></pre></td></tr></tbody></table></figure><p>每个BC 链验证者需要运行 oracle 进程作为 oracle relayer。</p><p>跨链消息包，也会被 BC 中的 validator 进行投票，签名超过2/3即为合法。</p><h2 id="超时和错误处理">超时和错误处理</h2><p>这个在跨链协议中很重要，涉及到回滚等。</p><p>当某个 sequence 的 tx 卡主，超时之后，将会有一个 skipsequence 交易出现，对卡主的 sequence 做出不可执行的标记。</p><p>社区决定如何处理。</p><blockquote><p>链上无法解决的问题，最终还是推到社区||-_-</p></blockquote><h1 id="staking-和治理">Staking 和治理</h1><p>BC 和 BSC 的Staking 的基本概念与其他基于 POS的链没有大不一样，要点如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）抵押，代理</span><br><span class="line"></span><br><span class="line">2）按照 token 排名，top n 作为验证者</span><br><span class="line"></span><br><span class="line">3）validator 分享收益给 delegator</span><br><span class="line"></span><br><span class="line">4）validator 会有被 slashing 的危险，delegator 需要分担</span><br><span class="line"></span><br><span class="line">5）token 有赎回期</span><br></pre></td></tr></tbody></table></figure><p>具体到 BC 和 BSC 的配合：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）BC 上抵押和代理 BNB</span><br><span class="line"></span><br><span class="line">2）BSC 的 validator 由 BC 上的 staking 模块决定，UTC 00:00:00 发出跨链通讯</span><br><span class="line"></span><br><span class="line">3）BSC 将验证者工作的信息，通过跨链通讯回传到 BC</span><br><span class="line"></span><br><span class="line">4）在 BC 上进行 reward 分配</span><br></pre></td></tr></tbody></table></figure><h1 id="罚没">罚没</h1><p>基于 PoS 的公链，其活性需要全体 validator 的诚实、如实工作保证的。</p><p>为了从经济学上推动这类行为，引入了罚没机制。</p><h2 id="双签">双签</h2><p>所谓的双签，是对于同一高度+同一个parent 的区块进行多与一次的签名。任何第三方都可以，以 slash request 的方式发到 BC 上。</p><p>1）从 validator 中移除——发出 update 事件</p><p>2）罚没一定量</p><p>3）一部分给提交者</p><p>4）另外的给验证者监管账户</p><h3 id="不稳定">不稳定</h3><p>一个内部合约，统计工作情况。</p><p>1）如果超过不工作阈值，其已得收益，将不会发给 BC，而是分2给其他的 validators。</p><p>驱使运营不好的节点，delegator 将会离开</p><p>2）如果工作情况低于另外一个阈值，将会通知 BC，发生另外一个 slashing</p><h1 id="总结">总结</h1><p>总的来讲，其技术结构和治理方式参考了一众跨链项目 （例如 cosmos 和 polkadot），也参考了 DPoS 的一众项目（例如 EOS 和 TRON）。机制设计上也留出了后续扩展的空间。在本文写作之时（2020-09），BSC 上已运行了若干 DeFi 应用，这也是 BSC 的实现最初目标（承接 DApp）的佐证。</p><p>在文章中，笔者也提出了一些疑问，例如 PoA 的区块确认时间过长，Relayer 和 Oracle 本身的信息正确性问题等。</p><p>在单链技术还没有实质性突破的情况下（以太坊 2.0 可能还需要若干年才能成熟，或者不会成功），这类平行扩展的思路，也不失为快速开展业务尝试的一种实干派做法。</p><h1 id="参考">参考</h1><p><a href="https://www.binance.org/" target="_blank" rel="noopener">BC 官网</a></p><p><a href="https://dex-bin.bnbstatic.com/static/Whitepaper_%20Binance%20Smart%20Chain.pdf" target="_blank" rel="noopener">BSC白皮书</a></p><p><a href="https://explorer.binance.org/" target="_blank" rel="noopener">BC 浏览器</a></p><p><a href="https://bscscan.com/" target="_blank" rel="noopener">BSC 浏览器</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。&lt;/p&gt;
&lt;h1 id=&quot;出发点&quot;&gt;出发点&lt;/h1
      
    
    </summary>
    
      <category term="blockchain" scheme="https://kvh.io/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://kvh.io/tags/blockchain/"/>
    
      <category term="DeFi" scheme="https://kvh.io/tags/DeFi/"/>
    
  </entry>
  
  <entry>
    <title>《影响力》读书笔记</title>
    <link href="https://kvh.io/reading-influence.html"/>
    <id>https://kvh.io/reading-influence.html</id>
    <published>2020-08-17T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.826Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言">前言</h1><p>这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。</p><p>通过阅读这本书，可以为<code>运营活动</code>或者<code>销售技巧</code>寻找理论根据，做到知其所以然。</p><h1 id="信息卡片">🏷信息卡片</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作者:[美] 罗伯特·西奥迪尼</span><br><span class="line">出版社:&nbsp;中国人民大学出版社</span><br><span class="line">出品方:&nbsp;湛庐文化</span><br><span class="line">原作名:&nbsp;Influence: The Psychology of Persuasion</span><br><span class="line">译者:&nbsp;陈叙</span><br><span class="line">出版年:&nbsp;2006-5</span><br><span class="line">页数:&nbsp;353</span><br><span class="line">定价:&nbsp;45.00元</span><br><span class="line">装帧:&nbsp;平装</span><br><span class="line">丛书:&nbsp;湛庐文化· 商业智慧</span><br><span class="line">ISBN:&nbsp;9787300072487</span><br><span class="line">起止时间：&nbsp; &nbsp; &nbsp;&nbsp; 2020.07.15--2020.08.15</span><br><span class="line">阅读次数：&nbsp; &nbsp; &nbsp;&nbsp; 2</span><br><span class="line">推荐指数：&nbsp; &nbsp; &nbsp; 🌟🌟🌟🌟</span><br><span class="line">获奖情况：</span><br></pre></td></tr></tbody></table></figure><h1 id="写作背景">🌱写作背景</h1><p>作者社会心理学家，致力于影响力的研究</p><p>作者使用了所谓的参与式观察（间谍）参与到一些商品或者服务的销售工作中，以获取技巧</p><h1 id="原著呈现">📒原著呈现</h1><figure><img src="https://img.kvh.io/blog/reading-influence/mindmap.png" alt="mindmap"><figcaption aria-hidden="true">mindmap</figcaption></figure><h1 id="书摘批注">🖇书摘&amp;批注</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">p3-4：绿宝石价格提高了，反而销量好了；</span><br><span class="line"></span><br><span class="line">人在成长过程中，接受了观念，价格贵=东西好；</span><br><span class="line">调高了价格，触发了用户的顺从按钮；在这一点上，人类也是某种基于反应的动物——跟雌火鸡一样；</span><br><span class="line"></span><br><span class="line">p9：文明的进步，就是人们在不假思索中可以做的事情更多</span><br><span class="line">所谓的专家，也就是在不断的训练中，形成了对于工作的问题的肌肉记忆</span><br><span class="line"></span><br><span class="line">p15-16：对比原理</span><br><span class="line">先看霹雳娇娃，会影响给自己对象的打分；</span><br><span class="line">先兜售贵的商品、其次是便宜商品——可能会让总收益最大</span><br><span class="line">先给一个不好的方案、然后给一个正常的方案，可能会有助于方案的接受</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二章：互惠——给予、索取、在索取</span><br><span class="line"></span><br><span class="line">p25：给对方寄贺卡，会受到很多回信</span><br><span class="line">在一个社交网络早期，主动加别人，会有一定的会加率</span><br><span class="line"></span><br><span class="line">p28：给对方带一瓶可乐，就可以获得更高的彩票销售</span><br><span class="line">不要忽视小恩小惠的作用；要习惯对别人施以援手——赠人玫瑰，手留余香</span><br><span class="line"></span><br><span class="line">p33：政府高层的相互投票和联合</span><br><span class="line">奥巴马和特朗普该多难啊！</span><br><span class="line"></span><br><span class="line">p35：安利臭虫</span><br><span class="line">所谓的试吃，也是这道理吧</span><br><span class="line"></span><br><span class="line">p38：人有送礼的义务、接受的义务、更有偿还的义务</span><br><span class="line">想起了老教父柯里昂</span><br><span class="line"></span><br><span class="line">p48：拒绝-后撤</span><br><span class="line">常见的销售技巧——漫天要价，坐地还钱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三章：承诺和一致性——脑子里的怪物</span><br><span class="line"></span><br><span class="line">p63：一开始就拒绝，比最后返回要容易——达芬奇</span><br><span class="line">至理名言，特别是对于推销cold call</span><br><span class="line"></span><br><span class="line">p67：所有人都一次次的骗自己，以便在做出选择之后，坚信自己做的没错</span><br><span class="line">you've got a dream, you've to protecet it</span><br><span class="line"></span><br><span class="line">p68：信仰、言行和行为前后一致不一致的人，会被看成脑筋混乱表里不一；言行高度一致多数跟个性坚强、智力出众；它是逻辑性、稳定性、诚实感的核心</span><br><span class="line">胡忠献的忠，岳飞的忠</span><br><span class="line">吴三桂所谓没有定力</span><br><span class="line"></span><br><span class="line">p70：关于冥思会和缴费</span><br><span class="line">超自然的方法，可能是唯一解药；</span><br><span class="line"></span><br><span class="line">p73：玩具销售商的策略</span><br><span class="line">为了保持淡季的销量</span><br><span class="line"></span><br><span class="line">p85：战俘营的做法</span><br><span class="line">以小积大</span><br><span class="line"></span><br><span class="line">p86：个人承诺防止撕毁合同</span><br><span class="line">自己说出的话，自己要遵守承诺</span><br><span class="line"></span><br><span class="line">p90：额外的努力，费尽努力得到的东西，人人往往格外珍视</span><br><span class="line">追姑娘丈母娘设置困难</span><br><span class="line">公司的严格面试，也是一种投名状</span><br><span class="line">其中的成员，会强烈的维护这种准入</span><br><span class="line">建立团队凝聚力和卓越感，入会活动要艰辛</span><br><span class="line"></span><br><span class="line">p100：内心的压力</span><br><span class="line">你得找一个有力的理由，让他大多数情况下都保持城市，可这个理由又不能强大到让孩子觉得，自己完全是为了它才诚实</span><br><span class="line">太强烈的惩罚，可能不会奏效</span><br><span class="line">要是说谎，我会失望的</span><br><span class="line">这个对于教育孩子很有意义，要让遵守规则成为孩子自身的习惯，而不是被强迫的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第四章：社会认同——脑子里的怪物</span><br><span class="line"></span><br><span class="line">p120：依照别人意见行事</span><br><span class="line"></span><br><span class="line">盖得排行，大众点评</span><br><span class="line">街头围观，网红店雇人排队</span><br><span class="line"></span><br><span class="line">p138:寻求帮助</span><br><span class="line">找到特定的人寻求帮助</span><br><span class="line">旁</span><br><span class="line"></span><br><span class="line">p150:自杀新闻</span><br><span class="line">会导致更高的自杀率</span><br><span class="line"></span><br><span class="line">第五章：喜好——友好的盗贼</span><br><span class="line"></span><br><span class="line">p175:销售外表</span><br><span class="line">广告模特和销售人员都要漂亮</span><br><span class="line">p179:喜好</span><br><span class="line"></span><br><span class="line">广告的作用。第一次陌生，看了广告之后就觉得是名牌了</span><br><span class="line"></span><br><span class="line">p181:所谓的融合策略</span><br><span class="line">融合过程中导致的恶意，难道不是留下更大的影响么</span><br><span class="line"></span><br><span class="line">p184:拼图学习法</span><br><span class="line">竞争与合作</span><br><span class="line"></span><br><span class="line">p199:体育运动</span><br><span class="line">乒乓球、排球、奥运会等对国民认同的形成的作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第六章：权威——教化下的敬重</span><br><span class="line"></span><br><span class="line">p223:头衔</span><br><span class="line">都喜欢挂一堆头衔</span><br><span class="line">第七章：稀缺——数量少说了算</span><br><span class="line"></span><br><span class="line">p243:稀缺</span><br><span class="line">销售管用伎俩，create urgent</span><br><span class="line"></span><br><span class="line">p247:逆反心理</span><br><span class="line">有屏障，挑衅；测试界限；罗密欧朱丽叶，如果没有限制，可能不多久就分掉了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p253:信息审查</span><br><span class="line">「禁书」，快要被删，这都有助于传播</span><br><span class="line">p260:参与竞争稀缺资源，有强大的刺激性</span><br><span class="line">所谓的竞雄？拍卖</span><br></pre></td></tr></tbody></table></figure><h1 id="总结感悟">🙋‍♀️总结感悟</h1><p>顺从的力量，来自大量「正统」观念影响</p><p>从理论上了解影响力的来源：互惠、承诺和一致性、社会认同、喜好、权威、稀缺</p><p>验证和对照了一些日常的销售和运营策略</p><h1 id="他山之石">👯‍♀️他山之石</h1><p>🎥多媒体资料</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。&lt;/p&gt;
&lt;p&gt;通过阅读这本书，可以为&lt;code&gt;运营活动&lt;/code&gt;或者&lt;code&gt;销售技巧&lt;/code&gt;寻找理
      
    
    </summary>
    
      <category term="reading" scheme="https://kvh.io/categories/reading/"/>
    
    
      <category term="社会心理学" scheme="https://kvh.io/tags/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证介绍与项目实战</title>
    <link href="https://kvh.io/open-source-license.html"/>
    <id>https://kvh.io/open-source-license.html</id>
    <published>2020-04-28T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.825Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="介绍">介绍</h1><p>在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到：</p><ul><li>使用和修改的条件是什么？</li><li>商用和分发的条件是什么？</li><li>本项目开源后使用什么许可证？</li></ul><p>本文将简要介绍对许可证（license）的理解，着重介绍一个实战项目处理方式。</p><h1 id="许可证介绍">许可证介绍</h1><p>许可证的内容，其实是博大精深。</p><p>首先许可证的种类特别的多，其次不同的许可的条款和细节也特别的多。</p><p>下面主要是介绍若干<code>主流且具有代表性</code>的许可证。</p><blockquote><p>主要参考了<a href="https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html" target="_blank" rel="noopener">开源许可证教程-阮一峰的网络日志</a></p></blockquote><h2 id="名词解释">名词解释</h2><ul><li><p>分发</p><p>将版权作品从一个人转移到另外一个人；例如提供给别人；如果是本公司使用，不算分发。</p></li><li><p>传染</p><p>一个项目用到了某个许可证的代码，在某些条件下（例如分发），这个项目本身也需要使用这种许可证</p></li><li><p>许可证版本</p><p>同一个许可证，有版本号之间的区别，例如 GPL 有 v1/v2/v3。</p></li></ul><h2 id="宽松的许可证">宽松的许可证</h2><p>包含 MIT/ISC/BSD/Apache等，基本上这类许可证，是可以放心使用。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）BSD（二条款版）</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。</span><br><span class="line"></span><br><span class="line">（2） BSD（三条款版）</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</span><br><span class="line"></span><br><span class="line">（3）MIT</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</span><br><span class="line"></span><br><span class="line">（4）Apache 2</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</span><br></pre></td></tr></tbody></table></figure><h3 id="copyleft-许可证">Copyleft 许可证</h3><p>代码可以随意复制，有如下前提：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如果分发二进制格式，必须提供源码</span><br><span class="line">- 修改后的源码，必须与修改前保持许可证一致</span><br><span class="line">- 不得在原始许可证以外，附加其他限制</span><br></pre></td></tr></tbody></table></figure><p>核心在于，修改后的代码，不得闭源。</p><ul><li>AGPL</li></ul><p>最严格的 GPL，除非获得商业授权，否则无论以何种方式修改或者使用代码，都需要开源。</p><blockquote><p>云服务使用AGPL 的源码，不构成分发，也也需要开源</p></blockquote><ul><li>GPL</li></ul><p>如果分发软件，则使用和修改都必须开源，整个项目都必须采用 GPL许可。</p><ul><li>LGPL</li></ul><p>分发时，如果是使用动态类库的方式引用，可以不开源</p><ul><li>MPL</li></ul><p>分发时，只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p><blockquote><p>无论是商业应用，还是开源项目，在采用 AGPL/GPL/LGPL/MPL都要特别的小心。</p></blockquote><h1 id="许可证检测">许可证检测</h1><p>介绍两个工具，分别检测代码文件和依赖的 license。</p><h2 id="检测代码">检测代码</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/addlicense</span><br></pre></td></tr></tbody></table></figure><p>可以递归检测当前目录下的所有代码文件，许可证声明的情况，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addlicense -check ./ |sort &gt; lc.txt</span><br></pre></td></tr></tbody></table></figure><p>可以把未添加许可证的文件都输出到lc.txt 文件中，方便后续进行检查。</p><h2 id="检测依赖库">检测依赖库</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/go-licenses</span><br></pre></td></tr></tbody></table></figure><p>查看一个依赖库所使用的版权信息：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-licenses csv repo</span><br></pre></td></tr></tbody></table></figure><p>可以通过一个这个脚本项目进行批量测试：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat dep.txt |while read line</span><br><span class="line">do </span><br><span class="line">echo "start checking package $line"</span><br><span class="line">go-licenses csv $line</span><br><span class="line">echo ""</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><h2 id="许可证添加">许可证添加</h2><p>笔者主要使用 idea 的 IDE 进行程序开发，它有管理版权信息的功能：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Preference-&gt;editor-&gt;Copyright</span><br></pre></td></tr></tbody></table></figure><p>可以添加不同的 Profiles，然后使用 IDE的功能进行自动添加和更新。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）设置默认 copyright</span><br><span class="line">preference-&gt;editor-&gt;Copyright</span><br><span class="line">设置 default project copyright，选中一种配置，这个可能会根据不同的文件需要切换</span><br><span class="line"></span><br><span class="line">2）选中代码文件或者文件夹</span><br><span class="line"></span><br><span class="line">3）菜单栏-&gt;Code-&gt;Update Copyright</span><br></pre></td></tr></tbody></table></figure><h1 id="项目实战">项目实战</h1><p>下文介绍对于一个实际项目进行许可证声明。</p><h2 id="项目背景">项目背景</h2><p>该项目主语言是 golang，采用了自某 LGPL 的项目的一部分类库作为基础代码。</p><h2 id="版权主体">版权主体</h2><p>也就是版权声明的第一行的关键信息，例如：</p><ul><li>go-ethereum</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2016 The go-ethereum Authors</span><br></pre></td></tr></tbody></table></figure><ul><li>go-algorand</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) 2019-2020 Algorand, Inc.</span><br></pre></td></tr></tbody></table></figure><p>可以选择是作者主体，或者公司主体。</p><h2 id="项目-license">项目 license</h2><p>由于该项目的代码，部分使用了修改了 LGPL 项目代码作为基础工具。</p><p>根据 LGPL 的规定，本项目也需要使用 LGPL 作为 license。</p><h2 id="版权声明">版权声明</h2><p>声明版权，一般两部分：</p><h4 id="项目级别的-license-文件">1）项目级别的 LICENSE 文件</h4><p>由于大部分的许可证都是控制包级别的许可，所以这种方式也足够</p><h4 id="代码级别的-copyright-文件头">2）代码级别的 copyright 文件头</h4><p>每一个原创的文件都设置了版权信息</p><h2 id="项目级别的-license">项目级别的 license</h2><p>一般而言，是找到你的 license 的文本，将文件放置于项目根目录。</p><blockquote><p>不同许可证可能有点不一样</p></blockquote><p>一般而言，在 github 建立公开项目的时候，会提示选择一个 license。</p><p>如果初始化忘记了，也可以web 界面上，新建一个名字是<code>LICENSE</code>的文件，来显式触发选择 license。</p><h2 id="代码级别的-copyright-文件头-1">代码级别的 copyright 文件头</h2><p>使用第三方代码，主要分为，<code>fork 引用</code> 和 <code>library 依赖</code>。</p><p>fork 是指把代码直接放到了代码库中，修改或者不修改。</p><p>library 是库依赖，例如通过 go.mod 的方式进行依赖。</p><h3 id="fork-引用">fork 引用</h3><p>代码分类 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1）项目原创文件</span><br><span class="line"></span><br><span class="line">2）项目修改第三方库的文件</span><br><span class="line"></span><br><span class="line">3）项目直接引用第三方库的文件</span><br><span class="line"></span><br><span class="line">4）fork 过来的开源库</span><br><span class="line">可能存在包内 license，单文件可能没有copyright</span><br><span class="line"></span><br><span class="line">5）忽略 license 文件的内容</span><br><span class="line"></span><br><span class="line">非 golang 文件</span><br><span class="line">gencode 生成的以 gen_开头的文件</span><br><span class="line">其他自动生成的文件</span><br></pre></td></tr></tbody></table></figure><p></p><p>有了如上的分类，你就可以使用 IDE 创建多个不同的 Copyright Profiles 来处理不同的文件了。</p><p>结合 addlicense 工具，相信这部分工作将可以顺利完成。</p><h4 id="library-依赖">library 依赖</h4><p>使用上述的依赖检测工具，查看是否有不合适的许可证。</p><blockquote><p>如果一个依赖库，license 不是MIT/ISC/BSD/Apache 其中的一种，那就要小心了！</p></blockquote><h1 id="tbd-topics">TBD-Topics</h1><p>有一些话题需要进一步讨论：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1）如果项目源码计划商用，如何处理？</span><br></pre></td></tr></tbody></table></figure><h1 id="总结">总结</h1><p>本文简要介绍了license 的原理，着重介绍了项目实战，希望对读者有启发，欢迎讨论！</p><h1 id="参考">参考</h1><p>https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html</p><p>https://www.gnu.org/licenses/gpl-faq.html</p><p>https://choosealicense.com/</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;介绍&quot;&gt;介绍&lt;/h1&gt;
&lt;p&gt;在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用和修改的条件是什么？&lt;/li&gt;
&lt;li&gt;商用和分发的条件是什么？&lt;/li&gt;
&lt;li&gt;本项目
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 作为服务器</title>
    <link href="https://kvh.io/osx-as-server.html"/>
    <id>https://kvh.io/osx-as-server.html</id>
    <published>2017-12-04T03:21:55.000Z</published>
    <updated>2021-01-13T01:42:18.825Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>因为业务需要，我司有若干台服务器 Mac 作为服务器。下面总结一下注意事项，作为记录。</p><h1 id="取消系统休眠">取消系统休眠</h1><p>曾经在这个问题上困扰很长时间。在升级了 <code>macOS High Sierra</code> 之后，发现之前能够正常运行的程序出现问题。</p><p>具体表现是：</p><ol type="1"><li>ssh 登出之后不久，线上就开始报警</li><li>登陆进去查看 log，发现程序又是正常的</li><li>socket 连接提示传输错误</li><li>程序并没有 exit</li></ol><p>一开始怀疑是后台程序的权限问题，于是更新了后台程序的 launchd 配置，确保了使用 root 用户运行，没有效果。</p><p>后来灵机一动，去具体分析程序的 log，发现只要用户登出，输出就会停止，看起来是程序被挂起了。</p><p>分析可能被挂起的原因，只可能是系统休眠了。</p><p>直接登陆 GUI 系统，在系统设置中将节能设置改成：</p><figure><img src="https://img.kvh.io/17-12-4/97778894.jpg" alt="节能设置"><figcaption aria-hidden="true">节能设置</figcaption></figure><p>生效了！</p><h1 id="守护进程">守护进程</h1><p>作为服务器，大多是需要运行守护进程。这就需要用到 <code>launchd</code>，它能确保这是确保设备重启之后，守护能够自动运行。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Launchd" target="_blank" rel="noopener">launchd</a> 是一个开源框架，用于控制守护进程、程序、或者脚本，在 Mac OS X Tiger 中引入。</p></blockquote><p>使用 launchd，主要需要注意下面几点：</p><ul><li>正确区分系统全局的守护和用户相关的守护进程</li></ul><table><thead><tr class="header"><th>类型</th><th>路径</th><th>运行用户</th></tr></thead><tbody><tr class="odd"><td>全局的守护进程</td><td>/Library/LaunchDaemons</td><td>root 用户或者使用 UserName key 对应的用户</td></tr><tr class="even"><td>系统的守护进程</td><td>/System/Library/LaunchDaemons</td><td>root 用户或者使用</td></tr></tbody></table><p>一般而言，把 plist 文件放到 <code>/Library/LaunchDaemons</code> 即可。</p><ul><li>正确设置 plist 文件的权限</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  1 wheel  947 12  1 14:51 name_of_the_config.plist</span><br></pre></td></tr></tbody></table></figure><p>也即是： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户：root</span><br><span class="line">组：wheel</span><br><span class="line">权限： 0644</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>被运行的程序，需要是处于前台运行，否则 launchd 会认为程序已经退出</li><li>如果需要全局性的守护进程，需要使用 sudo 运行</li></ul><h2 id="参考文档">参考文档</h2><p><a href="http://www.launchd.info/" target="_blank" rel="noopener">http://www.launchd.info/</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html#//apple_ref/doc/man/5/launchd.plist" target="_blank" rel="noopener">launchd.plist</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/launchctl.1.html#//apple_ref/doc/man/1/launchctl" target="_blank" rel="noopener">launchctl</a></p><h1 id="内网穿透">内网穿透</h1><p>很多时候，macOS 服务器并不是托管在机房，而是在某个比较方便管理的地方——例如办公室。</p><p>办公室的网络环境又千奇百怪，往往没有固定的外网 ip，往往是处于 NAT 的网络环境或者是防火墙内，如果服务出现了问题，总不能直接跑去办公室吧。</p><p>尝试过各种 VPN 方案，动静太大，不稳定，放弃。下面介绍一下 <a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">Ngrok</a>。</p><p>官网简介：</p><blockquote><p>Secure tunnels to localhost ”I want to expose a local server behind a NAT or firewall to the internet.”</p></blockquote><p>基本的构架图如下：</p><figure><img src="https://img.kvh.io/17-12-4/55782772.jpg" alt="Ngrok"><figcaption aria-hidden="true">Ngrok</figcaption></figure><p>这款软件是 C/S 结构，使用服务器作为中转，只需要设置好服务器和客户端，不需要在路由器做任何处理。<code>软件的2.x 不开源，github 上只有 1.x 版本</code>，已经足够。</p><p>使用方式，参考<a href="https://imququ.com/post/self-hosted-ngrokd.html" target="_blank" rel="noopener">imququ 的博客</a>。</p><p>基本流程是： 1. clone 源码 2. 生成证书，拷贝 <code>base.pem</code> 到 <code>assets/client/tls/ngrokroot.crt</code> 下 3. 运行 <code>make release-server release-client</code> 4. <code>bin</code> 的 ngrokd 和 ngrok 分别是服务器端和客户端</p><h1 id="总结">总结</h1><p>以上是对于 <code>macOS</code> 作为服务器的一些注意事项。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;因为业务需要，我司有若干台服务器 Mac 作为服务器。下面总结一下注意事项，作为记录。&lt;/p&gt;
&lt;h1 id=&quot;取消系统休眠&quot;&gt;取消系统休眠&lt;/h1&gt;
&lt;p&gt;曾经在这个问题上困扰很长时间。在升级了 &lt;code&gt;macOS H
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="macOS" scheme="https://kvh.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 配置中心</title>
    <link href="https://kvh.io/spring-cloud-config.html"/>
    <id>https://kvh.io/spring-cloud-config.html</id>
    <published>2017-10-13T15:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.830Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="闲话配置">闲话配置</h1><p>老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就满足了需求。</p><blockquote><p>配置（Configuration）是不修改代码的情况下，对程序的运行调整的能力。</p></blockquote><p>简单来讲，配置可以分成两类：</p><ol type="1"><li>系统配置：包括线程池大小、数据库连接等，变化频率较低</li><li>业务配置：功能开关，功能参数等，变化较为频繁</li></ol><p>程序的配置一般而言，分为几个环境：</p><ol type="1"><li>开发环境</li><li>测试环境</li><li>生产环境</li></ol><p>这几个环境的配置是有差异的，所以配置管理功能应当能够根据当前环境读取对应的配置。</p><p>前面提到的不修改代码，只是最低要求，相当多的情况下，程序是不能停机的，这就提出了热更新的需求。</p><p>另外，配置的修改应该是有记录可追溯的。</p><h1 id="spring-boot-的配置管理">Spring Boot 的配置管理</h1><p>Spring 实现了非常友好的配置读取方式，</p><p>Spring Boot 程序默认使用 application.properties 进行配置。</p><p>例如一个参数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=0</span><br></pre></td></tr></tbody></table></figure><p>在程序中可以通过：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value("${flag})</span><br><span class="line">int flag;</span><br></pre></td></tr></tbody></table></figure><p>来读取。</p><p>也可以通过设置多个配置文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application.properties</span><br><span class="line">application-dev.properties</span><br><span class="line">application-test.properties</span><br><span class="line">application-prod.properties</span><br></pre></td></tr></tbody></table></figure><p>application-dev.properties </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=1</span><br></pre></td></tr></tbody></table></figure><p></p><p>application-test.properties </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=2</span><br></pre></td></tr></tbody></table></figure><p></p><p>application-prod.properties </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=3</span><br></pre></td></tr></tbody></table></figure><p></p><p>和在 application.properties 中声明当前的活跃的 profile：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></tbody></table></figure><p>来实现根据运行环境切换配置信息。</p><p>以上只是 Spring 强大的配置能力的冰山一角，有兴趣可以参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html" target="_blank" rel="noopener">外部配置文档</a>。</p><h2 id="这还不够">这还不够</h2><p>其实以上描述的 Spring Boot 的配置能力已经很强了，但是有个很致命的问题——无法热更新。</p><p>如果非得实现热更新，那可以把配置做成 JSON 文件，再实现一个 endpoint，重新读取一次配置。</p><p>假设有一千个实例呢？</p><h1 id="spring-cloud-config">Spring Cloud Config</h1><p>项目 github：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><p>简介：External configuration (server and client) for Spring Cloud</p><p>这个项目包含两部分：</p><ul><li>Server</li></ul><p>负责从 git/svn 等版本管理系统中读取配置，并以 http 的方式提供服务。</p><ul><li>Client</li></ul><p>根据客户端配置，从指定的 Server 中读取对应配置，并且与 Spring 本身的 PropertyResource 和 Environment 无缝结合。同时，提供了统一的方式进行配置热更新。</p><p>对于这个系统的基础配置和运行，可以参阅下面两个 url：</p><p><a href="https://spring.io/guides/gs/centralized-configuration/" target="_blank" rel="noopener">https://spring.io/guides/gs/centralized-configuration/</a></p><p><a href="http://blog.didispace.com/spring-cloud-starter-dalston-3/" target="_blank" rel="noopener">http://blog.didispace.com/spring-cloud-starter-dalston-3/</a></p><h2 id="实操进阶">实操进阶</h2><h3 id="热更新">热更新</h3><p>Spring Cloud Config 实现了非常优雅的热更新。</p><ul><li>客户端的配置 Bean 添加 <span class="citation" data-cites="RefreshScope">@RefreshScope</span></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConsumeConfig {</span><br><span class="line"></span><br><span class="line">    @Value("${consume.desc}")</span><br><span class="line">    private String consumeDesc;</span><br><span class="line">    </span><br><span class="line">    @Value("#{'${api.server.round.card}'.split(',')}")</span><br><span class="line">    private List&lt;String&gt; cardList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在配置这个注解之后，调用客户端的 /refresh endpoint，这个 Bean 就会刷新，同时个 Bean 的依赖方下次方法调用时也会更新 Bean 引用。</p><p>有些时候，你需要监听这个更新事件，把拿到的最新配置，重新初始化一些部件。那你可以添加： <code>@EventListener(EnvironmentChangeEvent.class)</code> 这个 annotation。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumeService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConsumeConfig consumeConfig;</span><br><span class="line"></span><br><span class="line">    @EventListener(EnvironmentChangeEvent.class)</span><br><span class="line">    void onEnvChange() {</span><br><span class="line">        //do re-init stuff</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="添加权限">添加权限</h3><p>Config Server 任何人都可以通过 http 访问配置，这个不大好，建议加上认证，最简单是使用 Spring-Security 添加一个 basic authentication。</p><ul><li>服务器端配置</li></ul><p>build.gradle 添加依赖： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies {</span><br><span class="line">    compile('org.springframework.boot:spring-boot-starter-security')</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>application.properties 添加密码（用户名默认是 user）： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security.user.password=xxx</span><br></pre></td></tr></tbody></table></figure><p></p><p>重启服务器，再次通过 http 访问配置的时候需要验证。</p><ul><li>客户端配置</li></ul><p>服务器端做了验证，那客户端也需要添加相应的配置：</p><p>bootstrap.yml </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: application</span><br><span class="line"> cloud:</span><br><span class="line">  config:</span><br><span class="line">   uri: http://yourhost.com</span><br><span class="line">   profile: dev</span><br><span class="line">   username: user</span><br><span class="line">   password: xxx</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="加载多组配置文件">加载多组配置文件</h3><p>很多时候，为了避免 application.properties 过于臃肿，你可能需要把一些配置文件拆出来，例如专门负责邀请奖励的配置：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invite.properties</span><br><span class="line">invite-dev.properties</span><br><span class="line">invite-test.properties</span><br><span class="line">invite-prod.properties</span><br></pre></td></tr></tbody></table></figure><p>同样，也区分了多个环境。</p><p>那在使用 Spring Cloud 的时候如何读取这个文件呢？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: application,invite</span><br></pre></td></tr></tbody></table></figure><p>注意上面的 application.name 是以逗号分隔的两组配置名称。</p><h1 id="一些问题">一些问题</h1><h2 id="eventlistener-与-spel"><span class="citation" data-cites="EventListener">@EventListener</span> 与 SpEL</h2><p>我在实际使用中发现，在事件监听函数中，使用更新后的配置的时候：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value("${consume.desc}")</span><br><span class="line">private String consumeDesc;</span><br><span class="line"></span><br><span class="line">@Value("#{'${api.server.round.card}'.split(',')}")</span><br><span class="line">private List&lt;String&gt; cardList;</span><br></pre></td></tr></tbody></table></figure><p>第一个配置是使用 <span class="citation" data-cites="Value">@Value</span> 绑定一个字符串类型，第二个配置是使用 <span class="citation" data-cites="Value">@Value</span> 中的 SpEL 去将配置中的字符串，切割成 List。</p><p>我发现第二个，无法切割成功。试验了多次，还没有找到答案。我已经在 Spring Cloud Config 的 github 上提交了 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/821" target="_blank" rel="noopener">issue</a>。</p><p>如果有了解这个的，请不吝赐教。</p><blockquote><p>update 2017-10-26 * 我在 github 上提交了 issue： https://github.com/spring-cloud/spring-cloud-config/issues/821 得到回复：<code>We have only ever documented that placeholders ${} work, not SpEL.</code></p></blockquote><h2 id="权限管理">权限管理</h2><p>在不做二次开发的情况下，这个配置中心的数据是对所有的 client 开放的。某些情况下，这种设定并不合适。</p><h2 id="json-文件的读取和解析">JSON 文件的读取和解析</h2><p>Spring Cloud Config 本身是可以通过 http 来提供 JSON 文件的访问的，但是Spring Boot 原生并不支持 JSON 配置的读取和解析。</p><h1 id="相关选择">相关选择</h1><p>其实配置管理工具，选择还是不少的，下面列举一下。</p><ul><li>owner http://owner.aeonbits.org/</li></ul><p>配置文件管理，可以热更新，跟 Spring 没有绑定。</p><ul><li>cfg4j http://www.cfg4j.org/</li></ul><p>专注管理配置文件，也可以实现热更，跟 Spring 没有绑定。</p><ul><li>applolo https://github.com/ctripcorp/apollo</li></ul><p>携程开源的，功能很全</p><ul><li>disconf https://github.com/knightliao/disconf</li></ul><p>百度的一位工程师的开源项目，功能也很全</p><ul><li>diamond https://github.com/takeseem/diamond</li></ul><p>来自阿里的开源，有些日子了</p><h1 id="参考文献">参考文献</h1><p><a href="http://blog.didispace.com/spring-cloud-starter-dalston-3/" target="_blank" rel="noopener">http://blog.didispace.com/spring-cloud-starter-dalston-3/</a></p><p><a href="http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html</a></p><p><a href="http://jm.taobao.org/2016/09/28/an-article-about-config-center/" target="_blank" rel="noopener">http://jm.taobao.org/2016/09/28/an-article-about-config-center/</a></p><p><a href="https://blog.coding.net/blog/spring-cloud-config" target="_blank" rel="noopener">https://blog.coding.net/blog/spring-cloud-config</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;闲话配置&quot;&gt;闲话配置&lt;/h1&gt;
&lt;p&gt;老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就满足了需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Spring" scheme="https://kvh.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>小工具-sips-图片批量转大小</title>
    <link href="https://kvh.io/utility-sips.html"/>
    <id>https://kvh.io/utility-sips.html</id>
    <published>2017-05-16T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.830Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="家有设计师">家有设计师</h1><p>我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。</p><p>看了她导了好几次，实在不能忍。得发挥程序员的能动性，做个小工具。</p><h1 id="调研">调研</h1><p><a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">imagemagick</a> 是一个很好的工具，支持多个平台，功能丰富强大。考虑了一下，如果这个小工具还需要用户安装依赖的话，显然提高了使用门槛。</p><p>设计师们大多在 MacOS 下工作，最好是运用这个平台下现成的工具包。搜索了一下，发现今天的主角：<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/sips.1.html" target="_blank" rel="noopener">sips</a>。</p><p>sips 具有很友好的使用接口，可以实现大小转换、旋转、翻转等。这里我只需要大小转换功能，主要是如下命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sips -Z 100 input.png --out output.png</span><br></pre></td></tr></tbody></table></figure><p>上面的例子可以将 <code>input.png</code> 图片最大边调整成100像素，等比缩放。</p><h1 id="实践">实践</h1><p>整个工具包含如下几个文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── convert.sh//转换程序</span><br><span class="line">├── icon.png//输入文件</span><br><span class="line">└── sizes.txt//目标尺寸</span><br></pre></td></tr></tbody></table></figure><p>使用步骤如下：</p><ol type="1"><li>替换 icon.png 文件为需要转换的文件</li><li>修改 sizes.txt 文件，编辑目标尺寸，每一行为一个尺寸</li><li>控制台运行 <code>./convert.sh</code> 即可</li></ol><p>为了很方便的让设计师同学使用这个工具，我在她的电脑上安装了一个 <a href="https://github.com/jbtule/cdto" target="_blank" rel="noopener">cdto</a> 工具，可以在当前 finder 目录下打开 控制台。还把这个工具拖到了 finder 的左侧快捷方式。PS: 用户接口要友好。。。</p><h1 id="源码">源码</h1><p>源码和配置文件都放在 <a href="https://github.com/kevinho/image-resizer" target="_blank" rel="noopener">github</a> 上。</p><h1 id="todo">TODO</h1><ol type="1"><li>目前只支持 png</li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;家有设计师&quot;&gt;家有设计师&lt;/h1&gt;
&lt;p&gt;我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。&lt;/p&gt;
&lt;p&gt;看了她导了好几次，实在不能忍。得发挥程序员的能动性，做个小工具。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="产品" scheme="https://kvh.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验" scheme="https://kvh.io/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊 Alexa Echo Dot——入门</title>
    <link href="https://kvh.io/play-alexa-1.html"/>
    <id>https://kvh.io/play-alexa-1.html</id>
    <published>2017-03-21T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.826Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="智能家居">智能家居</h1><p>大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。</p><p>亚马逊的 <a href="https://en.wikipedia.org/wiki/Amazon_Echo" target="_blank" rel="noopener">Alexa Echo</a> 无疑是这个浪潮中的当红明星。</p><p>它是一个蓝牙音箱，是一个智能语音助手，是一个智能家居管理中心，它还提供了开放平台，允许第三方添加 <code>Skills</code> 来扩充功能。</p><p>本篇介绍一些购买和基本使用经验。</p><h1 id="购买">购买</h1><p>在经过几代的发展之后，目前这个产品主要包含 <code>Echo</code> 和 <code>Echo Dot</code>。主要的区别是扬声器的规格。</p><p>如下图： <img src="https://img.kvh.io/17-3-21/77023898-file_1490061698677_e03e.jpg" alt="Amazon-Echo"></p><figure><img src="https://img.kvh.io/17-3-21/7885364-file_1490061698538_1047c.jpg" alt="Amazon-Echo-Dot"><figcaption aria-hidden="true">Amazon-Echo-Dot</figcaption></figure><p>Echo Dot 价格要亲民一些，500人民币左右，某宝可购买。</p><p>下单后很快到货，就是这么一个小盒子：</p><figure><img src="https://img.kvh.io/17-3-21/17973801-file_1490061841802_10892.jpg" alt="Echo-Dot-实物"><figcaption aria-hidden="true">Echo-Dot-实物</figcaption></figure><h1 id="基础介绍">基础介绍</h1><p>顶部有四个按钮，功能分别是，分别是：静音、操控、音量加减。</p><p>背面有两个插槽，分别是 3.5 mm 声频输出口、Micro-USB 电源插口。</p><p>Echo Dot 需要一个叫做 <code>Alexa App</code>的手机软件作为控制端，下面提供 Android 和 iOS 平台的下载地址。</p><p><a href="https://play.google.com/store/apps/details?id=com.amazon.dee.app" target="_blank" rel="noopener">Android-App</a></p><p><a href="https://itunes.apple.com/us/app/amazon-echo/id944011620" target="_blank" rel="noopener">iOS-App</a></p><blockquote><p>注意在 iOS 平台上，这个 App 只允许美国区的账户进行下载。你可以折腾一下，注册一个美国区的 Apple ID，可能需要绑定信用卡。你也可以花钱买时间，在万能的某宝上买一个美国区账号。我选择了后者。</p></blockquote><h1 id="基础设置">基础设置</h1><p>Echo Dot 是需要连接到 WiFi 进行工作的，这就需要用 Alexa App 进行绑定和设置。</p><p>如果你曾经用过小米的空气净化器，你会发现设置的模式类似。</p><p>主要步骤为：EchoDot 进入设定模式、手机连上 Echo Dot 共享的 WiFi、操作 Echo Dot 连接家里的 WiFi。</p><p>1.长按 Echo Dot 顶部的操控键，会有提示进入设定模式(enter setup mode)；</p><p>2.在手机的 WiFi 设置页面，可以看到名字为 Amazon-XXX 的 WiFi，连接上去，会有提示：(connected)；</p><p>3.进入 Alexa App，在里面选择家里的 WiFi，输入密码，确定之后，Echo Dot 会尝试进行连接。</p><blockquote><p>连接中，主要发现两个问题，一是卡，二是根本连不上。因为 Alexa 的服务器在国外，速度受一定的影响，卡是正常的。然而国内的网络环境比较复杂，例如我就遇到过家里的<code>方正宽带</code>下的 WiFi，根本连不上的情况。后来我只能使用手机的联通4G 开热点才能勉强使用。公司的电信宽带也没有问题。后面网络续费的时候，看来要换成电信或者联通了。</p></blockquote><h1 id="基础使用">基础使用</h1><p>Echo Dot 连接上网络之后，你就可以跟它对话了。默认唤醒口令是 <code>Alexa</code>。唤醒之后灯会亮。</p><p>例如就可以试一下，<code>Alexa, what's the weather</code>。它可能会告诉你美国西雅图现在的天气，地址可以在 Alexa App 中设置。（ps：我还没有找到设置成北京的方式）</p><h1 id="一些后续">一些后续</h1><p>Alexa Echo 提供了开放平台，开发者可以将服务打包成 <code>Skills</code> 对系统进行扩展，这个就有点像苹果的 iOS 生态了。厂商只提供基础的服务和功能，开发者百花齐放。用户可以在 Alexa App 中添加 Skills，例如你可以添加一个读 CNN 新闻的功能。这一块还有待探索。</p><p>网络问题很严重，反应速度比较慢。后面如果想要愉快玩耍，还是得找一个比较好的联网方案。某一天亚马逊可以把服务器放一些到国内，就更好了。</p><h1 id="总结">总结</h1><p>Alexa Echo Dot 入门初步介绍了购买、设置、使用。下面继续探索。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;智能家居&quot;&gt;智能家居&lt;/h1&gt;
&lt;p&gt;大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。&lt;/p&gt;
&lt;p&gt;亚马逊的 &lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="product" scheme="https://kvh.io/categories/product/"/>
    
    
      <category term="产品" scheme="https://kvh.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验" scheme="https://kvh.io/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>读一首诗——纪伯伦《孩子》</title>
    <link href="https://kvh.io/on-children.html"/>
    <id>https://kvh.io/on-children.html</id>
    <published>2016-10-07T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.825Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（Kahlil Gibran）的《孩子》，很有感触。将冰心的译文和原文奉上。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">孩　　子</span><br><span class="line"> </span><br><span class="line">你们的孩子，都不是你们的孩子。</span><br><span class="line">乃是生命为自己所渴望的儿女。</span><br><span class="line">他们是凭借你们而来，却不是从你们而来，</span><br><span class="line">他们虽和你们同在，却不属于你们。</span><br><span class="line"></span><br><span class="line">你们可以给他们以爱，却不可给他们以思想。</span><br><span class="line">因为他们有自己的思想。</span><br><span class="line">你们可以荫庇他们的身体，却不能荫庇他们的灵魂。</span><br><span class="line">因为他们的灵魂，是住在明日的宅中，那是你们在梦中也不能想见的。</span><br><span class="line">你们可以努力去模仿他们，却不能使他们来象你们。</span><br><span class="line">因为生命是不倒行的，也不与昨日一同停留。</span><br><span class="line">你们是弓，你们的孩子是从弦上发出的生命的箭矢。</span><br><span class="line">那射者在无穷之中看定了目标，也用神力将你们引满，使他的箭矢迅速而遥远地射了出去。</span><br><span class="line">让你们在射者手中的弯曲成为喜乐罢；</span><br><span class="line">因为他爱那飞出的箭，也爱了那静止的弓。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">On Children</span><br><span class="line"></span><br><span class="line">Your children are not your children.</span><br><span class="line">They are the sons and daughters of Life's longing for itself.</span><br><span class="line">They come through you but not from you,</span><br><span class="line">And though they are with you yet they belong not to you.</span><br><span class="line"></span><br><span class="line">You may give them your love but not your thoughts, </span><br><span class="line">For they have their own thoughts.</span><br><span class="line">You may house their bodies but not their souls,</span><br><span class="line">For their souls dwell in the house of tomorrow, </span><br><span class="line">which you cannot visit, not even in your dreams.</span><br><span class="line">You may strive to be like them, </span><br><span class="line">but seek not to make them like you.</span><br><span class="line">For life goes not backward nor tarries with yesterday.</span><br><span class="line"></span><br><span class="line">You are the bows from which your children</span><br><span class="line">as living arrows are sent forth.</span><br><span class="line">The archer sees the mark upon the path of the infinite, </span><br><span class="line">and He bends you with His might </span><br><span class="line">that His arrows may go swift and far.</span><br><span class="line">Let your bending in the archer's hand be for gladness;</span><br><span class="line">For even as He loves the arrow that flies, </span><br><span class="line">so He loves also the bow that is stable.</span><br></pre></td></tr></tbody></table></figure><p>这首诗，来自纪伯伦的名作《先知》。</p><p>相信每一个人，在不同的阶段，读到这首诗的感受，是不一样的。</p><p>年少的时候，觉得父母老师管束自己，想要自由，可能会以此诗句来抗争——看，纪伯伦说了……。</p><p>长大了，离开父母上学，父母还是希望给更多的意见，你却总觉得父母的意见不合时宜。</p><p>工作了，经济自由了，在享受自由的那一瞬间，却开始想父母了。你慢慢的发现，自己身上的思想与习惯，很多都是源自来自父母。</p><p>若干年后，父母在你该找谁结婚这事儿上，干预未果，你想，抗争终于成功了。</p><p>不久，你也终于为人父母，才感叹，当父母真不容易。既当弓，又为箭。</p><p>再过若干年，自己的孩子也到了叛逆期，你还是希望像当年自己的父母一样，把自己曾经犯过的错，提前告诉孩子。</p><p>你却发现，每个人该犯的错误，该趟的坑，一个都少不了。你，却只能在旁边看着，就像当年你的父母一样。</p><p>孩子终于活出了自己的世界，你发现，原来每一个人都有自己的命运，只要努力，还是有机会。</p><p>每个人的每个阶段，都有自己的局限和使命。努力，活在当下就好。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（Kahlil Gibran）的《孩子》，很有感触。将冰心的译文和原文奉上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SDK 开发最佳实践之一：为你的 SDK 增加 No-Op 版本</title>
    <link href="https://kvh.io/sdk-noop.html"/>
    <id>https://kvh.io/sdk-noop.html</id>
    <published>2016-09-29T03:20:30.000Z</published>
    <updated>2021-01-13T01:42:18.829Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>笔者在开发和维护 Bugtags SDK 的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK 开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags 这样快速成长的 SDK。</p></blockquote><h1 id="sdk-的使用场景">SDK 的使用场景</h1><p>站在用户的角度来看，引入一个 SDK 可能会带来几方面的问题： - 包增大 - 可能不稳定 - 安全性问题</p><p>对于一些 SDK，产品形态是允许在测试阶段开启，上线移除的，例如性能调试工具，测试工具等。</p><h1 id="区分版本方案">区分版本方案</h1><p>最简单的，就是手动注释代码，应用中如果只使用了这个 SDK 的一个 API，那还好，如果用到了多个，分布在不同的文件中， 这事儿就麻烦了。很不优雅。</p><h1 id="最优雅的方案">最优雅的方案</h1><p>思考一下这个需求</p><ul><li>应用分为 debug/release 版本</li><li>无痛切换，最好能够实现自动化</li></ul><p>大部分的编译系统，例如 Gradle/Maven 都可以区分版本，引入不同的包。利用这个特性，我们可以实现一个 No-Op SDK。</p><p>这个 SDK 具有如下特点：</p><ul><li>具有正式 SDK 的所有可以被外部引用的类</li><li>具有正式 SDK 的所有对外 API</li><li>足够的精简</li><li>提示正在使用 No-Op SDK</li></ul><h1 id="最后的结果">最后的结果</h1><p>以 bugtags 为例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile 'com.bugtags.library:bugtags-lib:2.0.0'</span><br><span class="line">releaseCompile 'com.bugtags.library:bugtags-noop:2.0.0'</span><br></pre></td></tr></tbody></table></figure><p>以 leakcanary 为例： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5'</span><br><span class="line">releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="扩展">扩展</h1><p>如果你是一个 SDK 的使用者，即便官方没有提供 No-Op 版本，你完全可以自己写一个。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;笔者在开发和维护 Bugtags SDK 的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK 开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags 这样快
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="SDK" scheme="https://kvh.io/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 构建系统·初探</title>
    <link href="https://kvh.io/gradle-build-system-overview.html"/>
    <id>https://kvh.io/gradle-build-system-overview.html</id>
    <published>2016-08-13T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.824Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>8月7号，应<a href="http://www.chinagdg.com/thread-3462-1-1.html" target="_blank" rel="noopener">北京 GDG</a> 邀请，我做了一个题为《Android Gradle 构建系统·初探》的分享。</p><p>主要内容是构建系统背景知识，源码库，代码亮点，写插件。</p><p>很明显这是一个很大的话题，有超过 2.5GB 的核心代码和超过50个子项目。</p><p>第一步，我进行了宏观的介绍。下一步，我会继续深入子项目，尝试发现更多有意思的点。</p><p>对这个话题感兴趣的，请加入技术交流 qq 群：583688711。</p><p>Slides 在下面，分别是 PDF 版本和图片版本。</p><p><a href="https://img.kvh.io/static/Android%20Gradle%20Build%20System-Overview-wide-screen.pdf" target="_blank" rel="noopener">PDF here</a>.</p><p>图片：</p><p><img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.001.jpeg" alt="Android-Gradle-Build-System-Overview.001.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.002.jpeg" alt="Android-Gradle-Build-System-Overview.002.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.003.jpeg" alt="Android-Gradle-Build-System-Overview.003.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.004.jpeg" alt="Android-Gradle-Build-System-Overview.004.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.005.jpeg" alt="Android-Gradle-Build-System-Overview.005.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.006.jpeg" alt="Android-Gradle-Build-System-Overview.006.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.007.jpeg" alt="Android-Gradle-Build-System-Overview.007.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.008.jpeg" alt="Android-Gradle-Build-System-Overview.008.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.009.jpeg" alt="Android-Gradle-Build-System-Overview.009.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.010.jpeg" alt="Android-Gradle-Build-System-Overview.010.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.011.jpeg" alt="Android-Gradle-Build-System-Overview.011.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.012.jpeg" alt="Android-Gradle-Build-System-Overview.012.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.013.jpeg" alt="Android-Gradle-Build-System-Overview.013.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.014.jpeg" alt="Android-Gradle-Build-System-Overview.014.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.015.jpeg" alt="Android-Gradle-Build-System-Overview.015.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.016.jpeg" alt="Android-Gradle-Build-System-Overview.016.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.017.jpeg" alt="Android-Gradle-Build-System-Overview.017.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.018.jpeg" alt="Android-Gradle-Build-System-Overview.018.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.019.jpeg" alt="Android-Gradle-Build-System-Overview.019.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.020.jpeg" alt="Android-Gradle-Build-System-Overview.020.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.021.jpeg" alt="Android-Gradle-Build-System-Overview.021.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.022.jpeg" alt="Android-Gradle-Build-System-Overview.022.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.023.jpeg" alt="Android-Gradle-Build-System-Overview.023.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.024.jpeg" alt="Android-Gradle-Build-System-Overview.024.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.025.jpeg" alt="Android-Gradle-Build-System-Overview.025.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.026.jpeg" alt="Android-Gradle-Build-System-Overview.026.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.027.jpeg" alt="Android-Gradle-Build-System-Overview.027.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.028.jpeg" alt="Android-Gradle-Build-System-Overview.028.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.029.jpeg" alt="Android-Gradle-Build-System-Overview.029.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.030.jpeg" alt="Android-Gradle-Build-System-Overview.030.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.031.jpeg" alt="Android-Gradle-Build-System-Overview.031.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.032.jpeg" alt="Android-Gradle-Build-System-Overview.032.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.033.jpeg" alt="Android-Gradle-Build-System-Overview.033.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.034.jpeg" alt="Android-Gradle-Build-System-Overview.034.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.035.jpeg" alt="Android-Gradle-Build-System-Overview.035.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.036.jpeg" alt="Android-Gradle-Build-System-Overview.036.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.037.jpeg" alt="Android-Gradle-Build-System-Overview.037.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.038.jpeg" alt="Android-Gradle-Build-System-Overview.038.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.039.jpeg" alt="Android-Gradle-Build-System-Overview.039.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.040.jpeg" alt="Android-Gradle-Build-System-Overview.040.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.041.jpeg" alt="Android-Gradle-Build-System-Overview.041.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.042.jpeg" alt="Android-Gradle-Build-System-Overview.042.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.043.jpeg" alt="Android-Gradle-Build-System-Overview.043.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.044.jpeg" alt="Android-Gradle-Build-System-Overview.044.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.045.jpeg" alt="Android-Gradle-Build-System-Overview.045.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.046.jpeg" alt="Android-Gradle-Build-System-Overview.046.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.047.jpeg" alt="Android-Gradle-Build-System-Overview.047.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.048.jpeg" alt="Android-Gradle-Build-System-Overview.048.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.049.jpeg" alt="Android-Gradle-Build-System-Overview.049.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.050.jpeg" alt="Android-Gradle-Build-System-Overview.050.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.051.jpeg" alt="Android-Gradle-Build-System-Overview.051.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.052.jpeg" alt="Android-Gradle-Build-System-Overview.052.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.053.jpeg" alt="Android-Gradle-Build-System-Overview.053.jpeg"> <img src="https://img.kvh.io/2016/08/13/Android-Gradle-Build-System-Overview.054.jpeg" alt="Android-Gradle-Build-System-Overview.054.jpeg"></p><blockquote><p>有问题？在文章下留言或者加 qq 群：583688711，希望能帮到你。</p></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;8月7号，应&lt;a href=&quot;http://www.chinagdg.com/thread-3462-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;北京 GDG&lt;/a&gt; 邀请，我做了一个题
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Android" scheme="https://kvh.io/tags/Android/"/>
    
      <category term="Gradle" scheme="https://kvh.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 技巧之二： 最爱命令行</title>
    <link href="https://kvh.io/gradle-indepth-cmd.html"/>
    <id>https://kvh.io/gradle-indepth-cmd.html</id>
    <published>2016-06-04T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.825Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。</p><h1 id="命令行">命令行</h1><p>很多做 Android 开发不久的同学，习惯于使用图形界面，对命令行操作很陌生甚至恐惧。遇到 AS 运行错误，束手无策。</p><p>AS 为了确保易用性，也在 UI 界面上屏蔽了很多命令行运行的细节，导致很多人觉得 AS 难用。</p><p>这种情况，我在解决用户集成使用 Bugtags SDK 的问题的时候，经常能遇到。其实 GUI 界面的操作，绝大部分情况下，也是基于命令工具的。如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。 # 典型错误 AS 刚推出的时候，stackoverflow 上询问最多的问题，便是进入项目的时候，一直处于：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gradle: resolve dependancies '_debugCompile'</span><br></pre></td></tr></tbody></table></figure><p>状态，一直无法前进，到底 IDE 在做什么呢？看不出来。</p><h1 id="一句命令行">一句命令行</h1><p>当用户遇到问题时，我最常提醒用户使用的是在项目根目录下，运行如下命令行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac:</span><br><span class="line">./gradlew clean build --info &gt; bugtags.log</span><br><span class="line"></span><br><span class="line">windows:</span><br><span class="line">gradlew.bat clean build --info &gt; bugtags.log</span><br></pre></td></tr></tbody></table></figure><p>这个命令行的意思，是运行 clean 和 build 两个 gradle task，并且打开 info 参数使得输出更多的信息，最终把所有输出的信息，输出到项目根目录下的 bugtags.log 文件。用户把这个文件发给我，我根据这个输出文件，通常就能分析出问题所在。</p><p>假设命令行去除重定向输指令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean build --info</span><br></pre></td></tr></tbody></table></figure><p>信息将会输出在控制台，刚才提到的那个典型错误，可能是这样的：</p><figure><img src="https://img.kvh.io/16-6-5/15681897.jpg" alt="cmd-output"><figcaption aria-hidden="true">cmd-output</figcaption></figure><p>其实是在下载一个比较大的文件，不用惊慌，你要做的就是 just wait! 至于是在下载什么。我想在下一篇详细描述。</p><p>如果你对基本的命令行知识有所了解，前面就已经足够了，如果你想了解更多，请继续。</p><h1 id="扩展">扩展</h1><h2 id="在哪运行">在哪运行</h2><p>当我给出这个命令的时候，最常见的问题，就是在哪运行。答案是控制台（Terminal）。</p><h3 id="控制台">控制台</h3><p>在 mac 下，有 terminal（bash/zsh 等），在 windows 下，则是 powershell 或者 cmd。</p><p>关键一点：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br></pre></td></tr></tbody></table></figure><blockquote><p>AS 在使用 Gradle 的时候，为了灵活，或者为了应对 Gradle 系统的快速迭代，推荐使用在项目根目录中放置 Gradle 的 wrapper：gradlew 来实现对不同版本的使用。</p></blockquote><p>因此，在控制台运行命令，主要是跟 <code>gradlew</code> 打交道。这个 wrapper，在 mac 下是一个具有执行权限的文件：<code>gradlew</code>，在 windows 下，是一个批处理文件：<code>gradlew.bat</code>。</p><p>通常，mac 下在当前目录下运行可执行文件是这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew xxx</span><br></pre></td></tr></tbody></table></figure><p>windows 下在当前目录下运行批处理文件是这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew.bat xxx</span><br></pre></td></tr></tbody></table></figure><h3 id="terminal-插件">Terminal 插件</h3><p>AS（Intellij IDEA）已经做了一个很实用的插件：</p><figure><img src="https://img.kvh.io/16-6-5/3873932.jpg" alt="as-terminal"><figcaption aria-hidden="true">as-terminal</figcaption></figure><p>点击 Terminal，AS 会帮你完成下面的操作：</p><ul><li>模拟打开 terminal</li><li>cd 到当前项目根目录下</li></ul><h3 id="快速定位文件夹">快速定位文件夹</h3><p>IDE 还支持将项目中的某个文件夹拖放到 Terminal 窗口中实现快速定位到这个文件夹：</p><figure><img src="https://img.kvh.io/16-6-5/94595004.jpg" alt="terminal-drag-location"><figcaption aria-hidden="true">terminal-drag-location</figcaption></figure><h2 id="使用-help">使用 help</h2><p>要知道都有哪些 gradle 命令运行的参数，可以使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew --help</span><br><span class="line"></span><br><span class="line">USAGE: gradlew [option...] [task...]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>来获取。下面列举几个重要的参数。</p><h2 id="build-某个指定-module">build 某个指定 module</h2><p>AS 推荐的结构是 <code>multiple project</code> 结构，即一个 project 下，管理多个 module，如果每次都要 build 全部的 project 的话，有点浪费时间，则可以使用 <code>-p module</code> 参数，其中 module 是你要 build 的 module：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app clean build</span><br></pre></td></tr></tbody></table></figure><h2 id="明确指定不执行某个-task">明确指定不执行某个 task</h2><p>Gradle 的命令存在依赖，例如 build task，是依赖于一系列的其他的 task，如果想要指定不执行某个 task，则可以使用 <code>-x task</code> 参数，其中 task 是要忽略的那个，这个参数可以传递多次。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew build -x test -x lint</span><br></pre></td></tr></tbody></table></figure><h1 id="总结">总结</h1><p>Gradle 的命令行还有很多其他技巧，上面只是列举到了本人日常用到最多的几个。有兴趣可以留言深入讨论。</p><h1 id="参考资料">参考资料</h1><p><a href="http://blog.csdn.net/stpeace/article/details/9021641" target="_blank" rel="noopener">mac-terminal</a></p><p><a href="http://blog.csdn.net/stpeace/article/details/9021641" target="_blank" rel="noopener">windows-terminal</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。&lt;/p&gt;
&lt;h1 id=&quot;命令行&quot;&gt;命令行&lt;/h1&gt;
&lt;p&gt;很多做 Android 开发不久的同学，习惯于使用图形界面，对命令行操作很陌生甚至恐惧。遇到 AS 运行错
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Android" scheme="https://kvh.io/tags/Android/"/>
    
      <category term="Gradle 技巧" scheme="https://kvh.io/tags/Gradle-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 技巧之一： Build Variant 相关</title>
    <link href="https://kvh.io/gradle-indepth-build-variant.html"/>
    <id>https://kvh.io/gradle-indepth-build-variant.html</id>
    <published>2016-06-03T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.824Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="build-variant">Build Variant</h1><p>android gradle 插件，允许对最终的包以多个维度进行组合。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuildVariant = ProductFlavor x BuildType</span><br></pre></td></tr></tbody></table></figure><h2 id="两个维度">两个维度</h2><p>最常见的就是这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">productFlavors {</span><br><span class="line">    pro {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fre {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">lintOptions {</span><br><span class="line">    abortOnError false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buildTypes {</span><br><span class="line">    debug {</span><br><span class="line">    }</span><br><span class="line">    release {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，buildTypes 一般都会有 debug 或者release，标示编译的类型，通常在混淆代码、可调式、资源压缩上做一些区分。 productFlavor 则为了满足“同一个project，根据一个很小的区分，来打不同的包”这个需求。</p><p>这两个维度的组合，会产生如下包：</p><ul><li>proDebug</li><li>proRelease</li><li>freDebug</li><li>proRelease</li></ul><h2 id="更多的维度">更多的维度</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions 'abi', 'version'</span><br><span class="line"></span><br><span class="line">productFlavors {</span><br><span class="line">    pro {</span><br><span class="line">        dimension 'version'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fre {</span><br><span class="line">        dimension 'version'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    arm {</span><br><span class="line">        dimension 'abi'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mips {</span><br><span class="line">        dimension 'abi'</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buildTypes {</span><br><span class="line">    debug {</span><br><span class="line">    }</span><br><span class="line">    release {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>productFlavor 本身定义了2个维度，记上 buildType，则有三个维度，会产生如下的包：</p><ul><li>armProDebug</li><li>armProRelease</li><li>armFreDebug</li><li>armFreRelease</li><li>mipsProDebug</li><li>mipsProRelease</li><li>mipsFreDebug</li><li>mipsFreRelease</li></ul><p>其中每个维度组合，都可以设置本身的 dependency、test source。下面做一个举例。</p><h1 id="flavor-与-dependency">Flavor 与 Dependency</h1><h2 id="需求">需求</h2><p>module 中有若干个 flavors，例如：fre 和 pro，分别依赖不同的库，这些库有的是本地 jar 库，有的是远程库。</p><h2 id="方案">方案</h2><figure><img src="https://img.kvh.io/16-6-3/75851013.jpg?imageView2/2/w/640/h/640" alt="flavor-dependency"><figcaption aria-hidden="true">flavor-dependency</figcaption></figure><h1 id="遍历-build-variant">遍历 Build Variant</h1><h2 id="需求-1">需求</h2><p>Bugtags 的 android sdk，有一个自动上传符号表功能， 在最初，是这样配置的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.bugtags.library.plugin'</span><br><span class="line">bugtags {</span><br><span class="line">    appKey "APP_KEY"</span><br><span class="line">    appSecret  "APP_SECRET"</span><br><span class="line">    mappingUploadEnabled false</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后来，我们增加了一个 beta-live 的机制，用来区分测试和上线的 APP，这样，同一个 APP，就有两套 APP_KEY 和 APP_SECRET 了，很明显上方的配置方式就不在适用。</p><h2 id="方案-1">方案</h2><p>android gradle 插件提供了 android.applicationVariants 索引来遍历所有的 build variant 后来，我们采取了一个方案，遍历 Build Variant，设置 extension 信息来兼容这种需求。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate {</span><br><span class="line">    android.applicationVariants.each { variant -&gt;</span><br><span class="line">        def bugtagsAppKey = null;</span><br><span class="line">        def bugtagsAppSecret = null;</span><br><span class="line"></span><br><span class="line">        if (variant.name.contains("debug")) {</span><br><span class="line">            bugtagsAppKey = 'APP_KEY_BETA'</span><br><span class="line">            bugtagsAppSecret = 'APP_SECRET_BETA'</span><br><span class="line">        } else if (variant.name.contains("release")) {</span><br><span class="line">            bugtagsAppKey = 'APP_KEY_LIVE'</span><br><span class="line">            bugtagsAppSecret = 'APP_SECRET_LIVE'</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        variant.ext.bugtagsAppKey = bugtagsAppKey</span><br><span class="line">        variant.ext.bugtagsAppSecret = bugtagsAppSecret</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: 'com.bugtags.library.plugin'</span><br></pre></td></tr></tbody></table></figure><h1 id="总结">总结</h1><p>本文主要是介绍了 build variant 的概念，还介绍了两个日常应用案例。希望对大家有帮助。</p><h1 id="参考资料">参考资料</h1><p><a href="http://tools.android.com/tech-docs/new-build-system" target="_blank" rel="noopener">android-build-tool</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;build-variant&quot;&gt;Build Variant&lt;/h1&gt;
&lt;p&gt;android gradle 插件，允许对最终的包以多个维度进行组合。&lt;/p&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Android" scheme="https://kvh.io/tags/Android/"/>
    
      <category term="Gradle 技巧" scheme="https://kvh.io/tags/Gradle-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>拥抱 Android Studio 之五：Gradle 插件开发</title>
    <link href="https://kvh.io/embrace-android-studio-gradle-plugin.html"/>
    <id>https://kvh.io/embrace-android-studio-gradle-plugin.html</id>
    <published>2016-03-28T03:20:30.000Z</published>
    <updated>2021-01-13T01:42:18.823Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener">官方文档</a>给出了比较详细的实现步骤，本文的脉络会跟官方文档差不了太多，额外增补实际例子和一些实践经验。文中的代码已经托管到了 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo" target="_blank" rel="noopener">github 项目</a>中。</p><h1 id="需求">需求</h1><p>默认的 Android 打包插件会把 apk 命名成 <code>module-productFlavor-buildType.apk</code>，例如 <code>app-official-debug.apk</code>，并且会把包文件发布到固定的位置： <code>module/build/outputs/apk</code> 有的时候，这个命名风格并不是你所要的，你也想讲 apk 输出到别的目录。咱们通过 gradle 插件来实现自定义。这个插件的需求是：</p><ul><li>输入一个名为 nameMap 的 Closure，用来修改 apk 名字</li><li>输入一个名为 destDir 的 String，用于输出位置</li></ul><h1 id="原理简述">原理简述</h1><h2 id="插件之于-gradle">插件之于 Gradle</h2><p>根据官方文档定义，插件打包了可重用的构建逻辑，可以适用于不同的项目和构建过程。</p><p>Gradle 提供了很多官方插件，用于支持 Java、Groovy 等工程的构建和打包。同时也提供了自定义插件的机制，让每个人都可以通过插件来实现特定的构建逻辑，并可以把这些逻辑打包起来，分享给其他人。</p><p>插件的源码可以使用 Groovy、Scala、Java 三种语言，笔者不会 Scala，所以平时只是使用 Groovy 和 Java。前者用于实现与 Gradle 构建生命周期（如 task 的依赖）有关的逻辑，后者用于核心逻辑，表现为 Groovy 调用 Java 的代码。</p><p>另外，还有很多项目使用 Eclipse 或者 Maven 进行开发构建，用 Java 实现核心业务代码，将有利于实现快速迁移。</p><h2 id="插件打包方式">插件打包方式</h2><p>Gradle 的插件有三种打包方式，主要是按照复杂程度和可见性来划分： ### Build script 把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见，笔者常用来做原型调试，本文将简要介绍此类。 ### buildSrc 项目 将插件源代码放在 <code>rootProjectDir/buildSrc/src/main/groovy</code> 中，只对该项目中可见，适用于逻辑较为复杂，但又不需要外部可见的插件，本文不介绍，有兴趣可以参考<a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html#sec:build_sources" target="_blank" rel="noopener">此处</a>。 ### 独立项目 一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。</p><h1 id="build-script-插件">Build script 插件</h1><p>首先来直接在 build.gradle 中写一个 plugin：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistPlugin implements Plugin&lt;Project&gt; {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line">        project.task('apkdist') &lt;&lt; {</span><br><span class="line">            println 'hello, world!'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: ApkDistPlugin</span><br></pre></td></tr></tbody></table></figure><p>命令行运行</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app/ apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br></pre></td></tr></tbody></table></figure><p>这个插件创建了一个名为 <code>apkdist</code> 的 task，并在 task 中打印。</p><p>插件是一个类，继承自 <code>org.gradle.api.Plugin</code> 接口，重写 <code>void apply(Project project)</code> 方法，这个方法将会传入使用这个插件的 project 的实例，这是一个重要的 context。</p><h2 id="接受外部参数">接受外部参数</h2><p>通常情况下，插件使用方需要传入一些配置参数，如 bugtags 的 SDK 的插件需要接受两个参数:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bugtags {</span><br><span class="line">    appKey "APP_KEY"  //这里是你的 appKey</span><br><span class="line">    appSecret "APP_SECRET"    //这里是你的 appSecret，管理员在设置页可以查看</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样，ApkDistPlugin 这个 plugin 也希望接受两个参数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apkdistconf {</span><br><span class="line">    nameMap { name -&gt;</span><br><span class="line">        println 'hello,' + name</span><br><span class="line">        return name</span><br><span class="line">    }</span><br><span class="line">    destDir 'your-distribution-dir'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参数的内容后面继续完善。那这两个参数怎么传到插件内呢？</p><p><code>org.gradle.api.Project</code> 有一个 <code>ExtensionContainer getExtensions()</code> 方法，可以用来实现这个传递。</p><h3 id="声明参数类">声明参数类</h3><p>声明一个 Groovy 类，有两个默认值为 null 的成员变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistExtension {</span><br><span class="line">    Closure nameMap = null;</span><br><span class="line">    String destDir = null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接受参数">接受参数</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.extensions.create('apkdistconf', ApkDistExtension);</span><br></pre></td></tr></tbody></table></figure><p>要注意，<code>create</code> 方法的第一个参数就是你在 build.gradle 文件中的进行参数配置的 dsl 的名字，必须一致；第二个参数，就是参数类的名字。</p><h3 id="获取和使用参数">获取和使用参数</h3><p>在 create 了 extension 之后，如果传入了参数，则会携带在 project 实例中，</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def closure = project['apkdistconf'].nameMap;</span><br><span class="line">closure('wow!');</span><br><span class="line"></span><br><span class="line">println project['apkdistconf'].destDir</span><br></pre></td></tr></tbody></table></figure><h3 id="进化版本一参数">进化版本一：参数</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistExtension {</span><br><span class="line">    Closure nameMap = null;</span><br><span class="line">    String destDir = null;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ApkDistPlugin implements Plugin&lt;Project&gt; {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line"></span><br><span class="line">        project.extensions.create('apkdistconf', ApkDistExtension);</span><br><span class="line"></span><br><span class="line">        project.task('apkdist') &lt;&lt; {</span><br><span class="line">            println 'hello, world!'</span><br><span class="line"></span><br><span class="line">            def closure = project['apkdistconf'].nameMap;</span><br><span class="line">            closure('wow!');</span><br><span class="line"></span><br><span class="line">            println project['apkdistconf'].destDir</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: ApkDistPlugin</span><br><span class="line"></span><br><span class="line">apkdistconf {</span><br><span class="line">    nameMap { name -&gt;</span><br><span class="line">        println 'hello, ' + name</span><br><span class="line">        return name</span><br><span class="line">    }</span><br><span class="line">    destDir 'your-distribution-directory'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app/ apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br><span class="line">hello, wow!</span><br><span class="line">your-distribution-directory</span><br></pre></td></tr></tbody></table></figure><h1 id="独立项目插件">独立项目插件</h1><p>代码写到现在，已经不适合再放在一个 build.gradle 文件里面了，那也不是我们的目的。建立一个独立项目，把代码搬到对应的地方。</p><p>理论上，IntelliJ IDEA 开发插件要比 Android Studio 要方便一点点，因为有对应 Groovy module 的模板。但其实如果我们了解 IDEA 的项目文件结构，就不会受到这个局限，无非就是一个 build.gradle 构建文件加 src 源码文件夹。</p><p>最终项目的文件夹结构是这样：</p><figure><img src="https://img.kvh.io/16-3-4/6224454.jpg" alt="Java-Library"><figcaption aria-hidden="true">Java-Library</figcaption></figure><p>下面我们来一步步讲解。 ## 创建项目 在 Android Studio 中新建 <code>Java Library</code> module <code>“plugin”</code>。</p><h2 id="修改-build.gradle-文件">修改 build.gradle 文件</h2><p>添加 Groovy 插件和对应的两个依赖。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//removed java plugin </span><br><span class="line">apply plugin: 'groovy'</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line">    compile gradleApi()//gradle sdk</span><br><span class="line">    compile localGroovy()//groovy sdk</span><br><span class="line">    compile fileTree(dir: 'libs', include: ['*.jar'])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="修改项目文件夹">修改项目文件夹</h2><p>src/main 项目文件下：</p><ul><li>移除 java 文件夹，因为在这个项目中用不到 java 代码</li><li>添加 groovy 文件夹，主要的代码文件放在这里</li><li>添加 resources 文件夹，存放用于标识 gradle 插件的 meta-data</li></ul><h2 id="建立对应文件">建立对应文件</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── libs</span><br><span class="line">├── plugin.iml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── groovy</span><br><span class="line">        │&nbsp;&nbsp; └── com</span><br><span class="line">        │&nbsp;&nbsp;     └── asgradle</span><br><span class="line">        │&nbsp;&nbsp;         └── plugin</span><br><span class="line">        │&nbsp;&nbsp;             ├── ApkDistExtension.groovy</span><br><span class="line">        │&nbsp;&nbsp;             └── ApkDistPlugin.groovy</span><br><span class="line">        └── resources</span><br><span class="line">            └── META-INF</span><br><span class="line">                └── gradle-plugins</span><br><span class="line">                    └── com.asgradle.apkdist.properties</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>groovy 文件夹中的类，一定要修改成 <code>.groovy</code> 后缀，IDE 才会正常识别。</li><li>resources/META-INF/gradle-plugins 这个文件夹结构是强制要求的，否则不能识别成插件。</li></ul><h2 id="com.asgradle.apkdist.properties-文件">com.asgradle.apkdist.properties 文件</h2><p>如果写过 Java 的同学会知道，这是一个 Java 的 properties 文件，是 <code>key=value</code> 的格式。这个文件内容如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.asgradle.plugin.ApkDistPlugin</span><br></pre></td></tr></tbody></table></figure><p>按其语义推断，是指定这个插件的入口类。</p><ul><li><p>英文敏感的同学可能会问了，为什么这个文件的承载文件夹是叫做 <code>gradle-plugins</code>，使用复数？没错，这里可以指定多个 properties 文件，定义多个插件，扩展性一流，可以参考 <a href="https://github.com/linkedin/gradle-plugins/tree/master/buildSrc/src/main/resources/META-INF/gradle-plugins" target="_blank" rel="noopener">linkedin</a> 的插件的组织方式。</p></li><li><p>使用这个插件的时候，将会是这样：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:'com.asgradle.apkdist'</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><p>因此，<code>com.asgradle.apkdist</code> 这个字符串在这里，又称为这个插件的 id，不允许跟别的插件重复，取你拥有的域名的反向就不会错。</p><h2 id="将-plugin-module-传到本地-maven-仓库">将 plugin module 传到本地 maven 仓库</h2><p>参考上一篇：<a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建</a>，和对应的 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/tree/master/S4-MavenDeploy" target="_blank" rel="noopener">demo 项目</a>，将包传到本地仓库中进行测试。</p><h3 id="添加-gradle.properties">添加 gradle.properties</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PROJ_NAME=gradleplugin</span><br><span class="line">PROJ_ARTIFACTID=gradleplugin</span><br><span class="line">PROJ_POM_NAME=Local Repository</span><br><span class="line"></span><br><span class="line">LOCAL_REPO_URL=file:///Users/changbinhe/Documents/Android/repo/</span><br><span class="line"></span><br><span class="line">PROJ_GROUP=com.as-gradle.demo</span><br><span class="line"></span><br><span class="line">PROJ_VERSION=1.0.0</span><br><span class="line">PROJ_VERSION_CODE=1</span><br><span class="line"></span><br><span class="line">PROJ_WEBSITEURL=http://kvh.io</span><br><span class="line">PROJ_ISSUETRACKERURL=https://github.com/kevinho/Embrace-Android-Studio-Demo/issues</span><br><span class="line">PROJ_VCSURL=https://github.com/kevinho/Embrace-Android-Studio-Demo.git</span><br><span class="line">PROJ_DESCRIPTION=demo apps for embracing android studio</span><br><span class="line"></span><br><span class="line">PROJ_LICENCE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">PROJ_LICENCE_DEST=repo</span><br><span class="line"></span><br><span class="line">DEVELOPER_ID=your-dev-id</span><br><span class="line">DEVELOPER_NAME=your-dev-name</span><br><span class="line">DEVELOPER_EMAIL=your-email@your-mailbox.com</span><br></pre></td></tr></tbody></table></figure><h3 id="在-build.gradle-添加上传功能">在 build.gradle 添加上传功能</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'maven'</span><br><span class="line"></span><br><span class="line">uploadArchives {</span><br><span class="line">    repositories.mavenDeployer {</span><br><span class="line">        repository(url: LOCAL_REPO_URL)</span><br><span class="line">        pom.groupId = PROJ_GROUP</span><br><span class="line">        pom.artifactId = PROJ_ARTIFACTID</span><br><span class="line">        pom.version = PROJ_VERSION</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上传可以通过运行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p plugin/ clean build uploadArchives</span><br></pre></td></tr></tbody></table></figure><h2 id="在-app-module-中使用插件">在 app module 中使用插件</h2><h3 id="在项目的-buildscript-添加插件作为-classpath">在项目的 buildscript 添加插件作为 classpath</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript {</span><br><span class="line">    repositories {</span><br><span class="line">        maven{</span><br><span class="line">            url 'file:///Users/your-user-name/Documents/Android/repo/'</span><br><span class="line">        }</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">    dependencies {</span><br><span class="line">        classpath 'com.android.tools.build:gradle:2.1.0-alpha3'        </span><br><span class="line">        classpath 'com.as-gradle.demo:gradleplugin:1.0.0'</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="在-app-module-中使用插件-1">在 app module 中使用插件：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.asgradle.apkdist'</span><br></pre></td></tr></tbody></table></figure><p>命令行运行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br><span class="line">hello, wow!</span><br><span class="line">your-distribution-directory</span><br></pre></td></tr></tbody></table></figure><h3 id="可能会遇到问题">可能会遇到问题</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:(46, 0) Cause: com/asgradle/plugin/ApkDistPlugin : Unsupported major.minor version 52.0</span><br><span class="line">&lt;a href="openFile:/Users/your-user-name/Documents/git/opensource/embrace-android-studio-demo/s5-GradlePlugin/app/build.gradle"&gt;Open File&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure><p>应该是本机的 JDK 版本是1.8，默认将 plugin module 的 groovy 源码编译成了1.8版本的 class 文件，放在 Android 项目中，无法兼容。需要对 plugin module 的 build.gradle 文件添加两个参数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceCompatibility = 1.6</span><br><span class="line">targetCompatibility = 1.6</span><br></pre></td></tr></tbody></table></figure><h1 id="真正的实现插件需求">真正的实现插件需求</h1><p>读者可能会观察到，到目前为止，插件只是跑通了流程，并没有实现本文提出的两个需求，</p><p>那接下来就具体实现一下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistPlugin implements Plugin&lt;Project&gt; {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line"></span><br><span class="line">        project.extensions.create('apkdistconf', ApkDistExtension);</span><br><span class="line"></span><br><span class="line">        project.afterEvaluate {</span><br><span class="line"></span><br><span class="line">//只可以在 android application 或者 android lib 项目中使用</span><br><span class="line">            if (!project.android) {</span><br><span class="line">                throw new IllegalStateException('Must apply \'com.android.application\' or \'com.android.library\' first!')</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">//配置不能为空</span><br><span class="line">            if (project.apkdistconf.nameMap == null || project.apkdistconf.destDir == null) {</span><br><span class="line">                project.logger.info('Apkdist conf should be set!')</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Closure nameMap = project['apkdistconf'].nameMap</span><br><span class="line">            String destDir = project['apkdistconf'].destDir</span><br><span class="line"></span><br><span class="line">//枚举每一个 build variant</span><br><span class="line">            project.android.applicationVariants.all { variant -&gt;</span><br><span class="line">                variant.outputs.each { output -&gt;</span><br><span class="line">                    File file = output.outputFile</span><br><span class="line">                    output.outputFile = new File(destDir, nameMap(file.getName()))</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>必须指出，本文插件实现的需求，其实可以直接在 app module 的 build.gradle 中写脚本就可以实现。这里做成插件，只是为了做示范。</p><p>上传到 bintray 的过程，就不再赘述了，可以参考<a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建</a>。</p><h1 id="后记">后记</h1><p>至此，这系列开篇的时候挖下的坑，终于填完了。很多人借助这系列的讲解，真正理解了 Android Studio 和它背后的 Gradle、Groovy，笔者十分高兴。笔者也得到了很多读者的鼓励和支持，心中十分感激。</p><p>写博客真的是一个很讲究执行力和耐力的事情，但既然挖下了坑，就得填上，对吧？</p><p>这半年来，个人在 Android 和 Java 平台上也做了更多的事情，也有了更多的体会。</p><p>AS 系列，打算扩充几个主题：</p><ul><li>Proguard 混淆</li><li>Java &amp; Android Testing</li><li>Maven 私有仓库深入</li><li>持续集成</li><li>……待发掘</li></ul><p>记得有人说，只懂 Android 不懂 Java，是很可怕的。在这半年以来，笔者在工作中使用 Java 实现了一些后端服务，也认真学习了 JVM 字节码相关的知识并把它使用到了工作中。在这个过程中，真的很为 Java 平台的活力、丰富的库资源、几乎无止境的可能性所折服。接下来，会写一些跟有关的学习体会，例如：</p><ul><li>Java 多线程与锁</li><li>JVM 部分原理</li><li>字节码操作</li><li>Java 8部分特性</li><li>……待学习</li></ul><p>随着笔者工作的进展，我也有机会学习使用了别的语言，例如 Node.js，并实现了一些后端服务。这个语言的活力很强，一些比 Java 现代的地方，很吸引人。有精力会写一写。</p><p>因为业务所需，笔者所经历的系统，正在处于像面向服务的演化过程中，我们期望建立统一的通讯平台和规范，抽象系统的资源，拆分业务，容器化。这是一个很有趣的过程，也是对我们的挑战。笔者也希望有机会与读者分享。</p><p>一不小心又挖下了好多明坑和无数暗坑，只是为了激励自己不断往前。在探索事物本质的旅途中，必然十分艰险，又十分有趣，沿途一定风光绚丽，让我们共勉。</p><h1 id="参考文献">参考文献</h1><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener">官方文档</a></p><h1 id="系列导读">系列导读</h1><p>本文是笔者《拥抱 Android Studio》系列第四篇，其他篇请点击：</p><p><a href="http://kvh.io/2015/12/01/embrace-android-studio-migration/">拥抱 Android Studio 之一：从 ADT 到 Android Studio</a></p><p><a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">拥抱 Android Studio 之二：Android Studio 与 Gradle 深入</a></p><p><a href="http://kvh.io/2016/01/04/embrace-android-studio-groovy-gradle/">拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础</a></p><p><a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建</a></p><p><a href="http://kvh.io/2016/03/28/embrace-android-studio-gradle-plugin/">拥抱 Android Studio 之五：Gradle 插件使用与开发</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。 想要及时收到最新博客文章，请关注：</p></blockquote><h1 id="番外">番外</h1><p>笔者 <a href="http://kvh.io">kvh</a> 在开发和运营 <a href="https://bugtags.com" target="_blank" rel="noopener">bugtags.com</a>，这是一款移动时代首选的 bug 管理系统，能够极大的提升 app 开发者的测试效率，欢迎使用、转发推荐。</p><p>笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。</p><p>我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭：</p><figure><img src="https://img.kvh.io/16-1-29/87155741.jpg" alt="bugtags"><figcaption aria-hidden="true">bugtags</figcaption></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;https://docs.gradle.org/current/userguide/custom_plugins.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;给
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Android" scheme="https://kvh.io/tags/Android/"/>
    
      <category term="EmbraceAndroidStudio" scheme="https://kvh.io/tags/EmbraceAndroidStudio/"/>
    
      <category term="拥抱 Android Studio" scheme="https://kvh.io/tags/%E6%8B%A5%E6%8A%B1-Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>如何更好的提出技术问题</title>
    <link href="https://kvh.io/a-good-question.html"/>
    <id>https://kvh.io/a-good-question.html</id>
    <published>2016-02-03T03:18:16.000Z</published>
    <updated>2021-01-13T01:42:18.817Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。 笔者从事 <a href="https://bugtags.com" target="_blank" rel="noopener">Bugtags.com</a> 开发运营以来，除了开发任务以外，最重要的工作就是在 qq 群里面回答用户的问题。</p><p>这半年来，少说也接待了上千个用户了。笔者发现，有相当一部分的用户，提问方式和技巧都有问题，这样导致了我们额外的客服量，也使得自己的问题得不到及时满意的回答。</p><p>下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。</p><h1 id="直接了当">直接了当</h1><p>有的用户，喜欢先问：『有人在吗？』</p><p>其实这个问句真的是很无意义，有问题直接提出来就好，有工作人员或者热心人看到了，能回答的自然就会回答，为什么还需要问有没有人在家呢？</p><h1 id="目的明确">目的明确</h1><p>有的用户，其实只是对某些技术点感兴趣，但是表现出来，是要给我们反馈 bug。这样我们就很摸不着头脑。</p><p>是吐槽、建议、反馈、赞扬还是学习？请一上来就说明。</p><h1 id="有价值">有价值</h1><p>列举一些个人认为没有价值的问题：</p><ul><li>PHP 是不是最好的语言？</li><li>VIM 还是 Emacs 好？</li><li>学 Android 有没有前途？</li></ul><p>这种问题，没有讨论的价值。</p><h1 id="已尝试求解">已尝试求解</h1><p>其实大部分我们遇到的技术问题，只要在谷歌或者百度上查找，大多能找到答案。</p><p>大部分情况下，使用 Bugtags 遇到的问题，都能通过我们的帮助文档解决。</p><p>但是我发现中国人真的很着急，文档也不看，帮助也不看，上来就问。</p><h1 id="问题着眼点小">问题着眼点小</h1><p>切忌提一些特别大的问题，例如『安卓如何管理内存』，这种是需要一些列文章才能阐述清楚的问题，显然是不适合在 QQ 群上提问的。</p><h1 id="背景信息充足">背景信息充足</h1><p>举个例子，Bugtags SDK 支持 Android 和 iOS，但是大部分用户提问的时候，会忽略了这个信息。同样，常用的操作系统，也有 OSX 和 Windows，很多人也会忽略。</p><p>这里面其实有个思维盲点，提出问题的人，会忽略一些显而易见的环境差异，认为别人了解背景信息，具有跟他一样的运行环境和操作步骤。</p><h1 id="问题描述信息充分">问题描述信息充分</h1><p>这个也需要换位思考，假设你是一个热心人，尝试帮助群上的人解答问题。是不是希望问题越准确越好？</p><p>一些要点请备齐：</p><ul><li>软硬环境及版本</li><li>操作步骤</li><li>期待结果</li><li>错误信息，最好是文本而不是截图</li><li>设备运行的 log</li><li>现场截图</li><li>已尝试过的解决方案</li><li>怀疑的点</li></ul><h1 id="重现问题的-demo">重现问题的 Demo</h1><ul><li>创建你自己的 demo 程序，操作要友好</li><li>加上使用说明，描述你所遇到的问题，具体环境，操作步骤，帮助别人快速重现你的问题</li><li>打包你的 demo，上传到 github 或者百度云盘，让别人可以很快下载到</li></ul><h1 id="一个范例">一个范例</h1><p><a href="http://stackoverflow.com/questions/34804039/android-testing-of-the-floating-view" target="_blank" rel="noopener">stack-overflow</a></p><h1 id="总结">总结</h1><p>提问技巧，也是属于沟通技巧之一。</p><p>笔者认为要达到有效的沟通，双方都需要有同理心，要换位思考。</p><p>愿这篇文章能为大家带来一些启发，能够收获更多满意的答案。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。 笔者从事 &lt;a href=&quot;https://bugtags.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bugtags.com&lt;/a&gt; 开发
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="程序员必读" scheme="https://kvh.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建</title>
    <link href="https://kvh.io/embrace-android-studio-maven-deploy.html"/>
    <id>https://kvh.io/embrace-android-studio-maven-deploy.html</id>
    <published>2016-01-20T03:20:30.000Z</published>
    <updated>2021-01-13T01:42:18.824Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="使用创造和分享">使用、创造和分享</h1><p>笔者曾经不思量力的思考过<code>『是什么推动了互联网技术的快速发展？』</code>这种伟大的命题。结论是，除了摩尔定律之外，<code>技术经验的快速积累和广泛分享</code>，也是重要的原因。</p><p>有人戏称，『写 Java，首先要学会选包』，在这里不好评论对错。不过这句话里面，至少包含两层意思：首先 Java 有大量的现成的依赖包，不必要自己造轮子；其次，Java 的包存放较为集中，集成方式也方便。</p><p>笔者从事 Android 和 Java 开发以来，经历了几个阶段：</p><p><code>闭门造轮子 &gt; 使用别人的轮子 &gt; 开门造轮子 &gt; 分享轮子</code></p><p>在使用、创造、分享轮子的过程中，maven 仓库的使用可谓必备技能。</p><p>相信各位使用 Android Studio，对于 <code>jcenter()</code>、<code>mavenCentral()</code> 等概念应该是司空见惯了。程序员要知其然，知其所以然。本篇将按照如下脉络介绍在 Android Studio 中 Maven 仓库相关的概念和应用。</p><ul><li>Maven 包</li><li>Maven 仓库</li><li>发布包到本地仓库</li><li>发布包到 Bintray Jcenter 远程仓库</li><li>发布包到 Sonatype MavenCentral 远程仓库</li><li>搭建私有 Sonatype 仓库</li><li>搭建私有 Artifacotory 仓库</li></ul><h1 id="maven-包package">Maven 包（Package）</h1><p>至于 Maven 是什么，请参考 <a href="https://zh.wikipedia.org/wiki/Apache_Maven" target="_blank" rel="noopener">Apache Maven</a>。</p><p>对于 Android 开发者而言，只需要知道 Maven 是一种构建工具，Maven 包是由所谓 POM（Project Object Model）所定义的文件包格式即可。</p><p>Gradle 可以使用 Maven 包，而且大部分的 Android 能够使用的远程依赖包都是 Maven 包。</p><p>先来看一个托管在某仓库上的 Maven 包：Bugtags-Android-Lib 所包含的内容：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bugtags-lib-1.1.0-javadoc.jar//javadoc 文件</span><br><span class="line">bugtags-lib-1.1.0-javadoc.jar.asc//javadoc 文件的签名</span><br><span class="line">bugtags-lib-1.1.0-sources.jar//源码文件</span><br><span class="line">bugtags-lib-1.1.0-sources.jar.asc//源码文件的签名</span><br><span class="line">bugtags-lib-1.1.0.aar//Android Library 的主文件包</span><br><span class="line">bugtags-lib-1.1.0.aar.asc//主文件包的签名</span><br><span class="line">bugtags-lib-1.1.0.pom//包描述文件</span><br><span class="line">bugtags-lib-1.1.0.pom.asc//描述文件的签名</span><br></pre></td></tr></tbody></table></figure><p>对于一个合符规范的 Maven Package，<code>pom 文件、aar（或者 jar） 文件</code>是必须的。</p><p>而 javadoc 文件、源码文件、签名文件都不是必要的，但是<code>某些公开仓库</code>（如 mavenCentral ）有此要求。</p><p>使用这个包的方式，相信大家已经很熟悉了：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies {</span><br><span class="line">    compile 'com.bugtags.library:bugtags-lib:1.1.0'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="pom-文件">POM 文件</h2><p>一个 Maven Package，最重要就是 POM（Project Object Model） 文件，这其实是一个 XML 文件，这里截取 Bugtags-Android-Lib POM 主要内容如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.bugtags.library&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;bugtags-lib&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;aar&lt;/packaging&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.android.support&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;support-v4&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;19.0.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>modelVersion: 从 mvn 2.x 起，这个数值都是4.0.0</p></li><li><p>packaging：打包方式，aar 是 Android Libirary 的打包方式，常用的还有 jar</p></li><li><p>dependency：声明依赖列表</p></li><li><p>包的唯一标示：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--包组 id，通常是发布者拥有的域名的反向，以免跟别人的重复--&gt;</span><br><span class="line">&lt;groupId&gt;com.bugtags.library&lt;/groupId&gt;</span><br><span class="line">&lt;!--包 artifactId，不好意思我也不知道如何准确翻译，其实就是组以下应该有一个更小的归类--&gt;</span><br><span class="line">&lt;artifactId&gt;bugtags-lib&lt;/artifactId&gt;</span><br><span class="line">&lt;!--包版本--&gt;</span><br><span class="line">&lt;version&gt;1.1.0&lt;/version&gt;</span><br></pre></td></tr></tbody></table></figure><p></p><p>其中三个字段与 Gradle 的依赖格式 <code>'com.bugtags.library:bugtags-lib:1.1.0'</code> 冒号分割的三段一一对应。这就解释了所谓的 <code>Gradle 兼容 Maven 包</code>。</p></li></ul><h1 id="maven-仓库">Maven 仓库</h1><p>Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下面是笔者日常开发用的库列表：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mavenCentral();</span><br><span class="line">jcenter()</span><br><span class="line">maven {</span><br><span class="line">     url 'file:///Users/my-user-name/Documents/Android/repo/'</span><br><span class="line">}</span><br><span class="line">maven {</span><br><span class="line">     url 'http://192.168.99.100:8081/content/repositories/releases/'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">maven { </span><br><span class="line">    url "https://jitpack.io" </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Android Studio Gradle 主要支持两个 Maven 中央库：<code>mavenCentral</code> 和 <code>jcenter</code>。</p><ul><li>mavenCentral 是最早的 maven 中央仓库</li><li>jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库</li><li>第三个是笔者的本机的仓库</li><li>第四个是笔者部署在内网服务器的私有仓库</li><li>第五个是可以把 github 项目发不成 maven 库（jitpack 本身是一个很酷的 idea）</li></ul><p>读者可能会发现两个问题：</p><ul><li>为什么有了 mavenCentral，谷歌还切换到了 jcenter？</li><li><code>maven { url : xxx}</code>，这种格式可以配置任何一个存在的仓库？</li></ul><p>解释如下：</p><h2 id="jcenter-vs.-mavencentral">jcenter VS. mavenCentral</h2><p>根据<a href="http://blog.bintray.com/2015/02/09/android-studio-migration-from-maven-central-to-jcenter/" target="_blank" rel="noopener">这篇博客</a>，jcenter 具有如下优胜特点，使得谷歌进行切换：</p><ul><li>jcenter 是一个 mavenCentral 的超集，jcenter 还包含了其他 maven 包</li><li>jcenter 具有更好的 cdn，默认支持 https，这个对于谷歌有巨大吸引力</li><li>bintray（jcenter 的服务提供商）表示 jcenter 具有更好的性能</li><li>有数据表明 bintray jcenter 占用更少的本地缓存空间</li><li>更好的交互界面，可以从 jcenter 向 mavenCentral 同步包（下面两个平台的使用教程将会证实这一点）</li></ul><blockquote><p>笔者亲测，在 bintray 上发布包到 jcenter 在易用性上的确比 在 sonatype 发布到到 mavenCentral 要好得多。</p></blockquote><h2 id="使用符合规范的-maven-仓库">使用符合规范的 maven 仓库</h2><p>没错，你可以通过 <code>maven { url : xxx }</code>使用任何一个符合 maven 规范的仓库。</p><ul><li><p>存在本地的</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maven {</span><br><span class="line">    url 'file:///Users/my-user-name/Documents/Android/repo/'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>存在内网服务器的</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maven {</span><br><span class="line">    url 'http://192.168.99.100:8081/content/repositories/releases/'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>存在某个远程服务器的</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maven {</span><br><span class="line">   url 'https://raw.githubusercontent.com/liaohuqiu/umeng-libs/master/repository'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>此仓库由 <a href="https://github.com/liaohuqiu" target="_blank" rel="noopener">liaohuqiu</a> 同学为方便大家使用友盟开发者工具，把相应的包做成了符合规范的 Maven 包，托管在 github 项目中。</p></blockquote></li></ul><h1 id="发布-maven-包">发布 Maven 包</h1><p>使用 maven 包相信已经很清楚了，让我们更进一步。</p><p>当我们在日常开发实践中，积累了一些公共库，想要固定下来，被自己或者别人方便的使用，就需要发布 maven 包。</p><p>一个符合规范的 maven 包至少包含 pom 文件和主文件包。难道这些都要手动编写和创建么？</p><p>答案是：有了 gradle 插件，你只需要干很少的事儿。</p><h2 id="全局设定">全局设定</h2><p>下面以发布这系列包为示例：</p><ul><li>groupId: com.as-gradle.demo //改成你的 groupId</li><li>artifcatId: x //artifactId 会有些变化，这里先用 <code>x</code> 代替，下面会修改。</li><li>version: 1.0.0</li></ul><p>也就是<code>'com.as-gradle.demo:x:1.0.0'</code></p><blockquote><p>读者要进行练习的时候，最好改一下你的 <code>groupId</code>，否则可能会发布失败</p></blockquote><p>下面使用到的示例工程已经放在了 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo" target="_blank" rel="noopener">github</a> 上。</p><p>为了后面使用方便，首先在工程的项目 <code>gradle.properties</code> 中定义一些属性，<strong>这些属性，主要是用生成 POM 文件，将会在通篇文章中用到</strong>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 包信息</span><br><span class="line">PROJ_GROUP=com.as-gradle.demo</span><br><span class="line">PROJ_VERSION=1.0.0</span><br><span class="line"></span><br><span class="line"># 项目的描述</span><br><span class="line">PROJ_WEBSITEURL=https://bugtags.com</span><br><span class="line">PROJ_ISSUETRACKERURL=https://github.com/bugtags/Bugtags-Android/issues</span><br><span class="line">PROJ_VCSURL=https://github.com/bugtags/Bugtags-Android.git</span><br><span class="line">PROJ_DESCRIPTION=Simple and effective bug &amp; crash reporting tool for Android apps</span><br><span class="line"></span><br><span class="line"># Licence信息</span><br><span class="line">PROJ_LICENCE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">PROJ_LICENCE_DEST=repo</span><br><span class="line"></span><br><span class="line"># Developer 信息</span><br><span class="line">DEVELOPER_ID=your-dev-id</span><br><span class="line">DEVELOPER_NAME=your-dev-name</span><br><span class="line">DEVELOPER_EMAIL=your-email@your-mailbox.com</span><br></pre></td></tr></tbody></table></figure><h2 id="发布包到本地仓库">发布包到本地仓库</h2><ul><li><p>创建一个 module：<code>localrepo</code></p></li><li><p>将本地某个路径设置为仓库根目录： <code>/Users/your-user-name/Documents/Android/repo/</code>（ Mac 下）</p><p>这里使用了一个叫做 <code>your-user-name</code> 的用户下的某个目录，请读者__自行替换__成自己的登录用户名。</p></li><li><p>为了优雅，在 localrepo 这个 module 的 <code>gradle.properties</code> 定义属性：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROJ_NAME=localrepo</span><br><span class="line">PROJ_ARTIFACTID=localrepo</span><br><span class="line">PROJ_POM_NAME=Local Repository</span><br><span class="line">LOCAL_REPO_URL=file:///Users/your-user-name/Documents/Android/repo/</span><br><span class="line">#以上是 Mac 的本地路径，如果是 Windows，则是类似：</span><br><span class="line">#LOCAL_REPO_URL=file:///C:/Users/cadmanager/Documents/repo/</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在 module 中应用和配置 maven plugin：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'maven'</span><br><span class="line"></span><br><span class="line">uploadArchives {</span><br><span class="line">   repositories.mavenDeployer {</span><br><span class="line">       repository(url: LOCAL_REPO_URL)</span><br><span class="line">       pom.groupId = PROJ_GROUP</span><br><span class="line">       pom.artifactId = PROJ_ARTIFACTID</span><br><span class="line">       pom.version = PROJ_VERSION    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在控制台运行：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p localrepo clean build uploadArchives --info</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>一切顺利的话，你的第一个本地包已经发布到设定的目录的本地仓库了：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|├── com</span><br><span class="line">│&nbsp;&nbsp; ├── as-gradle</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── demo</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;     └── localrepo</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         ├── 1.0.0</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         │&nbsp;&nbsp; ├── localrepo-1.0.0.aar</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         │&nbsp;&nbsp; ├── localrepo-1.0.0.aar.md5</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         │&nbsp;&nbsp; ├── localrepo-1.0.0.aar.sha1</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         │&nbsp;&nbsp; ├── localrepo-1.0.0.pom</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         │&nbsp;&nbsp; ├── localrepo-1.0.0.pom.md5</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         │&nbsp;&nbsp; └── localrepo-1.0.0.pom.sha1</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         ├── maven-metadata.xml</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         ├── maven-metadata.xml.md5</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         └── maven-metadata.xml.sha1</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><h3 id="使用本地包两个疑问向读者请教">使用本地包（两个疑问向读者请教）</h3><ul><li><p>要使用这个包，首先在项目的 build.gradle 中添加这个本地仓库：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects {</span><br><span class="line">   repositories {</span><br><span class="line">       jcenter()</span><br><span class="line"></span><br><span class="line">       maven{</span><br><span class="line">           url 'file:///Users/your-user-name/Documents/Android/repo/'</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在某个 module（如 demo 项目中的 app） 的 build.gradle 中添加依赖：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile 'com.as-gradle.demo:localrepo:1.0.0@aar'</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><blockquote><p>这里有两个奇怪的地方，笔者也没有深入研究，初步猜测是 Android Studio 的 Bug，知道答案的读者请到我博客文章下留言赐教：</p></blockquote><pre><code>* 依赖末尾一般都需要加一个`@aar`，在某些版本的 Android Studio，又不需要，这是为什么？* 另外，如果本地包本身使用了了远程的依赖，也需要在使用本地包的时候，一并加上，否则会报缺少包，这又是为什么？</code></pre><blockquote><p>想要让更多的人使用到你的劳动成果，你就需要把 Maven 包放在一个别人有权访问的远程仓库上，而不是本机，接下来要介绍发布 Maven 到 jcenter 仓库和 mavenCentral 仓库。因为前者的使用简单，本着『先易后难，快速出成效』的原则，我先介绍 jcenter 的上传。</p></blockquote><h1 id="发布包到-bintray-jcenter-远程仓库">发布包到 Bintray jcenter 远程仓库</h1><h2 id="简介">简介</h2><p>jcenter 是由 <a href="https://bintray.com/" target="_blank" rel="noopener">bintray</a> 提供的 maven 中央库托管服务，bintray 又是 <a href="https://www.jfrog.com/" target="_blank" rel="noopener">jfrog</a> 公司的一款产品。jfrog 是一个商业公司，通过提供高级服务盈利，又为普通开发者提供了足够用的免费基础功能（截止至2016-01-24），笔者较为推崇这种开发者服务的商业模式。</p><blockquote><p>引用一张图来表述 bintray 的工作方式</p></blockquote><figure><img src="https://img.kvh.io/16-1-27/11169370.jpg" alt="how-bintray-works"><figcaption aria-hidden="true">how-bintray-works</figcaption></figure><p>图片来源，http://inthecheesefactory.com/</p><p>使用 jcenter 需要在 bintray 上注册账号，在本地进行加密签名配置，下面开始介绍。</p><h2 id="注册账号">1. 注册账号</h2><ul><li>登陆 jcenter <a href="https://bintray.com/" target="_blank" rel="noopener">首页</a></li><li>sigin -&gt; signup，填写表单，注意 username 这一栏是后面的 bintray 私有库的后缀，要慎重选择。</li></ul><h2 id="创建-gpg-签名">2. 创建 GPG 签名</h2><blockquote><p>前方高能预警：比较繁琐，切勿半途放弃</p></blockquote><p>前面介绍过，可以把 bintray 的包同步到 mavenCentral，而后者需要对包文件进行<a href="http://blog.sonatype.com/2010/01/how-to-generate-pgp-signatures-with-maven/#.VqTRiFN94n0" target="_blank" rel="noopener">签名</a>，签名和验证过程需要用到一个叫做 <a href="https://www.gnupg.org/" target="_blank" rel="noopener">GPG</a> 的工具产生的公钥和私钥。<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">这里</a>有适合<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">多个平台</a>的 GPG 程序，下面只介绍 OSX 平台。</p><blockquote><p>这种工具大概的意义是产生公钥和私钥，把公钥发送到公开的服务器，私钥用来产生包文件签名。包的使用者在拿到包文件之后，通过公钥来验证文件的有效性，运行具体原理参考<a href="https://www.gnupg.org/gph/en/manual/x135.html" target="_blank" rel="noopener">这里</a>。</p></blockquote><ul><li><p>下载 <a href="http://gpgtools.org/" target="_blank" rel="noopener">gpgtool</a>，安装</p></li><li><p>检测安装成功，在命令行运行</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --version</span><br><span class="line">gpg (GnuPG/MacGPG2) 2.0.28</span><br><span class="line">libgcrypt 1.6.3</span><br></pre></td></tr></tbody></table></figure><p></p><p>有类似的输出，就是正常安装了</p></li><li><p>产生证书，运行命令，按照提示输入</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --gen-key</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>检查结果</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-keys</span><br></pre></td></tr></tbody></table></figure><p></p><p>找到刚才创建证书的时候，输入的相关信息那三行，例如：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub   2048R/2E686B39 2015-06-02</span><br><span class="line">uid       [ultimate] Your Name &lt;your-email@your-mailbox.com&gt;</span><br><span class="line">sub   2048R/your-sub-key-id 2015-06-02</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>上传公钥到服务器，找到你的 pub 的那一行，2048R/后的那一串八位字符串，如上面的：2E686B39，就是公钥 ID</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyserver hkp://pool.sks-keyservers.net --send-keys your-public-key-id</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>输出公钥和私钥成文件</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gpg -a --export your-email@your-mailbox.com &gt; public_key_sender.asc</span><br><span class="line">$ gpg -a --export-secret-key your-email@your-mailbox.com &gt; private_key_sender.asc</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>配置本地 gradle 运行环境的属性，位于<code>~/.gradle/gradle.properties</code>，添加内容：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signing.keyId=your-public-key-id</span><br><span class="line">signing.password=your-gpg-password</span><br><span class="line">signing.secretKeyRingFile=/Users/your-user-name/.gnupg/secring.gpg</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>bintray 本身可以通过在 <a href="https://bintray.com/profile/edit" target="_blank" rel="noopener">profile-&gt;GPG Sining</a>中配置 public key 和 private key 来自动对上传的文件进行签名，在下图中，对应填入 <code>public_key_sender.asc</code> 与 <code>private_key_sender.asc</code> 的内容即可。 <img src="https://img.kvh.io/16-1-24/31700878.jpg" alt="gpg-signing"></p></li><li><p>设置 bintray maven 包自动签名 选取 maven 仓库首页，进入 edit：</p><figure><img src="https://img.kvh.io/16-1-27/8566871.jpg" alt="auto-sign"><figcaption aria-hidden="true">auto-sign</figcaption></figure><p>最下面有两个选项：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPG sign uploaded files using Bintray's public/private key pair.</span><br><span class="line">GPG Sign uploaded files automatically</span><br></pre></td></tr></tbody></table></figure><p></p><p>因为咱们是希望使用自己的 key，所以勾选第二个。</p></li></ul><h2 id="创建-bintray-项目">3. 创建 bintray 项目</h2><p>首页-&gt; maven -&gt; add new package，填入对应的信息，其中 name 是在下面 bintray gradle 插件上传的时候，使用的项目名称，例如：bintryaar，这是要上传一个 Android Library，上传纯 Java 包的方式有<code>点点不一样</code>，下面有介绍。</p><figure><img src="https://img.kvh.io/16-1-25/80371247.jpg" alt="create-package"><figcaption aria-hidden="true">create-package</figcaption></figure><h2 id="配置插件">4. 配置插件</h2><p>bintray 官方在 github 上托管了 <a href="https://github.com/bintray/bintray-examples" target="_blank" rel="noopener">bintray-examples</a>，方便用户使用 gradle 上传包。</p><p>因为这里要上传的是 aar 格式的包，所以，具体是参考 <a href="https://github.com/bintray/bintray-examples/tree/master/gradle-aar-example" target="_blank" rel="noopener">gradle-aar-example</a> 例子，然而例子有一些地方没有更新，请注意下面的描述。</p><ul><li>在项目中创建 local.properties 来配置 bintray 登陆信息以及 gpg 证书密码</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bintray.user=your-bintray-user</span><br><span class="line">bintray.apikey=your-bintray-apikey</span><br><span class="line">bintray.gpg.password=your-gpg-password</span><br></pre></td></tr></tbody></table></figure><p>其中 your-bintray-user 就是 bintray 右上角显示的用户名称，your-bintray-apikey 在 profile-&gt;API Key 可以找到，your-gpg-password 则是创建 gpg 证书的时候的密码</p><ul><li>在项目的 build.gradle 配置 buildscript 的 classpath</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript {</span><br><span class="line">    repositories {</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">    dependencies {</span><br><span class="line">        classpath 'com.android.tools.build:gradle:1.3.0'</span><br><span class="line">        //下面两个包是用于上传的插件</span><br><span class="line">        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'</span><br><span class="line">        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'//注意此处</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>在 module 的 gradle.properties 文件中定义属性</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROJ_NAME=bintrayaar</span><br><span class="line">PROJ_ARTIFACTID=bintrayaar</span><br><span class="line">PROJ_POM_NAME=Bintray Aar Repository</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在 module 的 build.gradle 中使用插件</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.github.dcendents.android-maven'</span><br><span class="line">apply plugin: 'com.jfrog.bintray'</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>为了build.gradle 文件干净，笔者创建了一个名为 bintray.gradle 的文件配置插件信息，请参考<a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/blob/master/S4-MavenDeploy/bintrayaar/bintray.gradle" target="_blank" rel="noopener">这个文件</a>。 关键点：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">artifacts {</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>是为了同时生成 javadoc.jar 和 sources.jar 文件</p></li><li><p>build，上传</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p bintrayrepo/ clean build bintrayUpload --info</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果一切顺利，你会在控制台看到多个文件上传成功的标输出</p></li><li><p>踩坑实录</p><ul><li><p>HTTP/1.1 401 Unauthorized</p><p>apikey 或者 user 填写错误</p></li><li><p>HTTP/1.1 409 Conflict</p><p>包的该版本已经存在，需要在 bintray 管理界面上删除该版本后才可以再次上传</p></li><li><p>想让 sources.jar 或者 javadoc.jar 为空</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task sourcesJar(type: Jar) {</span><br><span class="line">classifier = 'sources'</span><br><span class="line">    from sourceSets.main.java.srcDirs</span><br><span class="line">    exclude '**'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul></li></ul><h2 id="上传-jar-包">5. 上传 Jar 包</h2><ul><li><p>在上传 jar 的时候，使用的插件有些区别</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'maven-publish'</span><br><span class="line">apply plugin: 'com.jfrog.bintray'</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在生成符合规定的 pom 文件的时候，要调用 groovy 的API，具体请参考<a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/blob/master/S4-MavenDeploy/bintrayjar/bintray.gradle" target="_blank" rel="noopener">这个文件</a></p></li></ul><h2 id="通过私有仓库的方式引用">6. 通过私有仓库的方式引用</h2><p>至此，刚才上传的两个库，已经可以通过如下方式引用了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects {</span><br><span class="line">    repositories {</span><br><span class="line">            maven {</span><br><span class="line">            url 'https://dl.bintray.com/freefaces/maven'//这个地址在包的页面的右方</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile 'com.as-gradle.demo:bintrayaar:1.0.0'</span><br><span class="line">compile 'com.as-gradle.demo:bintrayjar:1.0.0'</span><br></pre></td></tr></tbody></table></figure><p>但是你也发现了，包的用户需要添加一个额外的 maven 仓库。作为一个以用户价值为先的库的开发者，那当然不希望用户麻烦的。那就需要把这个私有的库，推送到 jcenter 上去。</p><h2 id="推送到-jcenter">7. 推送到 jcenter</h2><p>在 bintray 的 maven 库的界面，有 <code>add to jcenter</code></p><figure><img src="https://img.kvh.io/16-1-26/97161898.jpg" alt="add-to-jcenter"><figcaption aria-hidden="true">add-to-jcenter</figcaption></figure><p>点击之后，会进入一个消息页面，写或者不写都可以。提交，等待回复即可。</p><p>记住,包必须满足如下条件：</p><ul><li>包含 sources.jar 和 javadoc.jar 文件</li><li>必须是 maven 包</li></ul><blockquote><p>bintray 的消息系统有些 bug，假设你的包提交申请被驳回，你修改之后再提交申请，可能没有人回复你。请<strong>不要傻等</strong>。直接找页面右侧的 Feedback，这个他们是很快有人回答的。</p></blockquote><p>成功了之后，会出现如下的标记：</p><figure><img src="https://img.kvh.io/16-1-26/31312186.jpg" alt="inclusion-succeed"><figcaption aria-hidden="true">inclusion-succeed</figcaption></figure><p>你可以在 jcenter <a href="http://jcenter.bintray.com/" target="_blank" rel="noopener">服务器</a>上看到你的包了</p><h2 id="推送到-mavencentral">8. 推送到 mavenCentral</h2><p>在包管理页面，可以找到推送到 mavenCentral 功能， <img src="https://img.kvh.io/16-1-26/8597833.jpg" alt="sync-mavencentral"></p><p>一个包要从 bintray 推送到 jcenter，有几个前提：</p><ul><li>已经推送到了 jcenter[已完成]</li><li>每个文件都有对应的签名[已完成]</li><li>有 sonatye 账户[未完成]</li><li>maven 仓库经过审核[未完成]</li></ul><p>点击 Sync 之后，一段时间之后，右边的 Sync Status 会反馈出结果。</p><p>当然了，现在咱还干不了这个，因为还有两个条件没准备好。那咱们就进入 mavenCentral 的条件准备。</p><h1 id="发布包到-sonatype-mavencentral-远程仓库">发布包到 Sonatype MavenCentral 远程仓库</h1><h2 id="注册-sonatye-账户">1. 注册 sonatye 账户</h2><p>进入 <a href="https://issues.sonatype.org/secure/Dashboard.jspa" target="_blank" rel="noopener">sonatype issue</a> 页面，注册账号。</p><h2 id="创建-issue">2. 创建 issue</h2><p>登陆之后，顶部有按钮，<a href="https://issues.sonatype.org/secure/CreateIssue!default.jspa" target="_blank" rel="noopener">Created</a>，下面是关键的条目</p><ul><li>Project: <code>Community Support - Open Source Project Repository Hosting (OSSRH)</code></li><li>Issue Type: New Project</li><li>Group Id：就是你的包的 groupId</li></ul><p>其他的都认真填写。确认之后，大概两个工作日， Issue 会变成 resolved 状态，就可以发布你的包了。有了这两部，其实就可以从 bintray 上直接反向推到 mavenCentral ，而不需要走下面的步骤了，但是我还是简略介绍一下下面的步骤。如果很感兴趣详情，可以参考 <a href="http://www.trinea.cn/" target="_blank" rel="noopener">trinea</a> 的<a href="http://www.trinea.cn/dev-tools/upload-java-jar-or-android-aar-to-maven-center-repository/" target="_blank" rel="noopener">介绍</a>。</p><h2 id="上传包">3. 上传包</h2><p>也有方便的 gradle 插件帮助我们进行传送，可以参考 <a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">chrisbanes/gradle-mvn-push</a> 项目。配置好插件，上传。</p><h2 id="发布包">4. 发布包</h2><p>登陆 <a href="https://oss.sonatype.org/" target="_blank" rel="noopener">oss sonatype</a>，登陆，选择左边栏里的 <code>Staging Repositories</code>, 然后点Close 按钮，sonatype 会做响应的 validation，通过的话，就可以点 Release 发布啦，如果不通过，就检查问题，先 Drop，并重新做 Staging 发布。</p><h2 id="检查包">5. 检查包</h2><p>在 <a href="https://oss.sonatype.org/content/repositories/releases" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/releases</a> 可以看到你发布的包。</p><h2 id="为何如此简略">6. 为何如此简略</h2><p>因为这个过程真的很繁琐，ui 也不友好，在体验了 bintray 的便捷和友好，并发现 bintray 可以反向推送到 mavenCentral 之后，我就再也不想使用 sonatype 了。无奈，贪嗔痴是人类天性。</p><h1 id="搭建私服">搭建私服</h1><p>由于“你懂得”的原因，在国内访问 jcenter，总是偶尔不稳定，经常会出现诸如 <a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">peer not found</a> 这种错误。为了保证用户的稳定使用库，那就要考虑搭建放在自己服务器上的私有仓库。</p><p>Sonatype 和 bintray 都提供了可供自己部署的 maven 库管理软件。Sonatype 提供了免费的 <a href="https://hub.docker.com/r/sonatype/nexus/" target="_blank" rel="noopener">sonatype/nexus</a>，bintray 提供了免费的 <a href="https://www.jfrog.com/open-source/" target="_blank" rel="noopener">artifactory-oss</a>。</p><p>为了部署简便，笔者使用了 <a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a> 进行这两个私服搭建。对于 docker 是什么，怎么用，并不是系列文章的重点。有兴趣可以自行学习。入门文档<a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="noopener">在此</a>。</p><h1 id="搭建私有-sonatype-仓库">搭建私有 Sonatype 仓库</h1><ul><li><p>下载安装 docker 镜像</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull sonatype/nexus</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>运行镜像</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8081:8081 --name nexus sonatype/nexus:oss</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>访问服务器</p><p>因为的 docker-machine ip 是：<code>192.168.99.100</code>，于是可以通过在浏览器访问<code>http://192.168.99.100:8081/</code> 这个 URL 来访问 sonatype 私服。</p><p>你会发现这个界面跟你在<code>https://oss.sonatype.org/</code>看到的几乎一样。</p><p>默认账户密码是：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">admin123</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>设置仓库</p><p>点击左侧 repository，会出现 repository 的列表，把其中的 <code>Releases</code> 的 <code>Configutation-&gt;Access Setting-&gt; Deploy Polocy</code> 设置成 <code>Allow Redeploy</code> 使得可以重复发布包。</p></li><li><p>配置和使用插件</p><p>我还是使用了 <a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">chrisbanes/gradle-mvn-push</a> 插件，稍微改动了一下字段的值，主要改动是环境配置，如账号密码，repository URL 等，具体请参考这里 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/blob/master/S4-MavenDeploy/sonatyaar/gradle-mvn-push.gradle" target="_blank" rel="noopener">mvn-push</a>。</p></li><li><p>关键设置</p><p>要在<code>gradle.properties</code> 中设置：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROJ_NAME=sonatyaar</span><br><span class="line">PROJ_ARTIFACTID=sonatyaar</span><br><span class="line">PROJ_POM_NAME=Sonatye Aar Repository</span><br><span class="line">POM_PACKAGING=aar</span><br><span class="line">RELEASE_REPOSITORY_URL=http://192.168.99.100:8081/content/repositories/releases</span><br><span class="line">SNAPSHOT_REPOSITORY_URL=http://192.168.99.100:8081/content/repositories/snapshots</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>查看</p><p>上传成功之后，就可以在浏览器的<code>http://192.168.99.100:8081/content/repositories/releases</code>看到这个包。并可引用了。</p></li><li><p>错误</p><p>上传的时候，返回400，可能是<code>Configutation-&gt;Access Setting-&gt; Deploy Polocy</code>没设置好；返回401，可能是账号密码错误。</p></li></ul><h1 id="搭建私有-artifactory-仓库">搭建私有 Artifactory 仓库</h1><p>bintray 其实提供了多个私有部署仓库的版本，分别是：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Artifactory OSS</span><br><span class="line">Artifactory Pro</span><br><span class="line">Artifactory Pro Registry</span><br></pre></td></tr></tbody></table></figure><p>按名字来看，后两者可能是收费的，这里就只介绍 <code>Artifactory OSS</code>，依然是使用 docker 进行部署运行。更详细的使用手册，参考 <a href="https://www.jfrog.com/confluence/display/RTF/Running+with+Docker" target="_blank" rel="noopener">Running with Docker</a>。</p><ul><li><p>下载镜像（截止至2016-01-27，最新版本是4.4.1）</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull jfrog-docker-reg2.bintray.io/jfrog/artifactory-oss:4.4.1</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>运行镜像</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8080:8081 jfrog-docker-reg2.bintray.io/jfrog/artifactory-oss:4.4.1</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在浏览器中访问<code>http://192.168.99.100:8080/</code>，默认账号密码是：</p><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">password</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><p>笔者写到这，发现这个篇幅已经太长了。现在的读者，其实也没有太多耐心看长篇大论，所以考虑将更详细的私服的部署，放在一篇独立的博客中讲解。</p><h1 id="kevinhogradle-maven-complete">kevinho/gradle-maven-complete</h1><p>为了方便读者使用 gradle 将 aar、jar包推送到 jcenter 和 mavenCentral，笔者决定将本文所使用的 sample 项目，分离出一个独立的 github 项目：<a href="https://github.com/kevinho/gradle-maven-complete" target="_blank" rel="noopener">kevinho/gradle-maven-complete</a>，里面包含如下范例：</p><ul><li>localrepo：本地仓库推送</li><li>bintrayaar：bintray 的 aar 包推送</li><li>bintrayjar：bintray 的 jar 包推送</li><li>sonatypearr：mavenCentral 的 aar 包推送</li></ul><p>基本上覆盖到了主流的场景了，希望我这个小轮子，也能帮助大家，喜欢记得 star 哦！</p><h1 id="总结">总结</h1><p>这一篇，笔者结合实例讲解了 maven 仓库相关的知识，以及将 maven 包通过 gradle 插件上传本地仓库、bintray jcenter、sonatype mavenCentral，还简要介绍了 sonatype 和 artifactory 私服的 docker 搭建。或许你已经蠢蠢欲动了，那就赶紧打开你的电脑，把你的轮子，用 maven 武装起来吧！下一篇会介绍 gradle 插件的编写以及发布使用，敬请期待！</p><h1 id="参考文献">参考文献</h1><ul><li><a href="http://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en" target="_blank" rel="noopener">inthecheesefactory.com</a></li><li><a href="http://www.trinea.cn/android/maven/" target="_blank" rel="noopener">trinea.cn</a></li><li><a href="https://en.wikipedia.org/wiki/Apache_Maven" target="_blank" rel="noopener">wikipedia</a></li><li><a href="https://maven.apache.org/what-is-maven.html" target="_blank" rel="noopener">apache-maven</a></li><li><a href="http://central.sonatype.org/pages/gradle.html" target="_blank" rel="noopener">sonatype-central</a></li><li><a href="https://bintray.com/docs/usermanual/" target="_blank" rel="noopener">bintray-manual</a></li></ul><h1 id="系列导读">系列导读</h1><p>本文是笔者《拥抱 Android Studio》系列第四篇，其他篇请点击：</p><p><a href="http://kvh.io/2015/12/01/embrace-android-studio-migration/">拥抱 Android Studio 之一：从 ADT 到 Android Studio</a></p><p><a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">拥抱 Android Studio 之二：Android Studio 与 Gradle 深入</a></p><p><a href="http://kvh.io/2016/01/04/embrace-android-studio-groovy-gradle/">拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础</a></p><p><a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建</a></p><p><a href="http://kvh.io/2016/03/28/embrace-android-studio-gradle-plugin/">拥抱 Android Studio 之五：Gradle 插件使用与开发</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote><h1 id="番外">番外</h1><p>笔者 <a href="http://kvh.io">kvh</a> 在开发和运营 <a href="https://bugtags.com" target="_blank" rel="noopener">bugtags.com</a>，这是一款移动时代首选的 bug 管理系统，能够极大的提升 app 开发者的测试效率，欢迎使用、转发推荐。</p><p>笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。</p><p>我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭：</p><figure><img src="https://img.kvh.io/16-1-29/87155741.jpg" alt="bugtags"><figcaption aria-hidden="true">bugtags</figcaption></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;使用创造和分享&quot;&gt;使用、创造和分享&lt;/h1&gt;
&lt;p&gt;笔者曾经不思量力的思考过&lt;code&gt;『是什么推动了互联网技术的快速发展？』&lt;/code&gt;这种伟大的命题。结论是，除了摩尔定律之外，&lt;code&gt;技术经验的快速积累和
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Android" scheme="https://kvh.io/tags/Android/"/>
    
      <category term="EmbraceAndroidStudio" scheme="https://kvh.io/tags/EmbraceAndroidStudio/"/>
    
      <category term="拥抱 Android Studio" scheme="https://kvh.io/tags/%E6%8B%A5%E6%8A%B1-Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础</title>
    <link href="https://kvh.io/embrace-android-studio-groovy-gradle.html"/>
    <id>https://kvh.io/embrace-android-studio-groovy-gradle.html</id>
    <published>2016-01-04T03:20:30.000Z</published>
    <updated>2021-01-13T01:42:18.823Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="关于学习方式续">关于学习方式续</h1><p>回忆起大学那个白衣飘飘的年代，开始金工实习却发现基础学的不牢靠，越来越胆小，越来越糊涂。所幸得到一位高年级学姐指导，赶紧找当时的书或者笔记，快速把基础知识温习一遍，再结合实践中思考，终于豁然开朗。</p><p>相信看过前一篇 <a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">《Android Studio 与 Gradle 深入》</a>的同学，有一部分就会遇到我初识 Gradle 时的困惑：代码我也依稀看得懂，但就是不知道还能这样写，为什么这样写。</p><h1 id="问题与解决方案">问题与解决方案</h1><p>回想我在 Gradle 的学习过程中遇到的问题与及其解决方案，总结出下面三点：</p><ul><li>原理不懂：学习 Groovy 与 Gradle 的基础原理</li><li>Gradle 实践不懂：学会找示例，学习开源例子</li><li>方法和属性不懂：学会查文档</li></ul><p>下面的我将以解决三个问题为线索，介绍 Groovy 和 Gradle。</p><h1 id="学习-groovy">学习 Groovy</h1><h2 id="groovy-概述">Groovy 概述</h2><p>Gradle 采用了 Groovy 语言作为主要的脚本语言。一个 build.gradle 文件，其实是一个 Groovy 类。</p><p>Groovy 是一个基于 JVM 的语言，代码最终编译成字节码（bytecode）在 JVM 上运行。它具有类似于 Java 的语法风格，但是语法又比 Java 要灵活和方便，同时具有动态语言（如 ruby 和 Python）的一些特性。</p><p>Groovy 的诸多特定，很适合用来定义 <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a>（Domain Specific Language）。</p><blockquote><p>简单的来讲 DSL 是一个面向特定小领域的语言，如常见的 HTML、CSS 都是 DSL，它通常是以配置的方式进行编程，与之相对的是通用语言（General Purpose Language），如 Java 等。</p></blockquote><p>既然是一门语言，就肯定有自己的特性。我们要从下面几个步骤来介绍 Groovy： * 环境安装 * 语言基础 * 语言特性及其本质</p><h2 id="环境安装">环境安装</h2><p>Groovy 官方<a href="http://www.groovy-lang.org/install.html" target="_blank" rel="noopener">安装文档</a>提供多种方式进行安装，确保你不会在<strong>跪在环境配置的路上 <sup>-</sup> </strong>：</p><ul><li>Windows 下推荐 binary 包配置环境变量</li><li>Mac 下推荐使用 sdkman 或者 Brew 进行安装</li><li>Linux 下推荐 sdkman</li><li>嵌入在程序中，则推荐使用 Maven 远程依赖</li></ul><p>初学者也没有必要使用IDE，平添障碍，后期用 Intellij IDEA Community 版本足矣。</p><p>下面只介绍 Mac 下使用 sdkman 的安装方式。</p><ul><li>下载安装 sdkman，执行下面命令，按照提示安装即可</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s http://get.sdkman.io | bash</span><br></pre></td></tr></tbody></table></figure><ul><li>使环境变量生效</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source "$HOME/.sdkman/bin/sdkman-init.sh"</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 Groovy</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdk install groovy</span><br></pre></td></tr></tbody></table></figure><ul><li>查看当前版本，如果能否运行且输出对应版本，就是成功了</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groovy -version</span><br><span class="line">Groovy Version: 2.4.4 JVM: 1.8.0_25 Vendor: Oracle Corporation OS: Mac OS X</span><br></pre></td></tr></tbody></table></figure><h2 id="初探">初探</h2><p>安装好环境之后，先来一个 hello, world！</p><ul><li>新建文件</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.groovy</span><br></pre></td></tr></tbody></table></figure><ul><li>在其中写上内容</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println "hello, world!"</span><br></pre></td></tr></tbody></table></figure><ul><li>保存退出，执行</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groovy test.groovy</span><br><span class="line">hello, world!</span><br></pre></td></tr></tbody></table></figure><p>Wow, So easy!</p><h2 id="语言基础">语言基础</h2><p>下面将会用一些实际的例子，介绍一些最重要的点， &gt; 例子都已经传到 github 的 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/tree/master/s3-GroovyGradle" target="_blank" rel="noopener">demo</a> 项目中。 &gt; 第一次使用 demo 项目的时候，需要等待自动下载几个远程包。 &gt; 笔者一个 Java 程序员，可以你能够看到很多 Java 的习性还是留在代码中。</p><h3 id="文件与类变量与函数">文件与类，变量与函数</h3><p>Groovy 代码文件，支持不显式声明类： &gt; ScriptClass.groovy</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println 'hello,world'</span><br></pre></td></tr></tbody></table></figure><p>这样一个 Groovy 脚本，经过编译之后，会产生一个继承自 groovy.lang.Script 类的子类：</p><p>是不是能看出点什么？</p><blockquote><p>groovy/build/classes/main/io/kvh/as/groovy/ScriptClass.class</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ScriptClass extends Script {</span><br><span class="line">    public ScriptClass() {</span><br><span class="line">        CallSite[] var1 = $getCallSiteArray();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ScriptClass(Binding context) {</span><br><span class="line">        CallSite[] var2 = $getCallSiteArray();</span><br><span class="line">        super(context);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) {</span><br><span class="line">        CallSite[] var1 = $getCallSiteArray();</span><br><span class="line">        var1[0].call(InvokerHelper.class, ScriptClass.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object run() {//关键方法</span><br><span class="line">        CallSite[] var1 = $getCallSiteArray();</span><br><span class="line">        return var1[1].callCurrent(this, "hello,world");// got it?</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Groovy 支持如下的方式来定义变量和函数： &gt; VarAndMethod.groovy</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def varAndMethod() {</span><br><span class="line">    def a = 1//不显式声明变量类型</span><br><span class="line">    a = "abc"//运行时改变类型</span><br><span class="line"></span><br><span class="line">    println a//无需；结束一行代码</span><br><span class="line">    a = 4//最后一行作为返回值</span><br><span class="line">}</span><br><span class="line">def ret = varAndMethod()//文件内运行方法</span><br><span class="line"></span><br><span class="line">println ret//输出4</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串">字符串</h3><p>Groovy 支持单引号，双引号，三单引号声明一个字符串；</p><blockquote><p>Quoted.groovy</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def quoted() {</span><br><span class="line">        def singleQ = 'hello, single quot'// 声明为java.lang.String</span><br><span class="line">        def doubleQ = "hello, double quot ${singleQ}"// 如果有${},则为groovy.lang.GString，支持变量替换;否则为java.lang.String</span><br><span class="line">        def tripleQ = '''hello,</span><br><span class="line">triple quot'''// 允许多行，而不需要+号</span><br><span class="line"></span><br><span class="line">        println singleQ</span><br><span class="line">        println doubleQ</span><br><span class="line">        println tripleQ</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Groovy 还支持以：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"""..."""</span><br><span class="line">/.../</span><br><span class="line">$/.../$</span><br></pre></td></tr></tbody></table></figure><p>来声明字符串，详情参见参考文档。</p><h3 id="listarray-和-map">List，Array 和 Map</h3><p>Groovy 默认使用 java.util.ArrayList 来提供 List 服务，但提供了更加灵活易用的操作方式： &gt; Collections.groovy</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def playList() {</span><br><span class="line">    def lst = ["a",2,true]//支持不同类型元素</span><br><span class="line"></span><br><span class="line">    println(lst)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">playList()</span><br></pre></td></tr></tbody></table></figure><p>要使用 Array，需要显式声明：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def playArray() {</span><br><span class="line">    def intArr = [1, 2, 3] as int[]//显示声明</span><br><span class="line">    String[] strArr = ["a", "b"]//另外一种方式</span><br><span class="line"></span><br><span class="line">    println(intArr)</span><br><span class="line">    println(strArr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">playArray()</span><br></pre></td></tr></tbody></table></figure><p>使用 key:value 的方式定义 Map，注意 key 的正确使用方式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def playMap() {</span><br><span class="line">    def map = [a: "a", b: "b"]</span><br><span class="line">    </span><br><span class="line">    println(map)</span><br><span class="line">    </span><br><span class="line">    def key = "name"</span><br><span class="line">    def map2 = [key: 'a']//未使用</span><br><span class="line">    def map3 = [(key): 'a']//使用</span><br><span class="line"></span><br><span class="line">    println(map2)</span><br><span class="line">    println(map3)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">playMap()</span><br></pre></td></tr></tbody></table></figure><h3 id="import">import</h3><p>Groovy 提供了更强大的 import</p><ul><li>默认 import，这些类都是被默认 import 到代码中的，可以直接使用</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.*</span><br><span class="line">import java.util.*</span><br><span class="line">import java.io.*</span><br><span class="line">import java.net.*</span><br><span class="line">import groovy.lang.*</span><br><span class="line">import groovy.util.*</span><br><span class="line">import java.math.BigInteger</span><br><span class="line">import java.math.BigDecimal</span><br></pre></td></tr></tbody></table></figure><ul><li>import alias</li></ul><p>引入一个类，通过 as 关键字赋予一个别名，有点 JavaScript 的意思么？</p><blockquote><p>Import.groovy</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.String as KString</span><br><span class="line"></span><br><span class="line">println(new KString("aaa"))</span><br></pre></td></tr></tbody></table></figure><h2 id="语言特性及其本质">语言特性及其本质</h2><h3 id="closure闭包">Closure（闭包）</h3><p>闭包的概念不再赘述，大概就是可以将函数作为参数传递和使用，详情参见 [wikipedia](https://zh.wikipedia.org/zh/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ [closureParameters -&gt; ] statements }</span><br></pre></td></tr></tbody></table></figure><p>可以省略方括号内的内容，也就是说，可以没有参数列表。</p><blockquote><p>Closure.groovy</p></blockquote><p>当闭包不声明参数列表，默认参数是 it；闭包被定义之后，是一个 Closure 对象，可以对其调用 call 方法使其执行。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def defaultIt() {</span><br><span class="line">    3.times {</span><br><span class="line">        println it //默认参数 it</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">defaultIt()</span><br><span class="line">def closureObj() {</span><br><span class="line">    def obj = { a -&gt;</span><br><span class="line">        ++a</span><br><span class="line">    }</span><br><span class="line">    println obj.call(1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">closureObj()</span><br></pre></td></tr></tbody></table></figure><h3 id="面向对象特性">面向对象特性</h3><ul><li>定义和实例化一个类</li></ul><blockquote><p>GroovyCLass.groovy</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class People{</span><br><span class="line">    String name</span><br><span class="line">    int age</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">People p1 = new People();</span><br><span class="line">People p2 = new People(name:"Luis",age: 29)//通过类似 map 的方式赋值参数</span><br></pre></td></tr></tbody></table></figure><ul><li>方法的默认参数</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo(String p1, int p2 = 1) {</span><br><span class="line">    println(p1)</span><br><span class="line">    println(p2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo("hello")</span><br></pre></td></tr></tbody></table></figure><ul><li>Field 和 Property</li></ul><p>Field 是以各种修饰符修饰的变量。Property是私有变量和自带的 gettters/setters，</p><p>下面的类具有私有变量 name、age，并自带这两个变量的 getter 和 setter：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class People{</span><br><span class="line">    String name</span><br><span class="line">    int age</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当变量声明为 final 的时候，默认就没有 setter</p><ul><li>Trait</li></ul><p>Groovy 提供了一个叫做 Trait 特性实现了多继承，还有很多强大的功能，读者可以自己探索。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">trait Fly {</span><br><span class="line">    void fly() {</span><br><span class="line">        println("fly")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">trait Walk {</span><br><span class="line">    void walk() {</span><br><span class="line">        println("walk")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Duck implements Fly, Walk {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Duck duck = new Duck()</span><br><span class="line">duck.fly()</span><br><span class="line">duck.walk()</span><br></pre></td></tr></tbody></table></figure><h2 id="groovy-基础小结">Groovy 基础小结</h2><p>至此，我们已经熟悉了 Groovy 的基本语法和特性，相信你也能够使用 Groovy 写一些基础程序了。Groovy 还有很多深入的内容，请用到的时候，参考这本这个 pdf： <a href="https://pragprog.com/book/vslg2/programming-groovy-2" target="_blank" rel="noopener">《Programming Groovy 2》</a>。</p><p>下面开始介绍使用 Groovy 写 Gradle 程序，主要的内容来自 <a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">《Gradle Sser Guide》</a>。</p><h1 id="学习-gradle">学习 Gradle</h1><h2 id="gradle-安装">Gradle 安装</h2><p>三种方式安装 Gradle：</p><ul><li><p><a href="https://gradle.org/gradle-download/" target="_blank" rel="noopener">下载 zip</a> 安装包</p></li><li><p>Mac 下使用 home brew</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gradle</span><br></pre></td></tr></tbody></table></figure><ul><li><strong><em>推荐</em></strong>：使用 IntelliJ IDEA（Android Studio）自带的 wrapper 结构来下载 Gradle</li></ul><blockquote><p>Wrapper 是为了让不同版本的插件能够使用其对应版本的 Gradle 的一个机制</p></blockquote><blockquote><p>Gradle Wrapper 会把不同的版本 Gradle 安装在：</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$USER_HOME/.gradle/wrapper/dists</span><br></pre></td></tr></tbody></table></figure><h2 id="gradle-build-的生命周期">Gradle Build 的生命周期</h2><p>回忆一下<a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">《Android Studio 与 Gradle 深入》</a>中的 Android Studio 项目文件结构：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app//app module</span><br><span class="line">│&nbsp;&nbsp; ├── build.gradle//app module 的 build.gradle</span><br><span class="line">├── build.gradle//项目 build.gradle，通常配置项目全局配置，如 repositories 和 dependencies</span><br><span class="line">├── gradle.properties//项目属性文件，通常可以放置一些常量</span><br><span class="line">├── lib//lib module</span><br><span class="line">│&nbsp;&nbsp; ├── build.gradle//lib module 的 build.gradle</span><br><span class="line">└── settings.gradle//项目总体设置，通常是配置项目中所有的 module</span><br></pre></td></tr></tbody></table></figure><h3 id="gradle-构建三个阶段">Gradle 构建三个阶段：</h3><ul><li><p>初始化：Gradle 支持单 module 构建和多 module 构建（Android Studio 创建的项目默认是多 module）。初始化阶段，Gradle 会为每一个 module 中的 build.gradle 文件创建一个 Project 实例。</p></li><li><p>配置：项目根目录的 build.gradle 会首先被执行</p></li><li><p>执行：执行所选取的 task</p></li></ul><h3 id="settings.gradle">Settings.gradle</h3><p>多 module 构建要求在项目根目录下有一个 settings.gradle，用来指定哪些 module 参与构建，如：</p><blockquote><p>settings.gradle</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include ':app', ':groovy'</span><br><span class="line"></span><br><span class="line">println 'print in settings.gradle'</span><br></pre></td></tr></tbody></table></figure><p>在 settings.gradle 文件中，添加一行打印语句，在控制台中，切换到当前项目根目录下执行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew -p groovy build</span><br></pre></td></tr></tbody></table></figure><p>可以在看出 settings.gradle 的代码每次都会率先执行。</p><h3 id="task">Task</h3><p>接下来，我们开始学习 Gradle 的核心 Task。</p><blockquote><p>groovy/build.gradle</p></blockquote><p>定义一个 Task：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello {</span><br><span class="line">    doLast {</span><br><span class="line">        println 'Hello,'</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行命令，查看输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew hello</span><br><span class="line">Hello,</span><br></pre></td></tr></tbody></table></figure><p>Task 也可以这样定义：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task World &lt;&lt; {</span><br><span class="line">    println 'World!'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，如果定义成这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hi {</span><br><span class="line">    println 'description hi'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在进行初始化和配置的时候，下面语句就会运行。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println 'hi'</span><br></pre></td></tr></tbody></table></figure><p>这种语法通常是用来定义 task 的描述信息。</p><p>Task 可设置 dependsOn 和 finalizedBy：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task hello {</span><br><span class="line">    doLast {</span><br><span class="line">        println 'Hello,'</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">task intro(dependsOn: hello) &lt;&lt; {</span><br><span class="line">    println 'intro'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">World.finalizedBy hello</span><br></pre></td></tr></tbody></table></figure><p>执行 intro 之前，会先执行 hello；执行 World 之后，会自动执行 hello。</p><h3 id="plugin">Plugin</h3><p>Gradle 的核心代码，只提供了一个框架，具体的功能（如构建 Android 工程）是通过插件机制来实现的。</p><p>Gradle 提供了大量官方的插件，如 Maven、Groovy、Java、Publishing、Signing等，也有大量第三方的插件（Android），甚至每个人都可以自己实现一个插件(如 笔者开发的 Bugtags 插件，这个将在最后一篇讲述)。</p><p>这些 plugin 定义了一系列的 task、DSL 和约定，在build.gradle 文件使用这些 plugin：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: java</span><br></pre></td></tr></tbody></table></figure><p>当你写了一个独立的 file_uri.gradle 文件，你可以通过：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: 'file_uri.gradle'</span><br></pre></td></tr></tbody></table></figure><p>来引入你的 gradle 文件，这个文件甚至可以在某个服务器上。</p><h1 id="gradle-实践参考">Gradle 实践参考</h1><p>学习了基础理论之后，如果你还是不知道如何开始写，那就先来实现一个自定义 apk 名称的功能吧！</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android.applicationVariants.all { variant -&gt;//获取 variant 参数，就是 productFlavor x buildType</span><br><span class="line">    variant.outputs.each { output -&gt;//获取输出文件</span><br><span class="line">        def file = output.outputFile//修改实例</span><br><span class="line">        output.outputFile = new File(</span><br><span class="line">                (String) file.parent,</span><br><span class="line">                (String) file.name.replace(</span><br><span class="line">                        file.name,</span><br><span class="line">                        // alter this string to change output file name</span><br><span class="line">                        "Your_Apk_Name_" + variant.name + "_" + variant.versionName + ".apk"</span><br><span class="line">                )</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你问我怎么知道 android 下有个 applicationVariants？其实我也不知道的，也得找文档。</p><p>因为使用的是 Android 的插件，那就得在谷歌搜 “android gradle plugin dsl”，果然有个 <a href="http://google.github.io/android-gradle-dsl/current/" target="_blank" rel="noopener">Android Plugin DSL Reference</a>。</p><p>点进去找找，里面有关于 build variant 的文档： <a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.AppExtension.html#com.android.build.gradle.AppExtension:applicationVariants" target="_blank" rel="noopener">applicationVariants</a>，既然是一个 Set，那就可以调用 all 方法。</p><p>写代码调试，再配合文档，你就晓得该怎么写了。</p><p>如果你还是不知道如何入手，那我提供几个开源参考：</p><ul><li><a href="https://github.com/bintray/gradle-bintray-plugin" target="_blank" rel="noopener">gradle-bintray-plugin</a>：bintray 提供的开源插件</li><li><a href="https://github.com/srs/gradle-node-plugin" target="_blank" rel="noopener">gradle-node-plugin</a>： 一个运行 NodeJS 脚本的插件</li><li><a href="https://github.com/linkedin/gradle-plugins" target="_blank" rel="noopener">linkedin-gradle-plugins</a>： linkedin的 Gradle 插件集合</li></ul><h1 id="参考文档">参考文档</h1><p>相信参照开源项目动手写了几个小程序之后，你已经小有感觉了，那就记得把文档地址备齐了，用到的时候，查一下：</p><ul><li><a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">Groovy Documentation</a>：Groovy 的详细介绍文档</li><li><a href="http://www.groovy-lang.org/api.html" target="_blank" rel="noopener">Groovy API Reference</a>：Groovy 的 API 文档，必要的时候查阅</li><li><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">Gradle User Guid</a>：Gradle 的详细介绍文档，很有必要过一遍</li><li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="noopener">Gradle Build Language Reference</a>：Gradle DSL 参考，重点的几个 DSL 过一下，其他的用到再查</li><li><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">Android Plugin DSL Reference</a>：使用 Android 插件必备</li></ul><p>另外，也有大量很好的中文文档，比如这几篇：</p><ul><li><a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">邓凡平老师的 Gradle 介绍</a></li><li><a href="https://www.gitbook.com/book/dongchuan/gradle-user-guide-/details" target="_blank" rel="noopener">Gradle User Guide 中文版</a></li></ul><h1 id="总结">总结</h1><p>笔者从 Gradle 入门到现在略懂，经历了大量懵懂的时光。最后狠下心去系统学习了 Groovy 和 Gradle 的基础之后，最终茅塞顿开。希望读者遇到类似的情况，一定要沉下心，多学多练。</p><p>在接下来的两篇，我将分别介绍将发布远程库和编写 Gradle 插件。</p><h1 id="系列导读">系列导读</h1><p>本文是笔者《拥抱 Android Studio》系列第三篇，其他篇请点击：</p><p><a href="http://kvh.io/2015/12/01/embrace-android-studio-migration/">拥抱 Android Studio 之一：从 ADT 到 Android Studio</a></p><p><a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">拥抱 Android Studio 之二：Android Studio 与 Gradle 深入</a></p><p><a href="http://kvh.io/2016/01/04/embrace-android-studio-groovy-gradle/">拥抱 Android Studio 之三：溯源，Groovy 与 Gradle 基础</a></p><p><a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱 Android Studio 之四：Maven 公共仓库使用与私有仓库搭建</a></p><p><a href="http://kvh.io/2016/03/28/embrace-android-studio-gradle-plugin/">拥抱 Android Studio 之五：Gradle 插件使用与开发</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote><h1 id="番外">番外</h1><p>笔者 <a href="http://kvh.io">kvh</a> 在开发和运营 <a href="https://bugtags.com" target="_blank" rel="noopener">bugtags.com</a>，这是一款能够极大的提升 app 开发者测试效率的 SDK 产品，欢迎使用、转发推荐。</p><p>笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。</p><p>我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭：</p><figure><img src="https://img.kvh.io/16-1-29/87155741.jpg" alt="bugtags"><figcaption aria-hidden="true">bugtags</figcaption></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;关于学习方式续&quot;&gt;关于学习方式续&lt;/h1&gt;
&lt;p&gt;回忆起大学那个白衣飘飘的年代，开始金工实习却发现基础学的不牢靠，越来越胆小，越来越糊涂。所幸得到一位高年级学姐指导，赶紧找当时的书或者笔记，快速把基础知识温习一遍，
      
    
    </summary>
    
      <category term="code" scheme="https://kvh.io/categories/code/"/>
    
    
      <category term="Android" scheme="https://kvh.io/tags/Android/"/>
    
      <category term="EmbraceAndroidStudio" scheme="https://kvh.io/tags/EmbraceAndroidStudio/"/>
    
      <category term="拥抱 Android Studio" scheme="https://kvh.io/tags/%E6%8B%A5%E6%8A%B1-Android-Studio/"/>
    
  </entry>
  
</feed>
