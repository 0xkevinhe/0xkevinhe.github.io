<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin He&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0xkevinhe.xyz/"/>
  <updated>2023-09-27T07:37:55.302Z</updated>
  <id>https://0xkevinhe.xyz/</id>
  
  <author>
    <name>Kevin He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blockchain-governance</title>
    <link href="https://0xkevinhe.xyz/blockchain-governance.html"/>
    <id>https://0xkevinhe.xyz/blockchain-governance.html</id>
    <published>2022-10-07T00:47:42.000Z</published>
    <updated>2023-09-27T07:37:55.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>BNB Chain 因为官桥被黑，停止工作。</p><ul><li><p>事件官方 Twitterhttps://twitter.com/BNBCHAIN/status/1578148078636650496</p></li><li><p>社区跟踪https://twitter.com/samczsun/thread/1578182840751050752</p></li></ul><h1 id="讨论">讨论</h1><p>去中心化和治理的边界在哪里</p><p>社会共识是什么</p><p>治理的边界在哪里</p><p>是否应该治理</p><p>以什么程序启动治理</p><p>有没有预设方案来更好的治理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;BNB Chain 因为官桥被黑，停止工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事件官方 Twitter
https://twitter.com/BNBCHAIN/status/1578148078636650496&lt;/p&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>web3-nft-overviews</title>
    <link href="https://0xkevinhe.xyz/web3-nft-overviews.html"/>
    <id>https://0xkevinhe.xyz/web3-nft-overviews.html</id>
    <published>2022-07-05T15:07:14.000Z</published>
    <updated>2023-09-27T07:01:22.200Z</updated>
    
    <content type="html"><![CDATA[<p>Last month, we did a small-scale web3 and NFT sharing offline, andthe audience was a group of Tesla owners.</p><p>Considering that most of the audience are non-crypto users, thecontent of the sharing will focus on the overview level, introducingconcepts and specific cases, but also involving some personal practicalwork experience and insights.</p><p>Admittedly, these two topics are still sensitive words in China, so Idon't expect the audience to fully accept my insights, but I do ask themto keep an open mind and be willing to learn about some content that isoffensive to the mainstream media.</p><p>Finally, a word to all bystanders: when the bubble rises, some peoplechoose to be a wise onlooker, others choose to experience it, and whenthe bubble dissipates, the wise reap the wisdom, and the pro-lifers reapthe experience or wealth.</p><p><a href="https://raw.githubusercontent.com/changbinhe/images/master/static/Web3%26NFT-overviews.pdf">PDF</a></p><p>================================================================================================</p><p>上月在线下做了一场小规模的web3和NFT的分享，受众是一个兴趣群的群友。</p><p>考虑到大部分听众都是非链圈或者币圈用户，分享内容会集中在overview层次，介绍概念和具体的case为主，也会涉及到一些个人的实际工作体会和行业判断。</p><p>诚然，这两个话题在国内依然处于准敏感词的状态，我也不强求听众能够完全接受我的见解，但求大家保持一颗开放的心，愿意去了解一些主流媒体所不齿的内容。</p><p>最后，给所有的旁观者一句话，当泡沫起来的时候，有的人选择做一个旁观的智者，另外一些人选择亲身去体验和深入，当泡沫散去，智者收获了智慧，亲历者收获了体验或者财富。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Last month, we did a small-scale web3 and NFT sharing offline, and
the audience was a group of Tesla owners.&lt;/p&gt;
&lt;p&gt;Considering that most
      
    
    </summary>
    
      <category term="web3" scheme="https://0xkevinhe.xyz/categories/web3/"/>
    
    
      <category term="nft" scheme="https://0xkevinhe.xyz/tags/nft/"/>
    
  </entry>
  
  <entry>
    <title>zksync 存储：sparse-merkle-tree 存储</title>
    <link href="https://0xkevinhe.xyz/sparse-merkle-tree.html"/>
    <id>https://0xkevinhe.xyz/sparse-merkle-tree.html</id>
    <published>2021-02-09T12:02:00.000Z</published>
    <updated>2023-09-27T07:01:22.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。</p><h1 id="merkle-tree">merkle tree</h1><p><a href="https://en.wikipedia.org/wiki/Merkle_tree">merkle tree</a>常用于区块链存储数据和快速校验数据。其构造特点是叶节点使用数据的 hash进行标记，中间节点使用所有子节点的 hash进行标记。</p><figure><img src="./sparse-merkle-tree/merkle-tree.png" alt="merkle-tree"><figcaption aria-hidden="true">merkle-tree</figcaption></figure><p>对于 merke tree 的操作，包含：插入节点、获取树根、计算 merkle证明、检验 merkle 证明。</p><p>计算 merkle 证明包含：</p><p>1）计算存在证明</p><p>2）计算不存在证明</p><p>在原始的 merkle tree上，很容易生成存在性证明，但是难以生成不存在证明。</p><h1 id="sparse-merkle-tree">sparse merkle tree</h1><p>为了解决这个问题，同时零知识证明也要求账号在树上的位置具有确定性，因此引入sparse merkle tree，有如下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一棵满二叉树</span><br><span class="line">数据是索引的，每个数据会放到对应的索引的叶子上</span><br><span class="line">存在性证明，merkle path</span><br><span class="line">不存在性证明，需要证明是 null</span><br></pre></td></tr></table></figure><h1 id="优化">优化</h1><p>1）预计算空值哈希</p><p>由于大部分情况下，树并不会真的满，而是非常的稀疏。可以预计算H(null)、H(H(null)|H(null))、H(H(H(null)|H(null))|H(H(null)|H(null)))等层级上的值，达到加速的效果。</p><p>2）并行计算左右子树哈希</p><p>H(H(left)|H(right)) 这类操作要求快速计算左右子树的哈希值，并行计算可以计算。</p><h1 id="实现">实现</h1><p><a href="https://github.com/matter-labs/zksync/blob/master/core/lib/crypto/src/merkle_tree/parallel_smt.rs">rust-matter-labs</a></p><p><a href="https://github.com/iden3/iden3js/blob/master/src/sparse-merkle-tree/sparse-merkle-tree.js">js-iden3</a></p><p><a href="https://github.com/iden3/go-iden3-core/blob/master/merkletree/merkletree.go">golang-iden3</a></p><h1 id="文献参考">文献参考</h1><p><a href="https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837">whats-a-sparse-merkle-tree</a></p><p><a href="https://blog.iden3.io/sparse-merkle-trees-visual-introduction.html">sparse-merkle-trees-visual-introduction</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;本文先介绍了 sparse merkle tree，接下来介绍 zksync 中数据持久化。&lt;/p&gt;
&lt;h1 id=&quot;merkle-tree&quot;&gt;merkle tree&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikip
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="zkp" scheme="https://0xkevinhe.xyz/tags/zkp/"/>
    
  </entry>
  
  <entry>
    <title>关于智能钱包</title>
    <link href="https://0xkevinhe.xyz/smart-wallet.html"/>
    <id>https://0xkevinhe.xyz/smart-wallet.html</id>
    <published>2021-01-13T01:58:57.000Z</published>
    <updated>2023-09-27T07:01:22.192Z</updated>
    
    <content type="html"><![CDATA[<p>Vitalik 在 1-11在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。</p><p>原文不赘述，下文将主要记录要点和思考。</p><h1 id="原文">原文</h1><p><a href="https://vitalik.ca/general/2021/01/11/recovery.html">英文</a></p><p><a href="https://www.chainnews.com/articles/195564221840.htm">中文</a></p><h1 id="要点">要点</h1><h2 id="guardian-的选择">guardian 的选择</h2><p>抵抗 guardian 联合作恶：</p><p>1）不公开</p><ul><li>对 list 进行哈希</li></ul><blockquote><p>fulllist，如何获得？</p></blockquote><ul><li>guardian确定性的生成一个用于恢复的地址；只在需要恢复的时候用到一次；</li></ul><p>2）来自不同的 social circle</p><h2 id="对于加密价值的讨论">对于加密价值的讨论</h2><p>有一种论调认为，社交恢复，是恢复到了相信人，是对区块链和加密的背叛。</p><p>Vitalik认为，加密不是移除所有的信任，其目的是提供更多的选择，来决定去相信谁；允许可控的信任：容许某些人代替做某些事，而没有能力做所有事。</p><h2 id="对抗小偷">对抗小偷</h2><p>sign key 可能丢失，可以增加一个保险柜功能，把 token进入其中；在保险柜中的token，交易可消。在发起交易和交易生效中间，增加了一个可撤回的缓冲期；还可以通过增加vault 的可编程性支持更多的功能。</p><h2 id="argent-和路印等现行社交钱包的两大挑战">Argent和路印等现行社交钱包的两大挑战</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）对中继的依赖</span><br><span class="line">2）交易费高</span><br></pre></td></tr></table></figure><p>目前的流行做法，是中继官方的签名的在链下进行，收集之后打包发送到服务器；</p><blockquote><p>对于这里的「收集」的概念有一定疑问； 假设一个用户有 7个guardian，路印是收集齐了4 个guardian的签名，才发送到链上？</p></blockquote><h2 id="两大挑战的解决方案">两大挑战的解决方案：</h2><ul><li>当前改造方式</li></ul><p><a href="https://docs.opengsn.org/learn.html">generalizeddecentralized relayer network</a></p><blockquote><p>以太坊加油站（与 heco 的元交易有异曲同工之处）</p></blockquote><p><a href="https://our.status.im/account-abstraction-eip-2938/">allowtransactions to begin from contracts</a></p><blockquote><p>修改以太坊协议，允许合约主动发起交易。</p></blockquote><ul><li>彻底改造方式：迁移到 layer2</li></ul><blockquote><p>为什么能解决问题？资金首先来自 1 层？在二层里面实现智能钱包逻辑？</p></blockquote><h1 id="思考">思考</h1><ol type="1"><li><p>如果是一个定制的链的场景，可以采用更激进的方式来改造链，是否可以定制一个对用户友好的钱包系统？</p></li><li><p>思考免费钱包或者网络可能性，可以使用<a href="https://docs.hecochain.com/#/en-us/dev/meta_tx">原生元交易</a>，对交易费进行补贴。</p></li></ol><h1 id="总结">总结</h1><p>钱包本身存在易用性和安全性的矛盾。公私钥、备份助记词这种操作，对于习惯了只记录一个pin 的 web2.0用户而言不友好，这可能也是阻碍区块链向更大量的用户普及的一部分原因。</p><p>支持社交恢复的智能钱包，免去了用户记录助记词的困难，将安全性托付于社交关系，易用性上有了提升，但是也存在一些问题。Vitalik难得之处在于，不止提出问题，还提供了解决方案的思考。</p><p>当前以太坊社区，开始逐步理解和使用 layer2，将 layer2和智能钱包结合，将有利于以太坊网络向更大体量的用户推广。</p><p>欢迎留言或者联系博主对相关问题讨论！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vitalik 在 1-11
在博客上发表了关于智能钱包的综述。文中介绍了硬件钱包、多签钱包，着重介绍了社交恢复智能钱包，针对社交恢复钱包面临的各方面问题，提出了对应的策略。&lt;/p&gt;
&lt;p&gt;原文不赘述，下文将主要记录要点和思考。&lt;/p&gt;
&lt;h1 id=&quot;原文&quot;&gt;原文&lt;/h1
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="wallet" scheme="https://0xkevinhe.xyz/tags/wallet/"/>
    
  </entry>
  
  <entry>
    <title>0x协议-介绍</title>
    <link href="https://0xkevinhe.xyz/0x-intro.html"/>
    <id>https://0xkevinhe.xyz/0x-intro.html</id>
    <published>2021-01-01T02:49:05.000Z</published>
    <updated>2023-09-27T07:01:22.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心">核心</h1><p>链下撮合（订单簿在链下）、链上结算（资金划转）</p><h1 id="角色">角色</h1><p>maker 挂单者</p><p>taker 吃单者</p><h1 id="实现">实现</h1><ul><li>maker 创建订单信息，签名 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">makerAddress</span><br><span class="line">takerAddress</span><br><span class="line">makerAssetData</span><br><span class="line">takerAssetData</span><br><span class="line">makerAssetAmount</span><br><span class="line">takerAssetAmount</span><br><span class="line">expirationTimeSeconds</span><br><span class="line">fee</span><br><span class="line">...</span><br><span class="line">签名</span><br><span class="line">哈希</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：</p></blockquote><p>takerAddress 是空——直到taker接单</p><ul><li><p>relayer 链下撮合 taker 接受 maker的订单，签名，提交到智能合约</p></li><li><p>链上结算 合约实现资金划转</p></li></ul><h1 id="问题">问题</h1><p>1）maker 如何取消交易</p><p>订单过期</p><p>2）交易效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">预先检查</span><br><span class="line">链上成交</span><br></pre></td></tr></table></figure><h1 id="与-uniswap-对比">与 uniswap 对比</h1><p>1）uni 有流动性提供者，一个 pair 的两个 token 都需要提供</p><p>2）uni 的价格是链上发现的</p><p>3）0x 只是交易意愿撮合，用户的资产不需要抵押</p><h1 id="总结">总结</h1><p>0x协议核心是定义了一个「链下撮合，链下成交」的结构，但正式由于分离了链上和链下，其成交效率有一定折扣。</p><p>其后继者 uniswap 是一个整体闭环。</p><h1 id="参考">参考</h1><p><a href="https://0x.org/docs/core-concepts">0x-protocol</a></p><p><a href="https://www.jinse.com/blockchain/247474.html">0x-intro-jnse</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;核心&quot;&gt;核心&lt;/h1&gt;
&lt;p&gt;链下撮合（订单簿在链下）、链上结算（资金划转）&lt;/p&gt;
&lt;h1 id=&quot;角色&quot;&gt;角色&lt;/h1&gt;
&lt;p&gt;maker 挂单者&lt;/p&gt;
&lt;p&gt;taker 吃单者&lt;/p&gt;
&lt;h1 id=&quot;实现&quot;&gt;实现&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;maker 
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="defi" scheme="https://0xkevinhe.xyz/tags/defi/"/>
    
  </entry>
  
  <entry>
    <title>《你就是孩子最好的玩具》读书笔记</title>
    <link href="https://0xkevinhe.xyz/reading-emotion-coaching.html"/>
    <id>https://0xkevinhe.xyz/reading-emotion-coaching.html</id>
    <published>2020-10-05T10:05:12.000Z</published>
    <updated>2023-09-27T07:01:22.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。</p><p>人生来就是一张白纸，父母是第一位老师，家庭教育对于塑造一个人的品格，有关键作用。</p><p>在教育这个事情上，说实话，也是战战兢兢，一不留神，就可能把原先的不那么正确的观念带给了孩子。</p><p>这个时候，不能盲目，不能下意识，只能多阅读、多思考、多观察、多实践，或许能减少一些内心的焦虑。</p><p>这是一本儿童教育的书，核心观点是对孩子进行情感引导式教育。作者摒弃了控制式、放任式、奖励式、惩罚式的教育。等等，这都是不对的？感觉颠覆了三观。细读下来，发现奖励和惩罚还是会在，不过占主导的是发挥同理心，进行情感引导和沟通。</p><p>这本书又是一本手册类的书，列举儿童 0-7岁能出现的大部分让家长抓狂的情形再现、原因分析和解决方案，是值得多次翻阅和查找的一本书。</p><h1 id="信息卡片">🏷信息卡片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">名称：《你就是孩子最好的玩具》</span><br><span class="line">作者: 金伯莉·布雷恩</span><br><span class="line">译者: 夏欣茁</span><br><span class="line">出版年: 2011-8</span><br><span class="line">页数: 191</span><br><span class="line">定价: 29.80元</span><br><span class="line">ISBN: 9787550102996</span><br><span class="line">豆瓣评分：       8.2</span><br><span class="line">起止时间：       2020.10.05--2020.10.05</span><br><span class="line">阅读次数：       1</span><br><span class="line">推荐指数：      🌟🌟🌟🌟</span><br><span class="line">获奖情况：     </span><br></pre></td></tr></table></figure><h1 id="写作背景">🌱写作背景</h1><p>作者是儿童教育专家，最早提出「情感引导式教育」概念，同时也是 2个男孩的母亲。</p><h1 id="原著呈现">📒原著呈现</h1><p>p9你是希望孩子处于对你的恐惧而听从你的建议，还是处于对你的爱戴和尊重而听从你的建议呢？p149 我们唯有甘心忍耐，才可能从刻意逃避转为欣然面对</p><h1 id="书摘批注">🖇书摘&批注</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">p3 情感引导是什么：想孩子传授情感规则，让他们知道如何辨认情感并且以恰当的方式来表达。</span><br><span class="line">懂得辨认和他人的情感，是形成和谐的人际关系的关键。</span><br><span class="line"></span><br><span class="line">p6 常见误区：</span><br><span class="line">1）控制和放任型</span><br><span class="line">2）轻视、低估和否定孩子的感受 </span><br><span class="line">3）采用外部激励和奖赏的手段 </span><br><span class="line">4）以消极后果作为惩罚</span><br><span class="line">小朋友没有去权利生气？不是的，小朋友要学会知道自己是否在生气，为什么生气，如何处理情绪。</span><br><span class="line"></span><br><span class="line">p33 同情的力量</span><br><span class="line">所谓同理心——站在别人角度看问题；对待小朋友，也需要如此。</span><br><span class="line"></span><br><span class="line">p38 情感引导的关键步骤：</span><br><span class="line">1）播下种子——提前预告</span><br><span class="line">2）观察和判断——了解孩子的情况</span><br><span class="line">3）聆听——倾听孩子的感受</span><br><span class="line">4）体察和同情</span><br><span class="line">期前预告接下来要发生的事情，以一种协商的姿态告知孩子，争取他的配合。</span><br><span class="line"></span><br><span class="line">p56 安抚毯、毛绒玩具</span><br><span class="line">作者提到她的孩子对于安抚毯有强烈的依赖。</span><br><span class="line"></span><br><span class="line">p62 不眠之夜</span><br><span class="line">在某些转折点之前，可能会折腾一阵子——例如突然开始说话之前</span><br><span class="line"></span><br><span class="line">p63 带婴儿外出</span><br><span class="line">做好心理建设最重要——孩子不大可能能长时间配合</span><br><span class="line"></span><br><span class="line">p79 为什么打屁股没用</span><br><span class="line">打屁股会影响孩子的学习能力，教唆使用暴力，体罚会造成伤害，打击自信心</span><br><span class="line">因为暴力而屈服，并不是真的理解，也没有主观产生能动性</span><br><span class="line"></span><br><span class="line">p92 奖励无法奏效</span><br><span class="line">核心是孩子应该是靠情感来激励，而不是物质；幸福感只能来源自身；</span><br><span class="line">久而久之，孩子会对奖励有过高的期望或者依赖。</span><br><span class="line">准确的夸赞孩子，而不是使用某种激励手段。</span><br><span class="line"></span><br><span class="line">p96 孩子耍脾气怎么办</span><br><span class="line">不要针锋相对</span><br><span class="line">提前计划，表达对孩子的理解和同情，保持冷静，不去理睬</span><br><span class="line"></span><br><span class="line">p149 无条件的爱</span><br><span class="line">了解自己，了解孩子</span><br></pre></td></tr></table></figure><h1 id="总结感悟">🙋‍♀️总结感悟</h1><ol type="1"><li><p>核心观点是父母与孩子建立良好的沟通和互动关系，理解、疏导孩各类「不良」行为。进而形成亲子之间的感情纽带，教会孩子正确理解和处理自己的情感，成长为一个具有良好社交能力的人。</p></li><li><p>孩子发展是分阶段的，不同孩子的发展又不是完全同步的，因此父母要尊重规律，抛弃不切实际的计划和目标——例如要求2 岁的孩子能安静坐着看电影。</p></li><li><p>作者认为新生儿阶段，应该给与足够的照料，这也是跟李玫瑾的观点类似。</p></li><li><p>2 岁以前，转移注意力的做法是可取的。</p></li><li><p>夸赞的方式：询问孩子自身的感受（你觉得怎么样？），站在主观的角度来观察（我喜欢你穿的衣服），而不是下一个看似客观的定义（你真会穿衣服）。</p></li><li><p>这本书实用性比较强，用了大量的案例来支撑观点。3-4-5章更是针对各类儿童的问题，都给出了分析和对策。</p></li><li><p>教会孩子与大人进行协作。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;随着年纪越大，对自己的认识深入，发现自己很多习惯或者性格的形成，都可以追溯到最早的生活经历。&lt;/p&gt;
&lt;p&gt;人生来就是一张白纸，父母是第一位老师，家庭教育对于塑造一个人的品格，有关键作用。&lt;/p&gt;
&lt;p&gt;在教育这个事情上，说实话，也是
      
    
    </summary>
    
      <category term="reading" scheme="https://0xkevinhe.xyz/categories/reading/"/>
    
    
      <category term="education" scheme="https://0xkevinhe.xyz/tags/education/"/>
    
  </entry>
  
  <entry>
    <title>币安链（BC）与币安智能链（BSC）简介</title>
    <link href="https://0xkevinhe.xyz/blockchain-bsc-intro.html"/>
    <id>https://0xkevinhe.xyz/blockchain-bsc-intro.html</id>
    <published>2020-09-19T03:46:03.000Z</published>
    <updated>2023-09-27T07:01:22.149Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。</p><h1 id="出发点">出发点</h1><p>总所周知，币安基于Cosmos-SDk 搭建了币安链（Binance Chain，下称BC），并于 2019 年上线了主网。那为什么还要有另外一个智能链（BinanceSmart Chain，下称 BSC）呢。白皮书解释和言外之意都描述下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）实际应用要求有更强的可编程性（要有智能合约）</span><br><span class="line">2）保证现有的 dex 的高性能（基于 cosmos-sdk的链交易并发是有瓶颈的）</span><br><span class="line">3）开发者的学习曲线（以太坊的 DApp 生态最完善）</span><br></pre></td></tr></table></figure></p><p>有了以上的需求，采用下面的技术路线和架构几乎是水到渠成。</p><h1 id="设计目标">设计目标</h1><h2 id="设计目标-1">设计目标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）BC 为主链，新链是一个独立区块链，对BC的依赖少</span><br><span class="line">2）兼容以太坊生态，保留跟随以太坊升级的可能性（改动越少，越好升级）</span><br></pre></td></tr></table></figure><h2 id="分工和职责">分工和职责</h2><p>为了旧链和新链的合理性，设计了下面的职责和结构。</p><p>BC核心职责： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）原有的 dex 功能</span><br><span class="line">2）平行链信息， staking 与治理</span><br></pre></td></tr></table></figure> > 平行staking 放在 BC上，也可能是考虑以后还会有别的新链出现~</p><p>BSC 核心职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）运行区块链，输出 staking 和治理依据</span><br><span class="line">2）运行复杂的 DApp</span><br></pre></td></tr></table></figure><p>由于两个链是相对独立的，所以称为是<code>平行链</code>。</p><h1 id="bsc-共识协议">BSC 共识协议</h1><p>BSC 采用了 所谓的 PoSA（Proof of StakedAuthority），你可以认为是以太坊代码中的 Clique 的一个小改动，综合了 PoA和 DPoS 的思路。大致流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）验证者或者代理人在 BC 上抵押</span><br><span class="line">2）BC 每24 小时重选合法验证者列表（21 个），通过跨链消息传递给 BSC</span><br><span class="line">3）BSC 根据验证者列表，选择节点轮流产块</span><br></pre></td></tr></table></figure><blockquote><p>PoA这个协议只能实现秒级的产块，但是无法实现秒级的确认（finality）。不确定做这个选择是为什么？可能是为了简单？个人认为有点偷懒了，采用基于BFT 的快速确认的共识协议可能会更好。</p></blockquote><p>简单而言，实现了基于 PoS 治理，PoA 产块。</p><p>从区块浏览器观察来看，BC 的区块周期大约1秒 2 个区块（sub-second），BSC 的区块周期是大约 3 秒。</p><p>因为 BC 使用的 tendermint 共识，所以交易确认时间也就是区块周期，BSC使用了是 PoA 共识，如果等待 21 个节点中的 +1/2确认，需要大约30s-1m。</p><h1 id="token">Token</h1><p>设计了在 BC 和 BSC 双向映射和转账的机制。</p><h2 id="token-定义">Token 定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BC：</span><br><span class="line">BEP2</span><br><span class="line">BNB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BSC：</span><br><span class="line">BEP2E</span><br><span class="line">BNB</span><br></pre></td></tr></table></figure><p>BNB 是两个平行链的 native token，交易手续费、抵押、奖励等都使用BNB。</p><p>BEP2 是 BC 上类似于 ERC20 的 Token。</p><p>BEP2E 是 BSC 上类似于 ERC20 的 Token，多了几个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol()</span><br><span class="line">decimals()</span><br><span class="line">onwer() //比较重要，声明拥有者地址，后面只有这个地址可以发起绑定操作</span><br></pre></td></tr></table></figure><p>那核心问题就是Token映射和转账，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEP2 of BC <--?-->BEP2E of BSC </span><br></pre></td></tr></table></figure><h2 id="token-绑定">Token 绑定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）确定 BC 上的BEP2和 BSC 上的 BEP2E 存在</span><br><span class="line">2）确定和锁定发行量</span><br><span class="line">  假如总发行量 S，</span><br><span class="line">  BC 初始流通 K</span><br><span class="line">  BSC 初始流通 S-K</span><br><span class="line">token 发行者应该在对应的链上把未流通的量 lock 到系统合约或者账户，使得两个链上的发行总量是 S。</span><br><span class="line">3）BEP2 token 的发行者在 BC 上发起绑定交易</span><br><span class="line">完成检查之后，绑定请求发送到 relayers</span><br><span class="line">4）BSC relayer 将跨链绑定信息转发给 TokenHub 合约</span><br><span class="line">5）BEP2E 的 owner 调用 TokenHub 合约的方法，后者确认 1.未被绑定 2.symbol 发行量和最小数量位 3。锁定正常</span><br><span class="line">6）BC 通过 Oracle 收到返回信息，将 contract address 和 decimal 信息写入 BC</span><br></pre></td></tr></table></figure><p>注意，以上流程，需要 BC 上的系统托管账户，和 BSC上的系统合约作为基础设施。</p><h1 id="链互操作">链互操作</h1><h2 id="平行链结构">平行链结构</h2><p>官方这张图很不错。 <img src="https://raw.githubusercontent.com/changbinhe/images/master/blog/blockchain-bsc-intro/para-chain.png" alt="para-chain"></p><p>注意 BSC Relayer 和 Oracle Relayer，分别负责把信息转发到 BSC 和BC。</p><p>下面先介绍这两个角色，再介绍具体的跨链操作方式。</p><blockquote><p>值得一提的是，币安在设计这两个角色的时候，已经考虑到了去中心化环境可能带来的问题和采取了一定的对策。</p><p>但是，这两个角色本身的合法性和提供的信息的验证问题，是不够清晰的。</p></blockquote><h2 id="bsc-replayer">BSC replayer</h2><p>BSC relayer 负责将信息从 BC传递到BSC。</p><p>需要存入一定量的 BNB 到BSC链上进行「注册」，BSC 只会接受注册的relayers。</p><ul><li>激励机制</li></ul><p>1）用户操作，由用户买单</p><p>2）系统同步，由 BSC 系统买单</p><ul><li>为了避免 relayers 垄断的情况</li></ul><p>1）奖励是批量分配</p><p>2）在批量中，奖励不是线性分配</p><h2 id="oracle-relayers">Oracle Relayers</h2><p>负责将信息从 BSC 传递到BC，消息本身需要经过BC 验证者的共识。</p><p>在提交之前，Oracle 需要等待足够的 BSC 区块确认（PoA 确认需要 1分钟）。</p><p>跨链奖励会成为区块奖励的一部分，分配给验证者。</p><blockquote><p>将来也会引入对 Oracle 的 slashing</p></blockquote><h2 id="bc-bsc">BC->BSC</h2><p>依赖BSC Replayers，消息将会进入到预编译的系统智能合约。</p><p>消息类型： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Token绑定</span><br><span class="line">转账</span><br><span class="line">错误处理</span><br><span class="line">验证者信息更新</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="bsc--bc">BSC ->BC</h2><p>如果是通过交易产生的跨链事件，其流程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tx -> EVM -> event -> oracle</span><br></pre></td></tr></table></figure><p>每个BC 链验证者需要运行 oracle 进程作为 oracle relayer。</p><p>跨链消息包，也会被 BC 中的 validator进行投票，签名超过2/3即为合法。</p><h2 id="超时和错误处理">超时和错误处理</h2><p>这个在跨链协议中很重要，涉及到回滚等。</p><p>当某个 sequence 的 tx 卡主，超时之后，将会有一个 skipsequence交易出现，对卡主的 sequence 做出不可执行的标记。</p><p>社区决定如何处理。</p><blockquote><p>链上无法解决的问题，最终还是推到社区||-_-</p></blockquote><h1 id="staking-和治理">Staking 和治理</h1><p>BC 和 BSC 的Staking 的基本概念与其他基于POS的链没有大不一样，要点如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）抵押，代理</span><br><span class="line"></span><br><span class="line">2）按照 token 排名，top n 作为验证者</span><br><span class="line"></span><br><span class="line">3）validator 分享收益给 delegator</span><br><span class="line"></span><br><span class="line">4）validator 会有被 slashing 的危险，delegator 需要分担</span><br><span class="line"></span><br><span class="line">5）token 有赎回期</span><br></pre></td></tr></table></figure><p>具体到 BC 和 BSC 的配合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）BC 上抵押和代理 BNB</span><br><span class="line"></span><br><span class="line">2）BSC 的 validator 由 BC 上的 staking 模块决定，UTC 00:00:00 发出跨链通讯</span><br><span class="line"></span><br><span class="line">3）BSC 将验证者工作的信息，通过跨链通讯回传到 BC</span><br><span class="line"></span><br><span class="line">4）在 BC 上进行 reward 分配</span><br></pre></td></tr></table></figure><h1 id="罚没">罚没</h1><p>基于 PoS 的公链，其活性需要全体 validator的诚实、如实工作保证的。</p><p>为了从经济学上推动这类行为，引入了罚没机制。</p><h2 id="双签">双签</h2><p>所谓的双签，是对于同一高度+同一个parent的区块进行多与一次的签名。任何第三方都可以，以 slash request 的方式发到BC 上。</p><p>1）从 validator 中移除——发出 update 事件</p><p>2）罚没一定量</p><p>3）一部分给提交者</p><p>4）另外的给验证者监管账户</p><h3 id="不稳定">不稳定</h3><p>一个内部合约，统计工作情况。</p><p>1）如果超过不工作阈值，其已得收益，将不会发给 BC，而是分2给其他的validators。</p><p>驱使运营不好的节点，delegator 将会离开</p><p>2）如果工作情况低于另外一个阈值，将会通知 BC，发生另外一个slashing</p><h1 id="总结">总结</h1><p>总的来讲，其技术结构和治理方式参考了一众跨链项目 （例如 cosmos 和polkadot），也参考了 DPoS 的一众项目（例如 EOS 和TRON）。机制设计上也留出了后续扩展的空间。在本文写作之时（2020-09），BSC上已运行了若干 DeFi 应用，这也是 BSC 的实现最初目标（承接DApp）的佐证。</p><p>在文章中，笔者也提出了一些疑问，例如 PoA 的区块确认时间过长，Relayer和 Oracle 本身的信息正确性问题等。</p><p>在单链技术还没有实质性突破的情况下（以太坊 2.0可能还需要若干年才能成熟，或者不会成功），这类平行扩展的思路，也不失为快速开展业务尝试的一种实干派做法。</p><h1 id="参考">参考</h1><p><a href="https://www.binance.org/">BC 官网</a></p><p><a href="https://dex-bin.bnbstatic.com/static/Whitepaper_%20Binance%20Smart%20Chain.pdf">BSC白皮书</a></p><p><a href="https://explorer.binance.org/">BC 浏览器</a></p><p><a href="https://bscscan.com/">BSC 浏览器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍的是中心化交易所币安（binance.com）在区块链上的一些工作，主要是介绍币安链（BC）和币安智能链（BSC），除了综述官方文档之外，也会加入一些个人的看法。&lt;/p&gt;
&lt;h1 id=&quot;出发点&quot;&gt;出发点&lt;/h1&gt;
&lt;p&gt;总所周知，币安基于Cosmos-SDk 
      
    
    </summary>
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://0xkevinhe.xyz/tags/blockchain/"/>
    
      <category term="DeFi" scheme="https://0xkevinhe.xyz/tags/DeFi/"/>
    
  </entry>
  
  <entry>
    <title>《影响力》读书笔记</title>
    <link href="https://0xkevinhe.xyz/reading-influence.html"/>
    <id>https://0xkevinhe.xyz/reading-influence.html</id>
    <published>2020-08-17T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。</p><p>通过阅读这本书，可以为<code>运营活动</code>或者<code>销售技巧</code>寻找理论根据，做到知其所以然。</p><h1 id="信息卡片">🏷信息卡片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作者:[美] 罗伯特·西奥迪尼</span><br><span class="line">出版社: 中国人民大学出版社</span><br><span class="line">出品方: 湛庐文化</span><br><span class="line">原作名: Influence: The Psychology of Persuasion</span><br><span class="line">译者: 陈叙</span><br><span class="line">出版年: 2006-5</span><br><span class="line">页数: 353</span><br><span class="line">定价: 45.00元</span><br><span class="line">装帧: 平装</span><br><span class="line">丛书: 湛庐文化· 商业智慧</span><br><span class="line">ISBN: 9787300072487</span><br><span class="line">起止时间：       2020.07.15--2020.08.15</span><br><span class="line">阅读次数：       2</span><br><span class="line">推荐指数：      🌟🌟🌟🌟</span><br><span class="line">获奖情况：                                                                                                </span><br></pre></td></tr></table></figure><h1 id="写作背景">🌱写作背景</h1><p>作者社会心理学家，致力于影响力的研究</p><p>作者使用了所谓的参与式观察（间谍）参与到一些商品或者服务的销售工作中，以获取技巧</p><h1 id="原著呈现">📒原著呈现</h1><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/blog/reading-influence/mindmap.png" alt="mindmap"><figcaption aria-hidden="true">mindmap</figcaption></figure><h1 id="书摘批注">🖇书摘&批注</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">p3-4：绿宝石价格提高了，反而销量好了；</span><br><span class="line"></span><br><span class="line">人在成长过程中，接受了观念，价格贵=东西好；</span><br><span class="line">调高了价格，触发了用户的顺从按钮；在这一点上，人类也是某种基于反应的动物——跟雌火鸡一样；</span><br><span class="line"></span><br><span class="line">p9：文明的进步，就是人们在不假思索中可以做的事情更多</span><br><span class="line">所谓的专家，也就是在不断的训练中，形成了对于工作的问题的肌肉记忆</span><br><span class="line"></span><br><span class="line">p15-16：对比原理</span><br><span class="line">先看霹雳娇娃，会影响给自己对象的打分；</span><br><span class="line">先兜售贵的商品、其次是便宜商品——可能会让总收益最大</span><br><span class="line">先给一个不好的方案、然后给一个正常的方案，可能会有助于方案的接受</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二章：互惠——给予、索取、在索取</span><br><span class="line"></span><br><span class="line">p25：给对方寄贺卡，会受到很多回信</span><br><span class="line">在一个社交网络早期，主动加别人，会有一定的会加率</span><br><span class="line"></span><br><span class="line">p28：给对方带一瓶可乐，就可以获得更高的彩票销售</span><br><span class="line">不要忽视小恩小惠的作用；要习惯对别人施以援手——赠人玫瑰，手留余香</span><br><span class="line"></span><br><span class="line">p33：政府高层的相互投票和联合</span><br><span class="line">奥巴马和特朗普该多难啊！</span><br><span class="line"></span><br><span class="line">p35：安利臭虫</span><br><span class="line">所谓的试吃，也是这道理吧</span><br><span class="line"></span><br><span class="line">p38：人有送礼的义务、接受的义务、更有偿还的义务</span><br><span class="line">想起了老教父柯里昂</span><br><span class="line"></span><br><span class="line">p48：拒绝-后撤</span><br><span class="line">常见的销售技巧——漫天要价，坐地还钱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三章：承诺和一致性——脑子里的怪物</span><br><span class="line"></span><br><span class="line">p63：一开始就拒绝，比最后返回要容易——达芬奇</span><br><span class="line">至理名言，特别是对于推销cold call</span><br><span class="line"></span><br><span class="line">p67：所有人都一次次的骗自己，以便在做出选择之后，坚信自己做的没错</span><br><span class="line">you've got a dream, you've to protecet it</span><br><span class="line"></span><br><span class="line">p68：信仰、言行和行为前后一致不一致的人，会被看成脑筋混乱表里不一；言行高度一致多数跟个性坚强、智力出众；它是逻辑性、稳定性、诚实感的核心</span><br><span class="line">胡忠献的忠，岳飞的忠</span><br><span class="line">吴三桂所谓没有定力</span><br><span class="line"></span><br><span class="line">p70：关于冥思会和缴费</span><br><span class="line">超自然的方法，可能是唯一解药；</span><br><span class="line"></span><br><span class="line">p73：玩具销售商的策略</span><br><span class="line">为了保持淡季的销量</span><br><span class="line"></span><br><span class="line">p85：战俘营的做法</span><br><span class="line">以小积大</span><br><span class="line"></span><br><span class="line">p86：个人承诺防止撕毁合同</span><br><span class="line">自己说出的话，自己要遵守承诺</span><br><span class="line"></span><br><span class="line">p90：额外的努力，费尽努力得到的东西，人人往往格外珍视</span><br><span class="line">追姑娘丈母娘设置困难</span><br><span class="line">公司的严格面试，也是一种投名状</span><br><span class="line">其中的成员，会强烈的维护这种准入</span><br><span class="line">建立团队凝聚力和卓越感，入会活动要艰辛</span><br><span class="line"></span><br><span class="line">p100：内心的压力</span><br><span class="line">你得找一个有力的理由，让他大多数情况下都保持城市，可这个理由又不能强大到让孩子觉得，自己完全是为了它才诚实</span><br><span class="line">太强烈的惩罚，可能不会奏效</span><br><span class="line">要是说谎，我会失望的</span><br><span class="line">这个对于教育孩子很有意义，要让遵守规则成为孩子自身的习惯，而不是被强迫的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第四章：社会认同——脑子里的怪物</span><br><span class="line"></span><br><span class="line">p120：依照别人意见行事</span><br><span class="line"></span><br><span class="line">盖得排行，大众点评</span><br><span class="line">街头围观，网红店雇人排队</span><br><span class="line"></span><br><span class="line">p138:寻求帮助</span><br><span class="line">找到特定的人寻求帮助</span><br><span class="line">旁</span><br><span class="line"></span><br><span class="line">p150:自杀新闻</span><br><span class="line">会导致更高的自杀率</span><br><span class="line"></span><br><span class="line">第五章：喜好——友好的盗贼</span><br><span class="line"></span><br><span class="line">p175:销售外表</span><br><span class="line">广告模特和销售人员都要漂亮</span><br><span class="line">p179:喜好</span><br><span class="line"></span><br><span class="line">广告的作用。第一次陌生，看了广告之后就觉得是名牌了</span><br><span class="line"></span><br><span class="line">p181:所谓的融合策略</span><br><span class="line">融合过程中导致的恶意，难道不是留下更大的影响么</span><br><span class="line"></span><br><span class="line">p184:拼图学习法</span><br><span class="line">竞争与合作</span><br><span class="line"></span><br><span class="line">p199:体育运动</span><br><span class="line">乒乓球、排球、奥运会等对国民认同的形成的作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第六章：权威——教化下的敬重</span><br><span class="line"></span><br><span class="line">p223:头衔</span><br><span class="line">都喜欢挂一堆头衔</span><br><span class="line">第七章：稀缺——数量少说了算</span><br><span class="line"></span><br><span class="line">p243:稀缺</span><br><span class="line">销售管用伎俩，create urgent</span><br><span class="line"></span><br><span class="line">p247:逆反心理</span><br><span class="line">有屏障，挑衅；测试界限；罗密欧朱丽叶，如果没有限制，可能不多久就分掉了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p253:信息审查</span><br><span class="line">「禁书」，快要被删，这都有助于传播</span><br><span class="line">p260:参与竞争稀缺资源，有强大的刺激性</span><br><span class="line">所谓的竞雄？拍卖</span><br></pre></td></tr></table></figure><h1 id="总结感悟">🙋‍♀️总结感悟</h1><p>顺从的力量，来自大量「正统」观念影响</p><p>从理论上了解影响力的来源：互惠、承诺和一致性、社会认同、喜好、权威、稀缺</p><p>验证和对照了一些日常的销售和运营策略</p><h1 id="他山之石">👯‍♀️他山之石</h1><p>🎥多媒体资料</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;这是一本关于影响力和顺从的书，作者使用了大量的案例来说明影响力来源。&lt;/p&gt;
&lt;p&gt;通过阅读这本书，可以为&lt;code&gt;运营活动&lt;/code&gt;或者&lt;code&gt;销售技巧&lt;/code&gt;寻找理论根据，做到知其所以然。&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="reading" scheme="https://0xkevinhe.xyz/categories/reading/"/>
    
    
      <category term="社会心理学" scheme="https://0xkevinhe.xyz/tags/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证介绍与项目实战</title>
    <link href="https://0xkevinhe.xyz/open-source-license.html"/>
    <id>https://0xkevinhe.xyz/open-source-license.html</id>
    <published>2020-04-28T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><p>在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到：</p><ul><li>使用和修改的条件是什么？</li><li>商用和分发的条件是什么？</li><li>本项目开源后使用什么许可证？</li></ul><p>本文将简要介绍对许可证（license）的理解，着重介绍一个实战项目处理方式。</p><h1 id="许可证介绍">许可证介绍</h1><p>许可证的内容，其实是博大精深。</p><p>首先许可证的种类特别的多，其次不同的许可的条款和细节也特别的多。</p><p>下面主要是介绍若干<code>主流且具有代表性</code>的许可证。</p><blockquote><p>主要参考了<a href="https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html">开源许可证教程-阮一峰的网络日志</a></p></blockquote><h2 id="名词解释">名词解释</h2><ul><li><p>分发</p><p>将版权作品从一个人转移到另外一个人；例如提供给别人；如果是本公司使用，不算分发。</p></li><li><p>传染</p><p>一个项目用到了某个许可证的代码，在某些条件下（例如分发），这个项目本身也需要使用这种许可证</p></li><li><p>许可证版本</p><p>同一个许可证，有版本号之间的区别，例如 GPL 有 v1/v2/v3。</p></li></ul><h2 id="宽松的许可证">宽松的许可证</h2><p>包含 MIT/ISC/BSD/Apache等，基本上这类许可证，是可以放心使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）BSD（二条款版）</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。</span><br><span class="line"></span><br><span class="line">（2） BSD（三条款版）</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</span><br><span class="line"></span><br><span class="line">（3）MIT</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</span><br><span class="line"></span><br><span class="line">（4）Apache 2</span><br><span class="line"></span><br><span class="line">分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</span><br></pre></td></tr></table></figure><h3 id="copyleft-许可证">Copyleft 许可证</h3><p>代码可以随意复制，有如下前提：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如果分发二进制格式，必须提供源码</span><br><span class="line">- 修改后的源码，必须与修改前保持许可证一致</span><br><span class="line">- 不得在原始许可证以外，附加其他限制</span><br></pre></td></tr></table></figure><p>核心在于，修改后的代码，不得闭源。</p><ul><li>AGPL</li></ul><p>最严格的GPL，除非获得商业授权，否则无论以何种方式修改或者使用代码，都需要开源。</p><blockquote><p>云服务使用AGPL 的源码，不构成分发，也也需要开源</p></blockquote><ul><li>GPL</li></ul><p>如果分发软件，则使用和修改都必须开源，整个项目都必须采用GPL许可。</p><ul><li>LGPL</li></ul><p>分发时，如果是使用动态类库的方式引用，可以不开源</p><ul><li>MPL</li></ul><p>分发时，只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p><blockquote><p>无论是商业应用，还是开源项目，在采用AGPL/GPL/LGPL/MPL都要特别的小心。</p></blockquote><h1 id="许可证检测">许可证检测</h1><p>介绍两个工具，分别检测代码文件和依赖的 license。</p><h2 id="检测代码">检测代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/addlicense</span><br></pre></td></tr></table></figure><p>可以递归检测当前目录下的所有代码文件，许可证声明的情况，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addlicense -check ./ |sort > lc.txt </span><br></pre></td></tr></table></figure><p>可以把未添加许可证的文件都输出到lc.txt 文件中，方便后续进行检查。</p><h2 id="检测依赖库">检测依赖库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/go-licenses</span><br></pre></td></tr></table></figure><p>查看一个依赖库所使用的版权信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-licenses csv repo</span><br></pre></td></tr></table></figure><p>可以通过一个这个脚本项目进行批量测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat dep.txt |while read line</span><br><span class="line">do </span><br><span class="line">echo "start checking package $line"</span><br><span class="line">go-licenses csv $line</span><br><span class="line">echo ""</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="许可证添加">许可证添加</h2><p>笔者主要使用 idea 的 IDE 进行程序开发，它有管理版权信息的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Preference->editor->Copyright</span><br></pre></td></tr></table></figure><p>可以添加不同的 Profiles，然后使用 IDE的功能进行自动添加和更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）设置默认 copyright</span><br><span class="line">preference->editor->Copyright</span><br><span class="line">设置 default project copyright，选中一种配置，这个可能会根据不同的文件需要切换</span><br><span class="line"></span><br><span class="line">2）选中代码文件或者文件夹</span><br><span class="line"></span><br><span class="line">3）菜单栏->Code->Update Copyright</span><br></pre></td></tr></table></figure><h1 id="项目实战">项目实战</h1><p>下文介绍对于一个实际项目进行许可证声明。</p><h2 id="项目背景">项目背景</h2><p>该项目主语言是 golang，采用了自某 LGPL的项目的一部分类库作为基础代码。</p><h2 id="版权主体">版权主体</h2><p>也就是版权声明的第一行的关键信息，例如：</p><ul><li>go-ethereum</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2016 The go-ethereum Authors</span><br></pre></td></tr></table></figure><ul><li>go-algorand</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) 2019-2020 Algorand, Inc.</span><br></pre></td></tr></table></figure><p>可以选择是作者主体，或者公司主体。</p><h2 id="项目-license">项目 license</h2><p>由于该项目的代码，部分使用了修改了 LGPL 项目代码作为基础工具。</p><p>根据 LGPL 的规定，本项目也需要使用 LGPL 作为 license。</p><h2 id="版权声明">版权声明</h2><p>声明版权，一般两部分：</p><h4 id="项目级别的-license-文件">1）项目级别的 LICENSE 文件</h4><p>由于大部分的许可证都是控制包级别的许可，所以这种方式也足够</p><h4 id="代码级别的-copyright-文件头">2）代码级别的 copyright 文件头</h4><p>每一个原创的文件都设置了版权信息</p><h2 id="项目级别的-license">项目级别的 license</h2><p>一般而言，是找到你的 license 的文本，将文件放置于项目根目录。</p><blockquote><p>不同许可证可能有点不一样</p></blockquote><p>一般而言，在 github 建立公开项目的时候，会提示选择一个 license。</p><p>如果初始化忘记了，也可以web界面上，新建一个名字是<code>LICENSE</code>的文件，来显式触发选择license。</p><h2 id="代码级别的-copyright-文件头-1">代码级别的 copyright 文件头</h2><p>使用第三方代码，主要分为，<code>fork 引用</code> 和<code>library 依赖</code>。</p><p>fork 是指把代码直接放到了代码库中，修改或者不修改。</p><p>library 是库依赖，例如通过 go.mod 的方式进行依赖。</p><h3 id="fork-引用">fork 引用</h3><p>代码分类 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1）项目原创文件</span><br><span class="line"></span><br><span class="line">2）项目修改第三方库的文件</span><br><span class="line"></span><br><span class="line">3）项目直接引用第三方库的文件</span><br><span class="line"></span><br><span class="line">4）fork 过来的开源库</span><br><span class="line">可能存在包内 license，单文件可能没有copyright</span><br><span class="line"></span><br><span class="line">5）忽略 license 文件的内容</span><br><span class="line"></span><br><span class="line">非 golang 文件</span><br><span class="line">gencode 生成的以 gen_开头的文件</span><br><span class="line">其他自动生成的文件</span><br></pre></td></tr></table></figure></p><p>有了如上的分类，你就可以使用 IDE 创建多个不同的 Copyright Profiles来处理不同的文件了。</p><p>结合 addlicense 工具，相信这部分工作将可以顺利完成。</p><h4 id="library-依赖">library 依赖</h4><p>使用上述的依赖检测工具，查看是否有不合适的许可证。</p><blockquote><p>如果一个依赖库，license 不是MIT/ISC/BSD/Apache其中的一种，那就要小心了！</p></blockquote><h1 id="tbd-topics">TBD-Topics</h1><p>有一些话题需要进一步讨论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1）如果项目源码计划商用，如何处理？</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>本文简要介绍了license的原理，着重介绍了项目实战，希望对读者有启发，欢迎讨论！</p><h1 id="参考">参考</h1><p>https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html</p><p>https://www.gnu.org/licenses/gpl-faq.html</p><p>https://choosealicense.com/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;介绍&lt;/h1&gt;
&lt;p&gt;在项目中第三方代码的时候，要注意源码许可证问题，因为这涉及到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用和修改的条件是什么？&lt;/li&gt;
&lt;li&gt;商用和分发的条件是什么？&lt;/li&gt;
&lt;li&gt;本项目开源后使用什么许可证？&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 作为服务器</title>
    <link href="https://0xkevinhe.xyz/osx-as-server.html"/>
    <id>https://0xkevinhe.xyz/osx-as-server.html</id>
    <published>2017-12-04T03:21:55.000Z</published>
    <updated>2023-09-27T07:01:22.161Z</updated>
    
    <content type="html"><![CDATA[<p>因为业务需要，我司有若干台服务器 Mac作为服务器。下面总结一下注意事项，作为记录。</p><h1 id="取消系统休眠">取消系统休眠</h1><p>曾经在这个问题上困扰很长时间。在升级了 <code>macOS High Sierra</code>之后，发现之前能够正常运行的程序出现问题。</p><p>具体表现是：</p><ol type="1"><li>ssh 登出之后不久，线上就开始报警</li><li>登陆进去查看 log，发现程序又是正常的</li><li>socket 连接提示传输错误</li><li>程序并没有 exit</li></ol><p>一开始怀疑是后台程序的权限问题，于是更新了后台程序的 launchd配置，确保了使用 root 用户运行，没有效果。</p><p>后来灵机一动，去具体分析程序的log，发现只要用户登出，输出就会停止，看起来是程序被挂起了。</p><p>分析可能被挂起的原因，只可能是系统休眠了。</p><p>直接登陆 GUI 系统，在系统设置中将节能设置改成：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-12-4/97778894.jpg" alt="节能设置"><figcaption aria-hidden="true">节能设置</figcaption></figure><p>生效了！</p><h1 id="守护进程">守护进程</h1><p>作为服务器，大多是需要运行守护进程。这就需要用到<code>launchd</code>，它能确保这是确保设备重启之后，守护能够自动运行。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Launchd">launchd</a>是一个开源框架，用于控制守护进程、程序、或者脚本，在 Mac OS X Tiger中引入。</p></blockquote><p>使用 launchd，主要需要注意下面几点：</p><ul><li>正确区分系统全局的守护和用户相关的守护进程</li></ul><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>类型</th><th>路径</th><th>运行用户</th></tr></thead><tbody><tr class="odd"><td>全局的守护进程</td><td>/Library/LaunchDaemons</td><td>root 用户或者使用 UserName key 对应的用户</td></tr><tr class="even"><td>系统的守护进程</td><td>/System/Library/LaunchDaemons</td><td>root 用户或者使用</td></tr></tbody></table><p>一般而言，把 plist 文件放到 <code>/Library/LaunchDaemons</code>即可。</p><ul><li>正确设置 plist 文件的权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  1 wheel  947 12  1 14:51 name_of_the_config.plist</span><br></pre></td></tr></table></figure><p>也即是： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户：root</span><br><span class="line">组：wheel</span><br><span class="line">权限： 0644</span><br></pre></td></tr></table></figure></p><ul><li>被运行的程序，需要是处于前台运行，否则 launchd会认为程序已经退出</li><li>如果需要全局性的守护进程，需要使用 sudo 运行</li></ul><h2 id="参考文档">参考文档</h2><p><a href="http://www.launchd.info/">http://www.launchd.info/</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html#//apple_ref/doc/man/5/launchd.plist">launchd.plist</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/launchctl.1.html#//apple_ref/doc/man/1/launchctl">launchctl</a></p><h1 id="内网穿透">内网穿透</h1><p>很多时候，macOS服务器并不是托管在机房，而是在某个比较方便管理的地方——例如办公室。</p><p>办公室的网络环境又千奇百怪，往往没有固定的外网 ip，往往是处于 NAT的网络环境或者是防火墙内，如果服务出现了问题，总不能直接跑去办公室吧。</p><p>尝试过各种 VPN 方案，动静太大，不稳定，放弃。下面介绍一下 <a href="https://github.com/inconshreveable/ngrok">Ngrok</a>。</p><p>官网简介：</p><blockquote><p>Secure tunnels to localhost ”I want to expose a local server behind aNAT or firewall to the internet.”</p></blockquote><p>基本的构架图如下：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-12-4/55782772.jpg" alt="Ngrok"><figcaption aria-hidden="true">Ngrok</figcaption></figure><p>这款软件是 C/S结构，使用服务器作为中转，只需要设置好服务器和客户端，不需要在路由器做任何处理。<code>软件的2.x 不开源，github 上只有 1.x 版本</code>，已经足够。</p><p>使用方式，参考<a href="https://imququ.com/post/self-hosted-ngrokd.html">imququ的博客</a>。</p><p>基本流程是： 1. clone 源码 2. 生成证书，拷贝 <code>base.pem</code> 到<code>assets/client/tls/ngrokroot.crt</code> 下 3. 运行<code>make release-server release-client</code> 4. <code>bin</code> 的ngrokd 和 ngrok 分别是服务器端和客户端</p><h1 id="总结">总结</h1><p>以上是对于 <code>macOS</code> 作为服务器的一些注意事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为业务需要，我司有若干台服务器 Mac
作为服务器。下面总结一下注意事项，作为记录。&lt;/p&gt;
&lt;h1 id=&quot;取消系统休眠&quot;&gt;取消系统休眠&lt;/h1&gt;
&lt;p&gt;曾经在这个问题上困扰很长时间。在升级了 &lt;code&gt;macOS High Sierra&lt;/code&gt;
之后，发现之前
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="macOS" scheme="https://0xkevinhe.xyz/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 配置中心</title>
    <link href="https://0xkevinhe.xyz/spring-cloud-config.html"/>
    <id>https://0xkevinhe.xyz/spring-cloud-config.html</id>
    <published>2017-10-13T15:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲话配置">闲话配置</h1><p>老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就满足了需求。</p><blockquote><p>配置（Configuration）是不修改代码的情况下，对程序的运行调整的能力。</p></blockquote><p>简单来讲，配置可以分成两类：</p><ol type="1"><li>系统配置：包括线程池大小、数据库连接等，变化频率较低</li><li>业务配置：功能开关，功能参数等，变化较为频繁</li></ol><p>程序的配置一般而言，分为几个环境：</p><ol type="1"><li>开发环境</li><li>测试环境</li><li>生产环境</li></ol><p>这几个环境的配置是有差异的，所以配置管理功能应当能够根据当前环境读取对应的配置。</p><p>前面提到的不修改代码，只是最低要求，相当多的情况下，程序是不能停机的，这就提出了热更新的需求。</p><p>另外，配置的修改应该是有记录可追溯的。</p><h1 id="spring-boot-的配置管理">Spring Boot 的配置管理</h1><p>Spring 实现了非常友好的配置读取方式，</p><p>Spring Boot 程序默认使用 application.properties 进行配置。</p><p>例如一个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=0</span><br></pre></td></tr></table></figure><p>在程序中可以通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value("${flag})</span><br><span class="line">int flag;</span><br></pre></td></tr></table></figure><p>来读取。</p><p>也可以通过设置多个配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application.properties</span><br><span class="line">application-dev.properties</span><br><span class="line">application-test.properties</span><br><span class="line">application-prod.properties</span><br></pre></td></tr></table></figure><p>application-dev.properties <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=1</span><br></pre></td></tr></table></figure> application-test.properties<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=2</span><br></pre></td></tr></table></figure></p><p>application-prod.properties <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=3</span><br></pre></td></tr></table></figure></p><p>和在 application.properties 中声明当前的活跃的 profile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure><p>来实现根据运行环境切换配置信息。</p><p>以上只是 Spring 强大的配置能力的冰山一角，有兴趣可以参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">外部配置文档</a>。</p><h2 id="这还不够">这还不够</h2><p>其实以上描述的 Spring Boot的配置能力已经很强了，但是有个很致命的问题——无法热更新。</p><p>如果非得实现热更新，那可以把配置做成 JSON 文件，再实现一个endpoint，重新读取一次配置。</p><p>假设有一千个实例呢？</p><h1 id="spring-cloud-config">Spring Cloud Config</h1><p>项目 github：<a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a></p><p>简介：External configuration (server and client) for Spring Cloud</p><p>这个项目包含两部分：</p><ul><li>Server</li></ul><p>负责从 git/svn 等版本管理系统中读取配置，并以 http的方式提供服务。</p><ul><li>Client</li></ul><p>根据客户端配置，从指定的 Server 中读取对应配置，并且与 Spring 本身的PropertyResource 和 Environment无缝结合。同时，提供了统一的方式进行配置热更新。</p><p>对于这个系统的基础配置和运行，可以参阅下面两个 url：</p><p><a href="https://spring.io/guides/gs/centralized-configuration/">https://spring.io/guides/gs/centralized-configuration/</a></p><p><a href="http://blog.didispace.com/spring-cloud-starter-dalston-3/">http://blog.didispace.com/spring-cloud-starter-dalston-3/</a></p><h2 id="实操进阶">实操进阶</h2><h3 id="热更新">热更新</h3><p>Spring Cloud Config 实现了非常优雅的热更新。</p><ul><li>客户端的配置 Bean 添加 <span class="citation" data-cites="RefreshScope">@RefreshScope</span></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConsumeConfig {</span><br><span class="line"></span><br><span class="line">    @Value("${consume.desc}")</span><br><span class="line">    private String consumeDesc;</span><br><span class="line">    </span><br><span class="line">    @Value("#{'${api.server.round.card}'.split(',')}")</span><br><span class="line">    private List<String> cardList;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在配置这个注解之后，调用客户端的 /refresh endpoint，这个 Bean就会刷新，同时个 Bean 的依赖方下次方法调用时也会更新 Bean 引用。</p><p>有些时候，你需要监听这个更新事件，把拿到的最新配置，重新初始化一些部件。那你可以添加：<code>@EventListener(EnvironmentChangeEvent.class)</code> 这个annotation。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumeService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConsumeConfig consumeConfig;</span><br><span class="line"></span><br><span class="line">    @EventListener(EnvironmentChangeEvent.class)</span><br><span class="line">    void onEnvChange() {</span><br><span class="line">        //do re-init stuff</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="添加权限">添加权限</h3><p>Config Server 任何人都可以通过 http访问配置，这个不大好，建议加上认证，最简单是使用 Spring-Security添加一个 basic authentication。</p><ul><li>服务器端配置</li></ul><p>build.gradle 添加依赖： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies {</span><br><span class="line">    compile('org.springframework.boot:spring-boot-starter-security')</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>application.properties 添加密码（用户名默认是 user）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security.user.password=xxx</span><br></pre></td></tr></table></figure></p><p>重启服务器，再次通过 http 访问配置的时候需要验证。</p><ul><li>客户端配置</li></ul><p>服务器端做了验证，那客户端也需要添加相应的配置：</p><p>bootstrap.yml <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: application</span><br><span class="line"> cloud:</span><br><span class="line">  config:</span><br><span class="line">   uri: http://yourhost.com</span><br><span class="line">   profile: dev</span><br><span class="line">   username: user</span><br><span class="line">   password: xxx</span><br></pre></td></tr></table></figure></p><h3 id="加载多组配置文件">加载多组配置文件</h3><p>很多时候，为了避免 application.properties过于臃肿，你可能需要把一些配置文件拆出来，例如专门负责邀请奖励的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invite.properties</span><br><span class="line">invite-dev.properties</span><br><span class="line">invite-test.properties</span><br><span class="line">invite-prod.properties</span><br></pre></td></tr></table></figure><p>同样，也区分了多个环境。</p><p>那在使用 Spring Cloud 的时候如何读取这个文件呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: application,invite</span><br></pre></td></tr></table></figure><p>注意上面的 application.name 是以逗号分隔的两组配置名称。</p><h1 id="一些问题">一些问题</h1><h2 id="eventlistener-与-spel"><span class="citation" data-cites="EventListener">@EventListener</span> 与 SpEL</h2><p>我在实际使用中发现，在事件监听函数中，使用更新后的配置的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value("${consume.desc}")</span><br><span class="line">private String consumeDesc;</span><br><span class="line"></span><br><span class="line">@Value("#{'${api.server.round.card}'.split(',')}")</span><br><span class="line">private List<String> cardList;</span><br></pre></td></tr></table></figure><p>第一个配置是使用 <span class="citation" data-cites="Value">@Value</span> 绑定一个字符串类型，第二个配置是使用<span class="citation" data-cites="Value">@Value</span> 中的 SpEL去将配置中的字符串，切割成 List。</p><p>我发现第二个，无法切割成功。试验了多次，还没有找到答案。我已经在Spring Cloud Config 的 github 上提交了 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/821">issue</a>。</p><p>如果有了解这个的，请不吝赐教。</p><blockquote><p>update 2017-10-26 * 我在 github 上提交了 issue：https://github.com/spring-cloud/spring-cloud-config/issues/821得到回复：<code>We have only ever documented that placeholders ${} work, not SpEL.</code></p></blockquote><h2 id="权限管理">权限管理</h2><p>在不做二次开发的情况下，这个配置中心的数据是对所有的 client开放的。某些情况下，这种设定并不合适。</p><h2 id="json-文件的读取和解析">JSON 文件的读取和解析</h2><p>Spring Cloud Config 本身是可以通过 http 来提供 JSON文件的访问的，但是Spring Boot 原生并不支持 JSON 配置的读取和解析。</p><h1 id="相关选择">相关选择</h1><p>其实配置管理工具，选择还是不少的，下面列举一下。</p><ul><li>owner http://owner.aeonbits.org/</li></ul><p>配置文件管理，可以热更新，跟 Spring 没有绑定。</p><ul><li>cfg4j http://www.cfg4j.org/</li></ul><p>专注管理配置文件，也可以实现热更，跟 Spring 没有绑定。</p><ul><li>applolo https://github.com/ctripcorp/apollo</li></ul><p>携程开源的，功能很全</p><ul><li>disconf https://github.com/knightliao/disconf</li></ul><p>百度的一位工程师的开源项目，功能也很全</p><ul><li>diamond https://github.com/takeseem/diamond</li></ul><p>来自阿里的开源，有些日子了</p><h1 id="参考文献">参考文献</h1><p><a href="http://blog.didispace.com/spring-cloud-starter-dalston-3/">http://blog.didispace.com/spring-cloud-starter-dalston-3/</a></p><p><a href="http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html">http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html</a></p><p><a href="http://jm.taobao.org/2016/09/28/an-article-about-config-center/">http://jm.taobao.org/2016/09/28/an-article-about-config-center/</a></p><p><a href="https://blog.coding.net/blog/spring-cloud-config">https://blog.coding.net/blog/spring-cloud-config</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闲话配置&quot;&gt;闲话配置&lt;/h1&gt;
&lt;p&gt;老司机都喜欢在程序设计中尽可能的把各种参数做成可配置的，等到产品需求发生改动的时候，优雅的修改一行配置，重新加载一次配置，就满足了需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置（Configuration）是不修改代码的
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Spring" scheme="https://0xkevinhe.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>小工具-sips-图片批量转大小</title>
    <link href="https://0xkevinhe.xyz/utility-sips.html"/>
    <id>https://0xkevinhe.xyz/utility-sips.html</id>
    <published>2017-05-16T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="家有设计师">家有设计师</h1><p>我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。</p><p>看了她导了好几次，实在不能忍。得发挥程序员的能动性，做个小工具。</p><h1 id="调研">调研</h1><p><a href="http://www.imagemagick.org/script/index.php">imagemagick</a>是一个很好的工具，支持多个平台，功能丰富强大。考虑了一下，如果这个小工具还需要用户安装依赖的话，显然提高了使用门槛。</p><p>设计师们大多在 MacOS下工作，最好是运用这个平台下现成的工具包。搜索了一下，发现今天的主角：<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/sips.1.html">sips</a>。</p><p>sips具有很友好的使用接口，可以实现大小转换、旋转、翻转等。这里我只需要大小转换功能，主要是如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sips -Z 100 input.png --out output.png</span><br></pre></td></tr></table></figure><p>上面的例子可以将 <code>input.png</code>图片最大边调整成100像素，等比缩放。</p><h1 id="实践">实践</h1><p>整个工具包含如下几个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── convert.sh//转换程序</span><br><span class="line">├── icon.png//输入文件</span><br><span class="line">└── sizes.txt//目标尺寸</span><br></pre></td></tr></table></figure><p>使用步骤如下：</p><ol type="1"><li>替换 icon.png 文件为需要转换的文件</li><li>修改 sizes.txt 文件，编辑目标尺寸，每一行为一个尺寸</li><li>控制台运行 <code>./convert.sh</code> 即可</li></ol><p>为了很方便的让设计师同学使用这个工具，我在她的电脑上安装了一个 <a href="https://github.com/jbtule/cdto">cdto</a> 工具，可以在当前 finder目录下打开 控制台。还把这个工具拖到了 finder 的左侧快捷方式。PS:用户接口要友好。。。</p><h1 id="源码">源码</h1><p>源码和配置文件都放在 <a href="https://github.com/kevinho/image-resizer">github</a> 上。</p><h1 id="todo">TODO</h1><ol type="1"><li>目前只支持 png</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;家有设计师&quot;&gt;家有设计师&lt;/h1&gt;
&lt;p&gt;我家夫人是一位设计师，平时少不了将一张大图导出成多种规格的小图的脏活累活。&lt;/p&gt;
&lt;p&gt;看了她导了好几次，实在不能忍。得发挥程序员的能动性，做个小工具。&lt;/p&gt;
&lt;h1 id=&quot;调研&quot;&gt;调研&lt;/h1&gt;
&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="产品" scheme="https://0xkevinhe.xyz/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验" scheme="https://0xkevinhe.xyz/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊 Alexa Echo Dot——入门</title>
    <link href="https://0xkevinhe.xyz/play-alexa-1.html"/>
    <id>https://0xkevinhe.xyz/play-alexa-1.html</id>
    <published>2017-03-21T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能家居">智能家居</h1><p>大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。</p><p>亚马逊的 <a href="https://en.wikipedia.org/wiki/Amazon_Echo">AlexaEcho</a> 无疑是这个浪潮中的当红明星。</p><p>它是一个蓝牙音箱，是一个智能语音助手，是一个智能家居管理中心，它还提供了开放平台，允许第三方添加<code>Skills</code> 来扩充功能。</p><p>本篇介绍一些购买和基本使用经验。</p><h1 id="购买">购买</h1><p>在经过几代的发展之后，目前这个产品主要包含 <code>Echo</code> 和<code>Echo Dot</code>。主要的区别是扬声器的规格。</p><p>如下图： <img src="https://raw.githubusercontent.com/changbinhe/images/master/17-3-21/77023898-file_1490061698677_e03e.jpg" alt="Amazon-Echo"></p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-3-21/7885364-file_1490061698538_1047c.jpg" alt="Amazon-Echo-Dot"><figcaption aria-hidden="true">Amazon-Echo-Dot</figcaption></figure><p>Echo Dot 价格要亲民一些，500人民币左右，某宝可购买。</p><p>下单后很快到货，就是这么一个小盒子：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/17-3-21/17973801-file_1490061841802_10892.jpg" alt="Echo-Dot-实物"><figcaption aria-hidden="true">Echo-Dot-实物</figcaption></figure><h1 id="基础介绍">基础介绍</h1><p>顶部有四个按钮，功能分别是，分别是：静音、操控、音量加减。</p><p>背面有两个插槽，分别是 3.5 mm 声频输出口、Micro-USB 电源插口。</p><p>Echo Dot 需要一个叫做<code>Alexa App</code>的手机软件作为控制端，下面提供 Android 和 iOS平台的下载地址。</p><p><a href="https://play.google.com/store/apps/details?id=com.amazon.dee.app">Android-App</a></p><p><a href="https://itunes.apple.com/us/app/amazon-echo/id944011620">iOS-App</a></p><blockquote><p>注意在 iOS 平台上，这个 App只允许美国区的账户进行下载。你可以折腾一下，注册一个美国区的 AppleID，可能需要绑定信用卡。你也可以花钱买时间，在万能的某宝上买一个美国区账号。我选择了后者。</p></blockquote><h1 id="基础设置">基础设置</h1><p>Echo Dot 是需要连接到 WiFi 进行工作的，这就需要用 Alexa App进行绑定和设置。</p><p>如果你曾经用过小米的空气净化器，你会发现设置的模式类似。</p><p>主要步骤为：EchoDot 进入设定模式、手机连上 Echo Dot 共享的 WiFi、操作Echo Dot 连接家里的 WiFi。</p><p>1.长按 Echo Dot 顶部的操控键，会有提示进入设定模式(enter setupmode)；</p><p>2.在手机的 WiFi 设置页面，可以看到名字为 Amazon-XXX 的WiFi，连接上去，会有提示：(connected)；</p><p>3.进入 Alexa App，在里面选择家里的 WiFi，输入密码，确定之后，Echo Dot会尝试进行连接。</p><blockquote><p>连接中，主要发现两个问题，一是卡，二是根本连不上。因为 Alexa的服务器在国外，速度受一定的影响，卡是正常的。然而国内的网络环境比较复杂，例如我就遇到过家里的<code>方正宽带</code>下的WiFi，根本连不上的情况。后来我只能使用手机的联通4G开热点才能勉强使用。公司的电信宽带也没有问题。后面网络续费的时候，看来要换成电信或者联通了。</p></blockquote><h1 id="基础使用">基础使用</h1><p>Echo Dot 连接上网络之后，你就可以跟它对话了。默认唤醒口令是<code>Alexa</code>。唤醒之后灯会亮。</p><p>例如就可以试一下，<code>Alexa, what's the weather</code>。它可能会告诉你美国西雅图现在的天气，地址可以在Alexa App 中设置。（ps：我还没有找到设置成北京的方式）</p><h1 id="一些后续">一些后续</h1><p>Alexa Echo 提供了开放平台，开发者可以将服务打包成 <code>Skills</code>对系统进行扩展，这个就有点像苹果的 iOS生态了。厂商只提供基础的服务和功能，开发者百花齐放。用户可以在 Alexa App中添加 Skills，例如你可以添加一个读 CNN新闻的功能。这一块还有待探索。</p><p>网络问题很严重，反应速度比较慢。后面如果想要愉快玩耍，还是得找一个比较好的联网方案。某一天亚马逊可以把服务器放一些到国内，就更好了。</p><h1 id="总结">总结</h1><p>Alexa Echo Dot 入门初步介绍了购买、设置、使用。下面继续探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;智能家居&quot;&gt;智能家居&lt;/h1&gt;
&lt;p&gt;大约20年前，在报纸上看到关于比尔盖茨智能豪宅的报道，心生向往。我等平民在20年后，终于迎来了智能家居浪潮普及的浪潮。&lt;/p&gt;
&lt;p&gt;亚马逊的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Am
      
    
    </summary>
    
      <category term="product" scheme="https://0xkevinhe.xyz/categories/product/"/>
    
    
      <category term="产品" scheme="https://0xkevinhe.xyz/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验" scheme="https://0xkevinhe.xyz/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>读一首诗——纪伯伦《孩子》</title>
    <link href="https://0xkevinhe.xyz/on-children.html"/>
    <id>https://0xkevinhe.xyz/on-children.html</id>
    <published>2016-10-07T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.159Z</updated>
    
    <content type="html"><![CDATA[<p>今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（KahlilGibran）的《孩子》，很有感触。将冰心的译文和原文奉上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">孩　　子</span><br><span class="line"> </span><br><span class="line">你们的孩子，都不是你们的孩子。</span><br><span class="line">乃是生命为自己所渴望的儿女。</span><br><span class="line">他们是凭借你们而来，却不是从你们而来，</span><br><span class="line">他们虽和你们同在，却不属于你们。</span><br><span class="line"></span><br><span class="line">你们可以给他们以爱，却不可给他们以思想。</span><br><span class="line">因为他们有自己的思想。</span><br><span class="line">你们可以荫庇他们的身体，却不能荫庇他们的灵魂。</span><br><span class="line">因为他们的灵魂，是住在明日的宅中，那是你们在梦中也不能想见的。</span><br><span class="line">你们可以努力去模仿他们，却不能使他们来象你们。</span><br><span class="line">因为生命是不倒行的，也不与昨日一同停留。</span><br><span class="line">你们是弓，你们的孩子是从弦上发出的生命的箭矢。</span><br><span class="line">那射者在无穷之中看定了目标，也用神力将你们引满，使他的箭矢迅速而遥远地射了出去。</span><br><span class="line">让你们在射者手中的弯曲成为喜乐罢；</span><br><span class="line">因为他爱那飞出的箭，也爱了那静止的弓。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">On Children</span><br><span class="line"></span><br><span class="line">Your children are not your children.</span><br><span class="line">They are the sons and daughters of Life's longing for itself.</span><br><span class="line">They come through you but not from you,</span><br><span class="line">And though they are with you yet they belong not to you.</span><br><span class="line"></span><br><span class="line">You may give them your love but not your thoughts, </span><br><span class="line">For they have their own thoughts.</span><br><span class="line">You may house their bodies but not their souls,</span><br><span class="line">For their souls dwell in the house of tomorrow, </span><br><span class="line">which you cannot visit, not even in your dreams.</span><br><span class="line">You may strive to be like them, </span><br><span class="line">but seek not to make them like you.</span><br><span class="line">For life goes not backward nor tarries with yesterday.</span><br><span class="line"></span><br><span class="line">You are the bows from which your children</span><br><span class="line">as living arrows are sent forth.</span><br><span class="line">The archer sees the mark upon the path of the infinite, </span><br><span class="line">and He bends you with His might </span><br><span class="line">that His arrows may go swift and far.</span><br><span class="line">Let your bending in the archer's hand be for gladness;</span><br><span class="line">For even as He loves the arrow that flies, </span><br><span class="line">so He loves also the bow that is stable.</span><br></pre></td></tr></table></figure><p>这首诗，来自纪伯伦的名作《先知》。</p><p>相信每一个人，在不同的阶段，读到这首诗的感受，是不一样的。</p><p>年少的时候，觉得父母老师管束自己，想要自由，可能会以此诗句来抗争——看，纪伯伦说了……。</p><p>长大了，离开父母上学，父母还是希望给更多的意见，你却总觉得父母的意见不合时宜。</p><p>工作了，经济自由了，在享受自由的那一瞬间，却开始想父母了。你慢慢的发现，自己身上的思想与习惯，很多都是源自来自父母。</p><p>若干年后，父母在你该找谁结婚这事儿上，干预未果，你想，抗争终于成功了。</p><p>不久，你也终于为人父母，才感叹，当父母真不容易。既当弓，又为箭。</p><p>再过若干年，自己的孩子也到了叛逆期，你还是希望像当年自己的父母一样，把自己曾经犯过的错，提前告诉孩子。</p><p>你却发现，每个人该犯的错误，该趟的坑，一个都少不了。你，却只能在旁边看着，就像当年你的父母一样。</p><p>孩子终于活出了自己的世界，你发现，原来每一个人都有自己的命运，只要努力，还是有机会。</p><p>每个人的每个阶段，都有自己的局限和使命。努力，活在当下就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在最喜欢的陈老师的《待字闺中》那里读到一首诗，纪伯伦（Kahlil
Gibran）的《孩子》，很有感触。将冰心的译文和原文奉上。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SDK 开发最佳实践之一：为你的 SDK 增加 No-Op 版本</title>
    <link href="https://0xkevinhe.xyz/sdk-noop.html"/>
    <id>https://0xkevinhe.xyz/sdk-noop.html</id>
    <published>2016-09-29T03:20:30.000Z</published>
    <updated>2023-09-27T07:01:22.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔者在开发和维护 Bugtags SDK的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags这样快速成长的 SDK。</p></blockquote><h1 id="sdk-的使用场景">SDK 的使用场景</h1><p>站在用户的角度来看，引入一个 SDK 可能会带来几方面的问题： - 包增大 -可能不稳定 - 安全性问题</p><p>对于一些SDK，产品形态是允许在测试阶段开启，上线移除的，例如性能调试工具，测试工具等。</p><h1 id="区分版本方案">区分版本方案</h1><p>最简单的，就是手动注释代码，应用中如果只使用了这个 SDK 的一个API，那还好，如果用到了多个，分布在不同的文件中，这事儿就麻烦了。很不优雅。</p><h1 id="最优雅的方案">最优雅的方案</h1><p>思考一下这个需求</p><ul><li>应用分为 debug/release 版本</li><li>无痛切换，最好能够实现自动化</li></ul><p>大部分的编译系统，例如 Gradle/Maven都可以区分版本，引入不同的包。利用这个特性，我们可以实现一个 No-OpSDK。</p><p>这个 SDK 具有如下特点：</p><ul><li>具有正式 SDK 的所有可以被外部引用的类</li><li>具有正式 SDK 的所有对外 API</li><li>足够的精简</li><li>提示正在使用 No-Op SDK</li></ul><h1 id="最后的结果">最后的结果</h1><p>以 bugtags 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile 'com.bugtags.library:bugtags-lib:2.0.0'</span><br><span class="line">releaseCompile 'com.bugtags.library:bugtags-noop:2.0.0'</span><br></pre></td></tr></table></figure><p>以 leakcanary 为例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5'</span><br><span class="line">releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'</span><br></pre></td></tr></table></figure></p><h1 id="扩展">扩展</h1><p>如果你是一个 SDK 的使用者，即便官方没有提供 No-Op版本，你完全可以自己写一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;笔者在开发和维护 Bugtags SDK
的一年多时间里面，趟过了不少坑，走了不少弯路，也积累了不少经验。这个 SDK
开发最佳实践系列，就是分享经验教训，帮助读者打造一款跟 Bugtags
这样快速成长的 SDK。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="SDK" scheme="https://0xkevinhe.xyz/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 构建系统·初探</title>
    <link href="https://0xkevinhe.xyz/gradle-build-system-overview.html"/>
    <id>https://0xkevinhe.xyz/gradle-build-system-overview.html</id>
    <published>2016-08-13T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.156Z</updated>
    
    <content type="html"><![CDATA[<p>8月7号，应<a href="http://www.chinagdg.com/thread-3462-1-1.html">北京GDG</a> 邀请，我做了一个题为《Android Gradle 构建系统·初探》的分享。</p><p>主要内容是构建系统背景知识，源码库，代码亮点，写插件。</p><p>很明显这是一个很大的话题，有超过 2.5GB的核心代码和超过50个子项目。</p><p>第一步，我进行了宏观的介绍。下一步，我会继续深入子项目，尝试发现更多有意思的点。</p><p>对这个话题感兴趣的，请加入技术交流 qq 群：583688711。</p><p>Slides 在下面，分别是 PDF 版本和图片版本。</p><p><a href="https://raw.githubusercontent.com/changbinhe/images/master/static/Android%20Gradle%20Build%20System-Overview-wide-screen.pdf">PDFhere</a>.</p><p>图片：</p><p><img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.001.jpeg" alt="Android-Gradle-Build-System-Overview.001.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.002.jpeg" alt="Android-Gradle-Build-System-Overview.002.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.003.jpeg" alt="Android-Gradle-Build-System-Overview.003.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.004.jpeg" alt="Android-Gradle-Build-System-Overview.004.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.005.jpeg" alt="Android-Gradle-Build-System-Overview.005.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.006.jpeg" alt="Android-Gradle-Build-System-Overview.006.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.007.jpeg" alt="Android-Gradle-Build-System-Overview.007.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.008.jpeg" alt="Android-Gradle-Build-System-Overview.008.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.009.jpeg" alt="Android-Gradle-Build-System-Overview.009.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.010.jpeg" alt="Android-Gradle-Build-System-Overview.010.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.011.jpeg" alt="Android-Gradle-Build-System-Overview.011.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.012.jpeg" alt="Android-Gradle-Build-System-Overview.012.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.013.jpeg" alt="Android-Gradle-Build-System-Overview.013.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.014.jpeg" alt="Android-Gradle-Build-System-Overview.014.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.015.jpeg" alt="Android-Gradle-Build-System-Overview.015.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.016.jpeg" alt="Android-Gradle-Build-System-Overview.016.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.017.jpeg" alt="Android-Gradle-Build-System-Overview.017.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.018.jpeg" alt="Android-Gradle-Build-System-Overview.018.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.019.jpeg" alt="Android-Gradle-Build-System-Overview.019.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.020.jpeg" alt="Android-Gradle-Build-System-Overview.020.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.021.jpeg" alt="Android-Gradle-Build-System-Overview.021.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.022.jpeg" alt="Android-Gradle-Build-System-Overview.022.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.023.jpeg" alt="Android-Gradle-Build-System-Overview.023.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.024.jpeg" alt="Android-Gradle-Build-System-Overview.024.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.025.jpeg" alt="Android-Gradle-Build-System-Overview.025.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.026.jpeg" alt="Android-Gradle-Build-System-Overview.026.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.027.jpeg" alt="Android-Gradle-Build-System-Overview.027.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.028.jpeg" alt="Android-Gradle-Build-System-Overview.028.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.029.jpeg" alt="Android-Gradle-Build-System-Overview.029.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.030.jpeg" alt="Android-Gradle-Build-System-Overview.030.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.031.jpeg" alt="Android-Gradle-Build-System-Overview.031.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.032.jpeg" alt="Android-Gradle-Build-System-Overview.032.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.033.jpeg" alt="Android-Gradle-Build-System-Overview.033.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.034.jpeg" alt="Android-Gradle-Build-System-Overview.034.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.035.jpeg" alt="Android-Gradle-Build-System-Overview.035.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.036.jpeg" alt="Android-Gradle-Build-System-Overview.036.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.037.jpeg" alt="Android-Gradle-Build-System-Overview.037.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.038.jpeg" alt="Android-Gradle-Build-System-Overview.038.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.039.jpeg" alt="Android-Gradle-Build-System-Overview.039.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.040.jpeg" alt="Android-Gradle-Build-System-Overview.040.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.041.jpeg" alt="Android-Gradle-Build-System-Overview.041.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.042.jpeg" alt="Android-Gradle-Build-System-Overview.042.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.043.jpeg" alt="Android-Gradle-Build-System-Overview.043.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.044.jpeg" alt="Android-Gradle-Build-System-Overview.044.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.045.jpeg" alt="Android-Gradle-Build-System-Overview.045.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.046.jpeg" alt="Android-Gradle-Build-System-Overview.046.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.047.jpeg" alt="Android-Gradle-Build-System-Overview.047.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.048.jpeg" alt="Android-Gradle-Build-System-Overview.048.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.049.jpeg" alt="Android-Gradle-Build-System-Overview.049.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.050.jpeg" alt="Android-Gradle-Build-System-Overview.050.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.051.jpeg" alt="Android-Gradle-Build-System-Overview.051.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.052.jpeg" alt="Android-Gradle-Build-System-Overview.052.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.053.jpeg" alt="Android-Gradle-Build-System-Overview.053.jpeg"> <img src="https://raw.githubusercontent.com/changbinhe/images/master/2016/08/13/Android-Gradle-Build-System-Overview.054.jpeg" alt="Android-Gradle-Build-System-Overview.054.jpeg"></p><blockquote><p>有问题？在文章下留言或者加 qq 群：583688711，希望能帮到你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;8月7号，应&lt;a href=&quot;http://www.chinagdg.com/thread-3462-1-1.html&quot;&gt;北京
GDG&lt;/a&gt; 邀请，我做了一个题为《Android Gradle 构建系统·初探》的分享。&lt;/p&gt;
&lt;p&gt;主要内容是构建系统背景知识，源码库，代
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="Gradle" scheme="https://0xkevinhe.xyz/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 技巧之二： 最爱命令行</title>
    <link href="https://0xkevinhe.xyz/gradle-indepth-cmd.html"/>
    <id>https://0xkevinhe.xyz/gradle-indepth-cmd.html</id>
    <published>2016-06-04T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.158Z</updated>
    
    <content type="html"><![CDATA[<p>如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。</p><h1 id="命令行">命令行</h1><p>很多做 Android开发不久的同学，习惯于使用图形界面，对命令行操作很陌生甚至恐惧。遇到 AS运行错误，束手无策。</p><p>AS 为了确保易用性，也在 UI界面上屏蔽了很多命令行运行的细节，导致很多人觉得 AS 难用。</p><p>这种情况，我在解决用户集成使用 Bugtags SDK的问题的时候，经常能遇到。其实 GUI界面的操作，绝大部分情况下，也是基于命令工具的。如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。# 典型错误 AS 刚推出的时候，stackoverflow上询问最多的问题，便是进入项目的时候，一直处于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gradle: resolve dependancies '_debugCompile'</span><br></pre></td></tr></table></figure><p>状态，一直无法前进，到底 IDE 在做什么呢？看不出来。</p><h1 id="一句命令行">一句命令行</h1><p>当用户遇到问题时，我最常提醒用户使用的是在项目根目录下，运行如下命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac:</span><br><span class="line">./gradlew clean build --info > bugtags.log</span><br><span class="line"></span><br><span class="line">windows:</span><br><span class="line">gradlew.bat clean build --info > bugtags.log</span><br></pre></td></tr></table></figure><p>这个命令行的意思，是运行 clean 和 build 两个 gradle task，并且打开info 参数使得输出更多的信息，最终把所有输出的信息，输出到项目根目录下的bugtags.log文件。用户把这个文件发给我，我根据这个输出文件，通常就能分析出问题所在。</p><p>假设命令行去除重定向输指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean build --info</span><br></pre></td></tr></table></figure><p>信息将会输出在控制台，刚才提到的那个典型错误，可能是这样的：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-5/15681897.jpg" alt="cmd-output"><figcaption aria-hidden="true">cmd-output</figcaption></figure><p>其实是在下载一个比较大的文件，不用惊慌，你要做的就是 just wait!至于是在下载什么。我想在下一篇详细描述。</p><p>如果你对基本的命令行知识有所了解，前面就已经足够了，如果你想了解更多，请继续。</p><h1 id="扩展">扩展</h1><h2 id="在哪运行">在哪运行</h2><p>当我给出这个命令的时候，最常见的问题，就是在哪运行。答案是控制台（Terminal）。</p><h3 id="控制台">控制台</h3><p>在 mac 下，有 terminal（bash/zsh 等），在 windows 下，则是 powershell或者 cmd。</p><p>关键一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>AS 在使用 Gradle 的时候，为了灵活，或者为了应对 Gradle系统的快速迭代，推荐使用在项目根目录中放置 Gradle 的 wrapper：gradlew来实现对不同版本的使用。</p></blockquote><p>因此，在控制台运行命令，主要是跟 <code>gradlew</code> 打交道。这个wrapper，在 mac 下是一个具有执行权限的文件：<code>gradlew</code>，在windows 下，是一个批处理文件：<code>gradlew.bat</code>。</p><p>通常，mac 下在当前目录下运行可执行文件是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew xxx</span><br></pre></td></tr></table></figure><p>windows 下在当前目录下运行批处理文件是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew.bat xxx</span><br></pre></td></tr></table></figure><h3 id="terminal-插件">Terminal 插件</h3><p>AS（Intellij IDEA）已经做了一个很实用的插件：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-5/3873932.jpg" alt="as-terminal"><figcaption aria-hidden="true">as-terminal</figcaption></figure><p>点击 Terminal，AS 会帮你完成下面的操作：</p><ul><li>模拟打开 terminal</li><li>cd 到当前项目根目录下</li></ul><h3 id="快速定位文件夹">快速定位文件夹</h3><p>IDE 还支持将项目中的某个文件夹拖放到 Terminal窗口中实现快速定位到这个文件夹：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-5/94595004.jpg" alt="terminal-drag-location"><figcaption aria-hidden="true">terminal-drag-location</figcaption></figure><h2 id="使用-help">使用 help</h2><p>要知道都有哪些 gradle 命令运行的参数，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew --help</span><br><span class="line"></span><br><span class="line">USAGE: gradlew [option...] [task...]</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来获取。下面列举几个重要的参数。</p><h2 id="build-某个指定-module">build 某个指定 module</h2><p>AS 推荐的结构是 <code>multiple project</code> 结构，即一个 project下，管理多个 module，如果每次都要 build 全部的 project的话，有点浪费时间，则可以使用 <code>-p module</code> 参数，其中 module是你要 build 的 module：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app clean build</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="明确指定不执行某个-task">明确指定不执行某个 task</h2><p>Gradle 的命令存在依赖，例如 build task，是依赖于一系列的其他的task，如果想要指定不执行某个 task，则可以使用 <code>-x task</code>参数，其中 task 是要忽略的那个，这个参数可以传递多次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew build -x test -x lint</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>Gradle的命令行还有很多其他技巧，上面只是列举到了本人日常用到最多的几个。有兴趣可以留言深入讨论。</p><h1 id="参考资料">参考资料</h1><p><a href="http://blog.csdn.net/stpeace/article/details/9021641">mac-terminal</a></p><p><a href="http://blog.csdn.net/stpeace/article/details/9021641">windows-terminal</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你习惯了命令行，你会爱上它的，因为它简单、直接，深入。&lt;/p&gt;
&lt;h1 id=&quot;命令行&quot;&gt;命令行&lt;/h1&gt;
&lt;p&gt;很多做 Android
开发不久的同学，习惯于使用图形界面，对命令行操作很陌生甚至恐惧。遇到 AS
运行错误，束手无策。&lt;/p&gt;
&lt;p&gt;AS 为了确保易用性
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="Gradle 技巧" scheme="https://0xkevinhe.xyz/tags/Gradle-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 技巧之一： Build Variant 相关</title>
    <link href="https://0xkevinhe.xyz/gradle-indepth-build-variant.html"/>
    <id>https://0xkevinhe.xyz/gradle-indepth-build-variant.html</id>
    <published>2016-06-03T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="build-variant">Build Variant</h1><p>android gradle 插件，允许对最终的包以多个维度进行组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuildVariant = ProductFlavor x BuildType</span><br></pre></td></tr></table></figure><h2 id="两个维度">两个维度</h2><p>最常见的就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">productFlavors {</span><br><span class="line">    pro {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fre {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">lintOptions {</span><br><span class="line">    abortOnError false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buildTypes {</span><br><span class="line">    debug {</span><br><span class="line">    }</span><br><span class="line">    release {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>其中，buildTypes 一般都会有 debug或者release，标示编译的类型，通常在混淆代码、可调式、资源压缩上做一些区分。productFlavor则为了满足“同一个project，根据一个很小的区分，来打不同的包”这个需求。</p><p>这两个维度的组合，会产生如下包：</p><ul><li>proDebug</li><li>proRelease</li><li>freDebug</li><li>proRelease</li></ul><h2 id="更多的维度">更多的维度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions 'abi', 'version'</span><br><span class="line"></span><br><span class="line">productFlavors {</span><br><span class="line">    pro {</span><br><span class="line">        dimension 'version'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fre {</span><br><span class="line">        dimension 'version'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    arm {</span><br><span class="line">        dimension 'abi'</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mips {</span><br><span class="line">        dimension 'abi'</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buildTypes {</span><br><span class="line">    debug {</span><br><span class="line">    }</span><br><span class="line">    release {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>productFlavor 本身定义了2个维度，记上buildType，则有三个维度，会产生如下的包：</p><ul><li>armProDebug</li><li>armProRelease</li><li>armFreDebug</li><li>armFreRelease</li><li>mipsProDebug</li><li>mipsProRelease</li><li>mipsFreDebug</li><li>mipsFreRelease</li></ul><p>其中每个维度组合，都可以设置本身的 dependency、testsource。下面做一个举例。</p><h1 id="flavor-与-dependency">Flavor 与 Dependency</h1><h2 id="需求">需求</h2><p>module 中有若干个 flavors，例如：fre 和pro，分别依赖不同的库，这些库有的是本地 jar 库，有的是远程库。</p><h2 id="方案">方案</h2><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-6-3/75851013.jpg?imageView2/2/w/640/h/640" alt="flavor-dependency"><figcaption aria-hidden="true">flavor-dependency</figcaption></figure><h1 id="遍历-build-variant">遍历 Build Variant</h1><h2 id="需求-1">需求</h2><p>Bugtags 的 android sdk，有一个自动上传符号表功能，在最初，是这样配置的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.bugtags.library.plugin'</span><br><span class="line">bugtags {</span><br><span class="line">    appKey "APP_KEY"</span><br><span class="line">    appSecret  "APP_SECRET"</span><br><span class="line">    mappingUploadEnabled false</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>后来，我们增加了一个 beta-live 的机制，用来区分测试和上线的APP，这样，同一个 APP，就有两套 APP_KEY 和 APP_SECRET了，很明显上方的配置方式就不在适用。</p><h2 id="方案-1">方案</h2><p>android gradle 插件提供了 android.applicationVariants索引来遍历所有的 build variant 后来，我们采取了一个方案，遍历 BuildVariant，设置 extension 信息来兼容这种需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate {</span><br><span class="line">    android.applicationVariants.each { variant -></span><br><span class="line">        def bugtagsAppKey = null;</span><br><span class="line">        def bugtagsAppSecret = null;</span><br><span class="line"></span><br><span class="line">        if (variant.name.contains("debug")) {</span><br><span class="line">            bugtagsAppKey = 'APP_KEY_BETA'</span><br><span class="line">            bugtagsAppSecret = 'APP_SECRET_BETA'</span><br><span class="line">        } else if (variant.name.contains("release")) {</span><br><span class="line">            bugtagsAppKey = 'APP_KEY_LIVE'</span><br><span class="line">            bugtagsAppSecret = 'APP_SECRET_LIVE'</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        variant.ext.bugtagsAppKey = bugtagsAppKey</span><br><span class="line">        variant.ext.bugtagsAppSecret = bugtagsAppSecret</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: 'com.bugtags.library.plugin'</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>本文主要是介绍了 build variant的概念，还介绍了两个日常应用案例。希望对大家有帮助。</p><h1 id="参考资料">参考资料</h1><p><a href="http://tools.android.com/tech-docs/new-build-system">android-build-tool</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;build-variant&quot;&gt;Build Variant&lt;/h1&gt;
&lt;p&gt;android gradle 插件，允许对最终的包以多个维度进行组合。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="Gradle 技巧" scheme="https://0xkevinhe.xyz/tags/Gradle-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>拥抱 Android Studio 之五：Gradle 插件开发</title>
    <link href="https://0xkevinhe.xyz/embrace-android-studio-gradle-plugin.html"/>
    <id>https://0xkevinhe.xyz/embrace-android-studio-gradle-plugin.html</id>
    <published>2016-03-28T03:20:30.000Z</published>
    <updated>2023-09-27T07:01:22.150Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html">官方文档</a>给出了比较详细的实现步骤，本文的脉络会跟官方文档差不了太多，额外增补实际例子和一些实践经验。文中的代码已经托管到了<a href="https://github.com/kevinho/Embrace-Android-Studio-Demo">github项目</a>中。</p><h1 id="需求">需求</h1><p>默认的 Android 打包插件会把 apk 命名成<code>module-productFlavor-buildType.apk</code>，例如<code>app-official-debug.apk</code>，并且会把包文件发布到固定的位置：<code>module/build/outputs/apk</code>有的时候，这个命名风格并不是你所要的，你也想讲 apk输出到别的目录。咱们通过 gradle 插件来实现自定义。这个插件的需求是：</p><ul><li>输入一个名为 nameMap 的 Closure，用来修改 apk 名字</li><li>输入一个名为 destDir 的 String，用于输出位置</li></ul><h1 id="原理简述">原理简述</h1><h2 id="插件之于-gradle">插件之于 Gradle</h2><p>根据官方文档定义，插件打包了可重用的构建逻辑，可以适用于不同的项目和构建过程。</p><p>Gradle 提供了很多官方插件，用于支持 Java、Groovy等工程的构建和打包。同时也提供了自定义插件的机制，让每个人都可以通过插件来实现特定的构建逻辑，并可以把这些逻辑打包起来，分享给其他人。</p><p>插件的源码可以使用 Groovy、Scala、Java 三种语言，笔者不会Scala，所以平时只是使用 Groovy 和 Java。前者用于实现与 Gradle构建生命周期（如 task 的依赖）有关的逻辑，后者用于核心逻辑，表现为Groovy 调用 Java 的代码。</p><p>另外，还有很多项目使用 Eclipse 或者 Maven 进行开发构建，用 Java实现核心业务代码，将有利于实现快速迁移。</p><h2 id="插件打包方式">插件打包方式</h2><p>Gradle 的插件有三种打包方式，主要是按照复杂程度和可见性来划分： ###Build script 把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该build.gradle 文件中可见，笔者常用来做原型调试，本文将简要介绍此类。 ###buildSrc 项目 将插件源代码放在<code>rootProjectDir/buildSrc/src/main/groovy</code>中，只对该项目中可见，适用于逻辑较为复杂，但又不需要外部可见的插件，本文不介绍，有兴趣可以参考<a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html#sec:build_sources">此处</a>。### 独立项目 一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar文件包，一个 Jar文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。</p><h1 id="build-script-插件">Build script 插件</h1><p>首先来直接在 build.gradle 中写一个 plugin：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistPlugin implements Plugin<Project> {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line">        project.task('apkdist') << {</span><br><span class="line">            println 'hello, world!'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: ApkDistPlugin</span><br></pre></td></tr></table></figure><p>命令行运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app/ apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure><p>这个插件创建了一个名为 <code>apkdist</code> 的 task，并在 task中打印。</p><p>插件是一个类，继承自 <code>org.gradle.api.Plugin</code> 接口，重写<code>void apply(Project project)</code>方法，这个方法将会传入使用这个插件的 project 的实例，这是一个重要的context。</p><h2 id="接受外部参数">接受外部参数</h2><p>通常情况下，插件使用方需要传入一些配置参数，如 bugtags 的 SDK的插件需要接受两个参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bugtags {</span><br><span class="line">    appKey "APP_KEY"  //这里是你的 appKey</span><br><span class="line">    appSecret "APP_SECRET"    //这里是你的 appSecret，管理员在设置页可以查看</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>同样，ApkDistPlugin 这个 plugin 也希望接受两个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apkdistconf {</span><br><span class="line">    nameMap { name -></span><br><span class="line">        println 'hello,' + name</span><br><span class="line">        return name</span><br><span class="line">    }</span><br><span class="line">    destDir 'your-distribution-dir'</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>参数的内容后面继续完善。那这两个参数怎么传到插件内呢？</p><p><code>org.gradle.api.Project</code> 有一个<code>ExtensionContainer getExtensions()</code>方法，可以用来实现这个传递。</p><h3 id="声明参数类">声明参数类</h3><p>声明一个 Groovy 类，有两个默认值为 null 的成员变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistExtension {</span><br><span class="line">    Closure nameMap = null;</span><br><span class="line">    String destDir = null;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="接受参数">接受参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.extensions.create('apkdistconf', ApkDistExtension);</span><br></pre></td></tr></table></figure><p>要注意，<code>create</code> 方法的第一个参数就是你在 build.gradle文件中的进行参数配置的 dsl的名字，必须一致；第二个参数，就是参数类的名字。</p><h3 id="获取和使用参数">获取和使用参数</h3><p>在 create 了 extension 之后，如果传入了参数，则会携带在 project实例中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def closure = project['apkdistconf'].nameMap;</span><br><span class="line">closure('wow!');</span><br><span class="line"></span><br><span class="line">println project['apkdistconf'].destDir</span><br></pre></td></tr></table></figure><h3 id="进化版本一参数">进化版本一：参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistExtension {</span><br><span class="line">    Closure nameMap = null;</span><br><span class="line">    String destDir = null;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ApkDistPlugin implements Plugin<Project> {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line"></span><br><span class="line">        project.extensions.create('apkdistconf', ApkDistExtension);</span><br><span class="line"></span><br><span class="line">        project.task('apkdist') << {</span><br><span class="line">            println 'hello, world!'</span><br><span class="line"></span><br><span class="line">            def closure = project['apkdistconf'].nameMap;</span><br><span class="line">            closure('wow!');</span><br><span class="line"></span><br><span class="line">            println project['apkdistconf'].destDir</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply plugin: ApkDistPlugin</span><br><span class="line"></span><br><span class="line">apkdistconf {</span><br><span class="line">    nameMap { name -></span><br><span class="line">        println 'hello, ' + name</span><br><span class="line">        return name</span><br><span class="line">    }</span><br><span class="line">    destDir 'your-distribution-directory'</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app/ apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br><span class="line">hello, wow!</span><br><span class="line">your-distribution-directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="独立项目插件">独立项目插件</h1><p>代码写到现在，已经不适合再放在一个 build.gradle文件里面了，那也不是我们的目的。建立一个独立项目，把代码搬到对应的地方。</p><p>理论上，IntelliJ IDEA 开发插件要比 Android Studio要方便一点点，因为有对应 Groovy module 的模板。但其实如果我们了解 IDEA的项目文件结构，就不会受到这个局限，无非就是一个 build.gradle 构建文件加src 源码文件夹。</p><p>最终项目的文件夹结构是这样：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-3-4/6224454.jpg" alt="Java-Library"><figcaption aria-hidden="true">Java-Library</figcaption></figure><p>下面我们来一步步讲解。 ## 创建项目 在 Android Studio 中新建<code>Java Library</code> module <code>“plugin”</code>。</p><h2 id="修改-build.gradle-文件">修改 build.gradle 文件</h2><p>添加 Groovy 插件和对应的两个依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//removed java plugin </span><br><span class="line">apply plugin: 'groovy'</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line">    compile gradleApi()//gradle sdk</span><br><span class="line">    compile localGroovy()//groovy sdk</span><br><span class="line">    compile fileTree(dir: 'libs', include: ['*.jar'])</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="修改项目文件夹">修改项目文件夹</h2><p>src/main 项目文件下：</p><ul><li>移除 java 文件夹，因为在这个项目中用不到 java 代码</li><li>添加 groovy 文件夹，主要的代码文件放在这里</li><li>添加 resources 文件夹，存放用于标识 gradle 插件的 meta-data</li></ul><h2 id="建立对应文件">建立对应文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── libs</span><br><span class="line">├── plugin.iml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── groovy</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── asgradle</span><br><span class="line">        │           └── plugin</span><br><span class="line">        │               ├── ApkDistExtension.groovy</span><br><span class="line">        │               └── ApkDistPlugin.groovy</span><br><span class="line">        └── resources</span><br><span class="line">            └── META-INF</span><br><span class="line">                └── gradle-plugins</span><br><span class="line">                    └── com.asgradle.apkdist.properties</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>groovy 文件夹中的类，一定要修改成 <code>.groovy</code> 后缀，IDE才会正常识别。</li><li>resources/META-INF/gradle-plugins这个文件夹结构是强制要求的，否则不能识别成插件。</li></ul><h2 id="com.asgradle.apkdist.properties-文件">com.asgradle.apkdist.properties文件</h2><p>如果写过 Java 的同学会知道，这是一个 Java 的 properties 文件，是<code>key=value</code> 的格式。这个文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.asgradle.plugin.ApkDistPlugin</span><br></pre></td></tr></table></figure><p>按其语义推断，是指定这个插件的入口类。</p><ul><li><p>英文敏感的同学可能会问了，为什么这个文件的承载文件夹是叫做<code>gradle-plugins</code>，使用复数？没错，这里可以指定多个 properties文件，定义多个插件，扩展性一流，可以参考 <a href="https://github.com/linkedin/gradle-plugins/tree/master/buildSrc/src/main/resources/META-INF/gradle-plugins">linkedin</a>的插件的组织方式。</p></li><li><p>使用这个插件的时候，将会是这样：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:'com.asgradle.apkdist'</span><br></pre></td></tr></table></figure> 因此，<code>com.asgradle.apkdist</code>这个字符串在这里，又称为这个插件的id，不允许跟别的插件重复，取你拥有的域名的反向就不会错。</p></li></ul><h2 id="将-plugin-module-传到本地-maven-仓库">将 plugin module 传到本地maven 仓库</h2><p>参考上一篇：<a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱Android Studio 之四：Maven 仓库使用与私有仓库搭建</a>，和对应的 <a href="https://github.com/kevinho/Embrace-Android-Studio-Demo/tree/master/S4-MavenDeploy">demo项目</a>，将包传到本地仓库中进行测试。</p><h3 id="添加-gradle.properties">添加 gradle.properties</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PROJ_NAME=gradleplugin</span><br><span class="line">PROJ_ARTIFACTID=gradleplugin</span><br><span class="line">PROJ_POM_NAME=Local Repository</span><br><span class="line"></span><br><span class="line">LOCAL_REPO_URL=file:///Users/changbinhe/Documents/Android/repo/</span><br><span class="line"></span><br><span class="line">PROJ_GROUP=com.as-gradle.demo</span><br><span class="line"></span><br><span class="line">PROJ_VERSION=1.0.0</span><br><span class="line">PROJ_VERSION_CODE=1</span><br><span class="line"></span><br><span class="line">PROJ_WEBSITEURL=http://kvh.io</span><br><span class="line">PROJ_ISSUETRACKERURL=https://github.com/kevinho/Embrace-Android-Studio-Demo/issues</span><br><span class="line">PROJ_VCSURL=https://github.com/kevinho/Embrace-Android-Studio-Demo.git</span><br><span class="line">PROJ_DESCRIPTION=demo apps for embracing android studio</span><br><span class="line"></span><br><span class="line">PROJ_LICENCE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">PROJ_LICENCE_DEST=repo</span><br><span class="line"></span><br><span class="line">DEVELOPER_ID=your-dev-id</span><br><span class="line">DEVELOPER_NAME=your-dev-name</span><br><span class="line">DEVELOPER_EMAIL=your-email@your-mailbox.com</span><br></pre></td></tr></table></figure><h3 id="在-build.gradle-添加上传功能">在 build.gradle 添加上传功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'maven'</span><br><span class="line"></span><br><span class="line">uploadArchives {</span><br><span class="line">    repositories.mavenDeployer {</span><br><span class="line">        repository(url: LOCAL_REPO_URL)</span><br><span class="line">        pom.groupId = PROJ_GROUP</span><br><span class="line">        pom.artifactId = PROJ_ARTIFACTID</span><br><span class="line">        pom.version = PROJ_VERSION</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传可以通过运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p plugin/ clean build uploadArchives</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在-app-module-中使用插件">在 app module 中使用插件</h2><h3 id="在项目的-buildscript-添加插件作为-classpath">在项目的buildscript 添加插件作为 classpath</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript {</span><br><span class="line">    repositories {</span><br><span class="line">        maven{</span><br><span class="line">            url 'file:///Users/your-user-name/Documents/Android/repo/'</span><br><span class="line">        }</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">    dependencies {</span><br><span class="line">        classpath 'com.android.tools.build:gradle:2.1.0-alpha3'        </span><br><span class="line">        classpath 'com.as-gradle.demo:gradleplugin:1.0.0'</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="在-app-module-中使用插件-1">在 app module 中使用插件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.asgradle.apkdist'</span><br></pre></td></tr></table></figure><p>命令行运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew -p app apkdist</span><br><span class="line">:app:apkdist</span><br><span class="line">hello, world!</span><br><span class="line">hello, wow!</span><br><span class="line">your-distribution-directory</span><br></pre></td></tr></table></figure><h3 id="可能会遇到问题">可能会遇到问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:(46, 0) Cause: com/asgradle/plugin/ApkDistPlugin : Unsupported major.minor version 52.0</span><br><span class="line"><a href="openFile:/Users/your-user-name/Documents/git/opensource/embrace-android-studio-demo/s5-GradlePlugin/app/build.gradle">Open File</a></span><br></pre></td></tr></table></figure><p>应该是本机的 JDK 版本是1.8，默认将 plugin module 的 groovy源码编译成了1.8版本的 class 文件，放在 Android 项目中，无法兼容。需要对plugin module 的 build.gradle 文件添加两个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceCompatibility = 1.6</span><br><span class="line">targetCompatibility = 1.6</span><br></pre></td></tr></table></figure><h1 id="真正的实现插件需求">真正的实现插件需求</h1><p>读者可能会观察到，到目前为止，插件只是跑通了流程，并没有实现本文提出的两个需求，</p><p>那接下来就具体实现一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ApkDistPlugin implements Plugin<Project> {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) {</span><br><span class="line"></span><br><span class="line">        project.extensions.create('apkdistconf', ApkDistExtension);</span><br><span class="line"></span><br><span class="line">        project.afterEvaluate {</span><br><span class="line"></span><br><span class="line">//只可以在 android application 或者 android lib 项目中使用</span><br><span class="line">            if (!project.android) {</span><br><span class="line">                throw new IllegalStateException('Must apply \'com.android.application\' or \'com.android.library\' first!')</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">//配置不能为空</span><br><span class="line">            if (project.apkdistconf.nameMap == null || project.apkdistconf.destDir == null) {</span><br><span class="line">                project.logger.info('Apkdist conf should be set!')</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Closure nameMap = project['apkdistconf'].nameMap</span><br><span class="line">            String destDir = project['apkdistconf'].destDir</span><br><span class="line"></span><br><span class="line">//枚举每一个 build variant</span><br><span class="line">            project.android.applicationVariants.all { variant -></span><br><span class="line">                variant.outputs.each { output -></span><br><span class="line">                    File file = output.outputFile</span><br><span class="line">                    output.outputFile = new File(destDir, nameMap(file.getName()))</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>必须指出，本文插件实现的需求，其实可以直接在 app module 的build.gradle 中写脚本就可以实现。这里做成插件，只是为了做示范。</p><p>上传到 bintray 的过程，就不再赘述了，可以参考<a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱Android Studio 之四：Maven 仓库使用与私有仓库搭建</a>。</p><h1 id="后记">后记</h1><p>至此，这系列开篇的时候挖下的坑，终于填完了。很多人借助这系列的讲解，真正理解了Android Studio 和它背后的Gradle、Groovy，笔者十分高兴。笔者也得到了很多读者的鼓励和支持，心中十分感激。</p><p>写博客真的是一个很讲究执行力和耐力的事情，但既然挖下了坑，就得填上，对吧？</p><p>这半年来，个人在 Android 和 Java平台上也做了更多的事情，也有了更多的体会。</p><p>AS 系列，打算扩充几个主题：</p><ul><li>Proguard 混淆</li><li>Java & Android Testing</li><li>Maven 私有仓库深入</li><li>持续集成</li><li>……待发掘</li></ul><p>记得有人说，只懂 Android 不懂Java，是很可怕的。在这半年以来，笔者在工作中使用 Java实现了一些后端服务，也认真学习了 JVM字节码相关的知识并把它使用到了工作中。在这个过程中，真的很为 Java平台的活力、丰富的库资源、几乎无止境的可能性所折服。接下来，会写一些跟有关的学习体会，例如：</p><ul><li>Java 多线程与锁</li><li>JVM 部分原理</li><li>字节码操作</li><li>Java 8部分特性</li><li>……待学习</li></ul><p>随着笔者工作的进展，我也有机会学习使用了别的语言，例如Node.js，并实现了一些后端服务。这个语言的活力很强，一些比 Java现代的地方，很吸引人。有精力会写一写。</p><p>因为业务所需，笔者所经历的系统，正在处于像面向服务的演化过程中，我们期望建立统一的通讯平台和规范，抽象系统的资源，拆分业务，容器化。这是一个很有趣的过程，也是对我们的挑战。笔者也希望有机会与读者分享。</p><p>一不小心又挖下了好多明坑和无数暗坑，只是为了激励自己不断往前。在探索事物本质的旅途中，必然十分艰险，又十分有趣，沿途一定风光绚丽，让我们共勉。</p><h1 id="参考文献">参考文献</h1><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html">官方文档</a></p><h1 id="系列导读">系列导读</h1><p>本文是笔者《拥抱 Android Studio》系列第四篇，其他篇请点击：</p><p><a href="http://kvh.io/2015/12/01/embrace-android-studio-migration/">拥抱Android Studio 之一：从 ADT 到 Android Studio</a></p><p><a href="http://kvh.io/2015/12/17/embrace-android-studio-indepth/">拥抱Android Studio 之二：Android Studio 与 Gradle 深入</a></p><p><a href="http://kvh.io/2016/01/04/embrace-android-studio-groovy-gradle/">拥抱Android Studio 之三：溯源，Groovy 与 Gradle 基础</a></p><p><a href="http://kvh.io/2016/01/20/embrace-android-studio-maven-deploy/">拥抱Android Studio 之四：Maven 公共仓库使用与私有仓库搭建</a></p><p><a href="http://kvh.io/2016/03/28/embrace-android-studio-gradle-plugin/">拥抱Android Studio 之五：Gradle 插件使用与开发</a></p><blockquote><p>有问题？在文章下留言或者加 qq 群：453503476，希望能帮到你。想要及时收到最新博客文章，请关注：</p></blockquote><h1 id="番外">番外</h1><p>笔者 <a href="http://kvh.io">kvh</a> 在开发和运营 <a href="https://bugtags.com">bugtags.com</a>，这是一款移动时代首选的 bug管理系统，能够极大的提升 app 开发者的测试效率，欢迎使用、转发推荐。</p><p>笔者目前关注点在于移动 SDK 研发，后端服务设计和实现。</p><p>我们团队长期求 PHP 后端研发，有兴趣请加下面公众号勾搭：</p><figure><img src="https://raw.githubusercontent.com/changbinhe/images/master/16-1-29/87155741.jpg" alt="bugtags"><figcaption aria-hidden="true">bugtags</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.gradle.org/current/userguide/custom_plugins.html&quot;&gt;官方文档&lt;/a&gt;给出了比较详细的实现步骤，本文的脉络会跟官方文档差不了太多，额外增补实际例子和一些实践经验。文中的代码已经托管到了
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="Android" scheme="https://0xkevinhe.xyz/tags/Android/"/>
    
      <category term="EmbraceAndroidStudio" scheme="https://0xkevinhe.xyz/tags/EmbraceAndroidStudio/"/>
    
      <category term="拥抱 Android Studio" scheme="https://0xkevinhe.xyz/tags/%E6%8B%A5%E6%8A%B1-Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>如何更好的提出技术问题</title>
    <link href="https://0xkevinhe.xyz/a-good-question.html"/>
    <id>https://0xkevinhe.xyz/a-good-question.html</id>
    <published>2016-02-03T03:18:16.000Z</published>
    <updated>2023-09-27T07:01:22.144Z</updated>
    
    <content type="html"><![CDATA[<p>下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。 笔者从事 <a href="https://bugtags.com">Bugtags.com</a>开发运营以来，除了开发任务以外，最重要的工作就是在 qq群里面回答用户的问题。</p><p>这半年来，少说也接待了上千个用户了。笔者发现，有相当一部分的用户，提问方式和技巧都有问题，这样导致了我们额外的客服量，也使得自己的问题得不到及时满意的回答。</p><p>下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。</p><h1 id="直接了当">直接了当</h1><p>有的用户，喜欢先问：『有人在吗？』</p><p>其实这个问句真的是很无意义，有问题直接提出来就好，有工作人员或者热心人看到了，能回答的自然就会回答，为什么还需要问有没有人在家呢？</p><h1 id="目的明确">目的明确</h1><p>有的用户，其实只是对某些技术点感兴趣，但是表现出来，是要给我们反馈bug。这样我们就很摸不着头脑。</p><p>是吐槽、建议、反馈、赞扬还是学习？请一上来就说明。</p><h1 id="有价值">有价值</h1><p>列举一些个人认为没有价值的问题：</p><ul><li>PHP 是不是最好的语言？</li><li>VIM 还是 Emacs 好？</li><li>学 Android 有没有前途？</li></ul><p>这种问题，没有讨论的价值。</p><h1 id="已尝试求解">已尝试求解</h1><p>其实大部分我们遇到的技术问题，只要在谷歌或者百度上查找，大多能找到答案。</p><p>大部分情况下，使用 Bugtags遇到的问题，都能通过我们的帮助文档解决。</p><p>但是我发现中国人真的很着急，文档也不看，帮助也不看，上来就问。</p><h1 id="问题着眼点小">问题着眼点小</h1><p>切忌提一些特别大的问题，例如『安卓如何管理内存』，这种是需要一些列文章才能阐述清楚的问题，显然是不适合在QQ 群上提问的。</p><h1 id="背景信息充足">背景信息充足</h1><p>举个例子，Bugtags SDK 支持 Android 和iOS，但是大部分用户提问的时候，会忽略了这个信息。同样，常用的操作系统，也有OSX 和 Windows，很多人也会忽略。</p><p>这里面其实有个思维盲点，提出问题的人，会忽略一些显而易见的环境差异，认为别人了解背景信息，具有跟他一样的运行环境和操作步骤。</p><h1 id="问题描述信息充分">问题描述信息充分</h1><p>这个也需要换位思考，假设你是一个热心人，尝试帮助群上的人解答问题。是不是希望问题越准确越好？</p><p>一些要点请备齐：</p><ul><li>软硬环境及版本</li><li>操作步骤</li><li>期待结果</li><li>错误信息，最好是文本而不是截图</li><li>设备运行的 log</li><li>现场截图</li><li>已尝试过的解决方案</li><li>怀疑的点</li></ul><h1 id="重现问题的-demo">重现问题的 Demo</h1><ul><li>创建你自己的 demo 程序，操作要友好</li><li>加上使用说明，描述你所遇到的问题，具体环境，操作步骤，帮助别人快速重现你的问题</li><li>打包你的 demo，上传到 github 或者百度云盘，让别人可以很快下载到</li></ul><h1 id="一个范例">一个范例</h1><p><a href="http://stackoverflow.com/questions/34804039/android-testing-of-the-floating-view">stack-overflow</a></p><h1 id="总结">总结</h1><p>提问技巧，也是属于沟通技巧之一。</p><p>笔者认为要达到有效的沟通，双方都需要有同理心，要换位思考。</p><p>愿这篇文章能为大家带来一些启发，能够收获更多满意的答案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面咱们就来聊聊技术人的素养：如何更好的提出技术问题。 笔者从事 &lt;a href=&quot;https://bugtags.com&quot;&gt;Bugtags.com&lt;/a&gt;
开发运营以来，除了开发任务以外，最重要的工作就是在 qq
群里面回答用户的问题。&lt;/p&gt;
&lt;p&gt;这半年来，少说也接待
      
    
    </summary>
    
      <category term="code" scheme="https://0xkevinhe.xyz/categories/code/"/>
    
    
      <category term="程序员必读" scheme="https://0xkevinhe.xyz/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
